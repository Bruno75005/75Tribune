### Résumé des fichiers trouvés dans C:\wamp64\www\75Tribune ###

===== C:\wamp64\www\75Tribune\next-env.d.ts =====

/// <reference types="next" />
/// <reference types="next/image-types/global" />

// NOTE: This file should not be edited
// see https://nextjs.org/docs/app/building-your-application/configuring/typescript for more information.


================================================================================

===== C:\wamp64\www\75Tribune\next.config.js =====

/** @type {import('next').NextConfig} */
const nextConfig = {
  webpack: (config, { isServer }) => {
    // Add optimization settings
    config.optimization = {
      ...config.optimization,
      moduleIds: 'deterministic',
      chunkIds: 'deterministic'
    }
    return config
  }
}

module.exports = nextConfig


================================================================================

===== C:\wamp64\www\75Tribune\package.json =====

{
  "name": "75Tribune",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start",
    "lint": "next lint"
  },
  "dependencies": {
    "@auth/prisma-adapter": "^2.7.4",
    "@heroicons/react": "^2.2.0",
    "@hookform/resolvers": "^3.9.1",
    "@prisma/client": "^6.0.0",
    "@radix-ui/react-avatar": "^1.1.1",
    "@radix-ui/react-dialog": "^1.1.2",
    "@radix-ui/react-dropdown-menu": "^2.1.2",
    "@radix-ui/react-label": "^2.1.0",
    "@radix-ui/react-select": "^2.1.2",
    "@radix-ui/react-separator": "^1.1.0",
    "@radix-ui/react-slot": "^1.1.0",
    "@radix-ui/react-switch": "^1.1.1",
    "@radix-ui/react-toast": "^1.2.2",
    "@tanstack/react-table": "^8.20.5",
    "@tiptap/extension-code-block-lowlight": "^2.10.3",
    "@tiptap/extension-color": "^2.10.3",
    "@tiptap/extension-highlight": "^2.10.3",
    "@tiptap/extension-image": "^2.10.3",
    "@tiptap/extension-link": "^2.10.3",
    "@tiptap/extension-placeholder": "^2.10.3",
    "@tiptap/extension-subscript": "^2.10.3",
    "@tiptap/extension-superscript": "^2.10.3",
    "@tiptap/extension-table": "^2.10.3",
    "@tiptap/extension-table-cell": "^2.10.3",
    "@tiptap/extension-table-header": "^2.10.3",
    "@tiptap/extension-table-row": "^2.10.3",
    "@tiptap/extension-text-align": "^2.10.3",
    "@tiptap/extension-text-style": "^2.10.3",
    "@tiptap/extension-typography": "^2.10.3",
    "@tiptap/extension-underline": "^2.10.3",
    "@tiptap/pm": "^2.10.3",
    "@tiptap/react": "^2.10.3",
    "@tiptap/starter-kit": "^2.10.3",
    "@types/bcrypt": "^5.0.2",
    "@types/form-data": "^2.2.1",
    "@types/formidable": "^3.4.5",
    "@types/node-fetch": "^2.6.12",
    "@types/prismjs": "^1.26.5",
    "@types/react": "^18.2.45",
    "@types/react-dom": "^18.2.17",
    "bcrypt": "^5.1.1",
    "bcryptjs": "^2.4.3",
    "class-variance-authority": "^0.7.1",
    "clsx": "^2.1.1",
    "date-fns": "^4.1.0",
    "form-data": "^4.0.2",
    "formidable": "^3.5.2",
    "framer-motion": "^11.13.1",
    "googleapis": "^144.0.0",
    "highlight.js": "^11.10.0",
    "jose": "^5.1.3",
    "jsonwebtoken": "^9.0.2",
    "lowlight": "^3.2.0",
    "lucide-react": "^0.294.0",
    "next": "^14.0.4",
    "next-auth": "^4.24.7",
    "next-themes": "^0.4.3",
    "node-fetch": "^3.3.2",
    "nodemailer": "^6.9.16",
    "prism-react-renderer": "^2.4.0",
    "prismjs": "^1.29.0",
    "react": "^18.2.0",
    "react-dom": "^18.2.0",
    "react-hook-form": "^7.53.2",
    "react-hot-toast": "^2.4.1",
    "react-query": "^3.39.3",
    "slate": "^0.101.5",
    "slate-react": "^0.101.5",
    "slugify": "^1.6.6",
    "sonner": "^1.7.0",
    "tailwind-merge": "^2.5.5",
    "twitter-api-v2": "^1.18.2",
    "zod": "^3.23.8",
    "zustand": "^4.4.7"
  },
  "devDependencies": {
    "@types/bcryptjs": "^2.4.6",
    "@types/hast": "^3.0.4",
    "@types/jsonwebtoken": "^9.0.5",
    "@types/node": "^22.10.1",
    "@types/nodemailer": "^6.4.17",
    "autoprefixer": "^10.4.16",
    "eslint": "^8.55.0",
    "eslint-config-next": "^14.0.4",
    "postcss": "^8.4.32",
    "prisma": "^6.0.0",
    "tailwindcss": "^3.3.6",
    "tailwindcss-animate": "^1.0.7",
    "typescript": "^5.3.3"
  }
}


================================================================================

===== C:\wamp64\www\75Tribune\postcss.config.js =====

module.exports = {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
}


================================================================================

===== C:\wamp64\www\75Tribune\README.md =====

# 75Tribune - Plateforme de Contenu Premium

Une plateforme SaaS moderne permettant à l'administrateur de publier du contenu premium et de gérer des abonnements. Les utilisateurs peuvent accéder au contenu selon leur niveau d'abonnement. Intègre des capacités d'IA avancées grâce à Ollama.

## 🚀 Fonctionnalités

### 👨‍💼 Administration du Blog
- 📝 Interface administrateur pour la publication de contenu
- 🎯 Gestion des niveaux d'accès par article
- 🏷️ Organisation par catégories
- 📈 Analytics et suivi des articles

### 💎 Système d'Abonnement

#### Plans d'Accès
- 🆓 **Accès Gratuit**
  - Lecture d'articles publics
  - Création de compte
  - Accès limité aux ressources

- 💫 **Accès Premium**
  - Accès à tous les articles
  - Fonctionnalités exclusives
  - Support prioritaire

### 🎯 Gestion du Contenu
- 📄 Création et édition d'articles avec éditeur riche (TipTap)
- 🌟 Système de catégorisation
- 📊 Gestion des droits d'accès
- 🔍 Recherche avancée

### ⚙️ Fonctionnalités Techniques
- 🔐 Authentification complète (JWT + Next-Auth)
- 📧 Système de vérification par email
- 🎨 Interface utilisateur moderne avec Tailwind CSS
- 🌓 Mode sombre/clair
- 📱 Design responsive

## 📋 Prérequis

- Node.js 18.x ou supérieur
- MySQL
- WAMP/XAMPP (pour le développement local)

## 🛠️ Installation

1. Clonez le dépôt :
```bash
git clone [url-du-repo]
cd 75Tribune
```

2. Installez les dépendances :
```bash
npm install
```

3. Configurez les variables d'environnement :
```bash
cp .env.example .env
```
Puis modifiez le fichier `.env` avec vos configurations :
- `DATABASE_URL`: URL de connexion MySQL
- `NEXTAUTH_SECRET`: Clé secrète pour l'authentification
- `SMTP_*`: Configuration pour l'envoi d'emails
- `NEXT_PUBLIC_APP_URL`: URL de votre application

4. Initialisez la base de données :
```bash
npx prisma generate
npx prisma db push
```

5. Lancez le serveur de développement :
```bash
npm run dev
```

6. Pour la production :
```bash
npm run build
npm run start
```

## 🏗️ Structure du Projet

```
75Tribune/
├── src/
│   ├── app/                # Routes et pages Next.js
│   │   ├── (admin)/       # Routes administrateur
│   │   ├── (auth)/        # Routes authentification
│   │   ├── api/           # API Routes
│   │   └── articles/      # Gestion des articles
│   ├── components/        # Composants React
│   ├── lib/              # Utilitaires et configurations
│   └── types/            # Types TypeScript
├── prisma/               # Schéma et migrations Prisma
└── public/              # Fichiers statiques
```

## 🔧 Technologies Utilisées

- **Framework** : Next.js 14
- **Langage** : TypeScript
- **UI** : 
  - Tailwind CSS
  - Radix UI
  - Lucide Icons
- **Base de données** : 
  - MySQL 
  - Prisma ORM
- **Authentification** : 
  - NextAuth.js
  - JWT
- **Éditeur** : TipTap
- **Emails** : Nodemailer
- **Validation** : Zod
- **Notifications** : React Hot Toast

## 🔐 Sécurité

- Authentification JWT
- Vérification des emails
- Protection CSRF
- Validation des entrées
- Hachage des mots de passe (bcrypt)
- Middleware de protection des routes

## 🚀 Déploiement

1. Assurez-vous d'avoir configuré toutes les variables d'environnement
2. Exécutez `npm run build`
3. Démarrez avec `npm run start`

## 📝 Licence

Ce projet est sous licence MIT. Voir le fichier `LICENSE` pour plus de détails.

## 🤝 Contribution

Les contributions sont les bienvenues ! Veuillez suivre ces étapes :

1. Fork le projet
2. Créer une branche (`git checkout -b feature/AmazingFeature`)
3. Commit vos changements (`git commit -m 'Add some AmazingFeature'`)
4. Push vers la branche (`git push origin feature/AmazingFeature`)
5. Ouvrir une Pull Request

## 📧 Contact

Pour toute question ou suggestion, n'hésitez pas à nous contacter.

## 🙏 Remerciements

Un grand merci à tous les contributeurs qui ont aidé à faire de ce projet une réalité !


================================================================================

===== C:\wamp64\www\75Tribune\tailwind.config.ts =====

import type { Config } from 'tailwindcss'

const config: Config = {
  darkMode: ['class'], // Activation du mode sombre via la classe "dark"
  content: [
    './src/**/*.{js,ts,jsx,tsx,mdx}',
    './src/pages/**/*.{js,ts,jsx,tsx,mdx}',
    './src/components/**/*.{js,ts,jsx,tsx,mdx}',
    './src/app/**/*.{js,ts,jsx,tsx,mdx}',
  ],
  theme: {
    container: {
      center: true,
      padding: '2rem',
      screens: {
        '2xl': '1400px',
      },
    },
    extend: {
      // NOUVELLE PALETTE DE COULEURS
      colors: {
        // Couleurs principales pour le mode clair
        lightBg: '#F7FAFC',          // fond clair
        lightText: '#1A202C',        // texte foncé
        primary: {
          DEFAULT: '#2563eb',       // un bleu un peu plus vif
          foreground: '#ffffff',    // texte sur fond bleu
        },
        secondary: {
          DEFAULT: '#8b5cf6',       // violet
          foreground: '#ffffff',
        },
        accent: {
          DEFAULT: '#ec4899',       // rose un peu flashy
          foreground: '#ffffff',
        },
        destructive: {
          DEFAULT: '#ef4444',       // rouge
          foreground: '#ffffff',
        },
        // Couleurs principales pour le mode sombre
        darkBg: '#111827',
        darkText: '#F3F4F6',

        // On conserve les variables "CSS" existantes si vous les utilisez en d’autres endroits:
        border: 'hsl(var(--border))',
        input: 'hsl(var(--input))',
        ring: 'hsl(var(--ring))',
        background: 'hsl(var(--background))',
        foreground: 'hsl(var(--foreground))',
        // On redéfinit également les groupements ci-dessous,
        // si vous faites usage des classes .bg-card, .bg-popover, etc.
        muted: {
          DEFAULT: 'hsl(var(--muted))',
          foreground: 'hsl(var(--muted-foreground))',
        },
        popover: {
          DEFAULT: 'hsl(var(--popover))',
          foreground: 'hsl(var(--popover-foreground))',
        },
        card: {
          DEFAULT: 'hsl(var(--card))',
          foreground: 'hsl(var(--card-foreground))',
        },
      },
      fontFamily: {
        // Police plus « moderne » (inter, roboto, etc.)
        headline: ['Inter', 'sans-serif'],
        body: ['Inter', 'sans-serif'],
      },
      borderRadius: {
        lg: 'var(--radius)',
        md: 'calc(var(--radius) - 2px)',
        sm: 'calc(var(--radius) - 4px)',
      },
      keyframes: {
        'accordion-down': {
          from: { height: '0' },
          to:   { height: 'var(--radix-accordion-content-height)' },
        },
        'accordion-up': {
          from: { height: 'var(--radix-accordion-content-height)' },
          to:   { height: '0' },
        },
        'slide-from-left': {
          '0%':   { transform: 'translateX(-100%)' },
          '100%': { transform: 'translateX(0)' },
        },
        'slide-to-left': {
          '0%':   { transform: 'translateX(0)' },
          '100%': { transform: 'translateX(-100%)' },
        },
        'fade-in': {
          from: { opacity: '0' },
          to:   { opacity: '1' },
        },
        'fade-out': {
          from: { opacity: '1' },
          to:   { opacity: '0' },
        },
      },
      animation: {
        'accordion-down': 'accordion-down 0.2s ease-out',
        'accordion-up':   'accordion-up 0.2s ease-out',
        'slide-from-left': 'slide-from-left 0.3s cubic-bezier(0.82, 0.085, 0.395, 0.895)',
        'slide-to-left':   'slide-to-left 0.3s cubic-bezier(0.82, 0.085, 0.395, 0.895)',
        'fade-in': 'fade-in 0.2s ease-out',
        'fade-out': 'fade-out 0.2s ease-out',
      },
    },
  },
  plugins: [
    require('tailwindcss-animate'), // Plugin pour animations (si utilisé ailleurs)
  ],
};

export default config;


================================================================================

===== C:\wamp64\www\75Tribune\tsconfig.json =====

{
  "compilerOptions": {
    "target": "es5",
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "paths": {
      "@/*": ["./src/*"]
    }
  },
  "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx", ".next/types/**/*.ts"],
  "exclude": ["node_modules"]
}


================================================================================

===== C:\wamp64\www\75Tribune\src\middleware.ts =====

import { withAuth } from 'next-auth/middleware';
import { NextResponse } from 'next/server';

export default withAuth(
  function middleware(req) {
    const token = req.nextauth.token;
    const isAdmin = token?.role === 'ADMIN';
    const path = req.nextUrl.pathname;

    // Si l'utilisateur est déjà connecté et essaie d'accéder à /login
    if (path === '/login' && token) {
      return NextResponse.redirect(new URL(isAdmin ? '/dashboard' : '/profile', req.url));
    }

    // Protection des routes admin
    if (path.startsWith('/dashboard')) {
      if (!isAdmin) {
        return NextResponse.redirect(new URL('/profile', req.url));
      }
    }

    return NextResponse.next();
  },
  {
    callbacks: {
      authorized: ({ req, token }) => {
        const path = req.nextUrl.pathname;
        // Permettre l'accès à /login même sans token
        if (path === '/login') return true;
        // Vérifier le token pour les autres routes protégées
        return !!token;
      },
    },
  }
);

export const config = {
  matcher: ['/dashboard/:path*', '/profile/:path*', '/login'],
};


================================================================================

===== C:\wamp64\www\75Tribune\src\app\ClientHome.tsx =====

"use client";

import Image from 'next/image';
import Link from 'next/link';
import { motion } from 'framer-motion';

// Définir une interface pour les articles
interface Article {
  id: string;
  slug: string;
  title: string;
  excerpt: string;
  featuredImage: string | null;
  // Ajoutez d'autres champs si nécessaire
}

interface ClientHomeProps {
  articles: Article[];
}

export default function ClientHome({ articles }: ClientHomeProps) {
  return (
    <main className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8">
      {/* Section Héroïque avec animation */}
      <motion.div
        initial={{ opacity: 0, y: 20 }}
        animate={{ opacity: 1, y: 0 }}
        transition={{ duration: 0.5 }}
        className="relative w-full h-96 mb-8"
      >
        <Image
          src="/hero-image.jpg" // Remplacez par votre image héroïque
          alt="Hero Image"
          fill
          className="object-cover"
        />
        <div className="absolute inset-0 bg-black/50 flex flex-col justify-center items-center text-white">
          <motion.h1
            initial={{ opacity: 0, y: 20 }}
            animate={{ opacity: 1, y: 0 }}
            transition={{ delay: 0.2, duration: 0.5 }}
            className="text-4xl font-bold mb-4"
          >
            Bienvenue sur 75Tribune
          </motion.h1>
          <motion.p
            initial={{ opacity: 0, y: 20 }}
            animate={{ opacity: 1, y: 0 }}
            transition={{ delay: 0.4, duration: 0.5 }}
            className="text-lg mb-6"
          >
            Découvrez nos derniers articles
          </motion.p>
          <motion.div
            initial={{ opacity: 0, y: 20 }}
            animate={{ opacity: 1, y: 0 }}
            transition={{ delay: 0.6, duration: 0.5 }}
          >
            <Link href="/articles" className="px-6 py-3 bg-nyt-blue text-white rounded-lg hover:bg-nyt-blue/90">
              Voir les articles
            </Link>
          </motion.div>
        </div>
      </motion.div>

      <h1 className="text-4xl font-headline mb-8 text-nyt-black dark:text-nyt-white">Latest News</h1>
      <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-8">
        {articles.length > 0 ? (
          articles.map((article, index) => (
            <motion.div
              key={article.id}
              initial={{ opacity: 0, y: 20 }}
              animate={{ opacity: 1, y: 0 }}
              transition={{ delay: index * 0.1, duration: 0.5 }}
              className="bg-nyt-white dark:bg-nyt-black shadow-sm"
            >
              {article.featuredImage && (
                <div className="relative w-full h-48">
                  <Image
                    src={article.featuredImage}
                    alt={article.title}
                    fill
                    className="object-cover"
                  />
                </div>
              )}
              <div className="p-4">
                <h2 className="text-xl font-headline mb-2 text-nyt-black dark:text-nyt-white">
                  <Link href={`/articles/${article.slug}`} className="hover:text-nyt-blue">
                    {article.title}
                  </Link>
                </h2>
                <p className="text-nyt-gray-500 dark:text-nyt-gray-200 font-body">
                  {article.excerpt}
                </p>
              </div>
            </motion.div>
          ))
        ) : (
          <p className="col-span-full text-center text-nyt-gray-500 dark:text-nyt-gray-200">
            Aucun article disponible pour le moment.
          </p>
        )}
      </div>
    </main>
  );
}

================================================================================

===== C:\wamp64\www\75Tribune\src\app\layout.tsx =====

// src/app/layout.tsx

import type { Metadata } from 'next';
import './globals.css'; // Assurez-vous que vous importez bien votre fichier global (où vous avez éventuellement d’autres classes)
import Navigation from '@/components/navigation/Navigation';
import Providers from '@/providers/Providers';
import { Toaster } from 'react-hot-toast';

export const metadata: Metadata = {
  title: '75Tribune - Plateforme de Blog Avancée',
  description: 'Une plateforme SaaS moderne avec des fonctionnalités de blog avancées',
};

export default function RootLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return (
    <html lang="fr" suppressHydrationWarning>
      {/* On applique la classe dark automatiquement si besoin */}
      <body className="bg-lightBg dark:bg-darkBg text-lightText dark:text-darkText transition-colors duration-300">
        <Providers>
          <div className="min-h-screen flex flex-col">
            {/* Barre de navigation principale */}
            <Navigation />
            <main className="flex-grow max-w-7xl mx-auto w-full px-4 sm:px-6 lg:px-8 py-8">
              {children}
            </main>
            {/* Pied de page */}
            <footer className="bg-gray-100 dark:bg-gray-900 py-6 transition-colors duration-300">
              <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
                <p className="text-center text-sm text-gray-500 dark:text-gray-400">
                  © 2025 75Tribune. Tous droits réservés.
                </p>
              </div>
            </footer>
          </div>
          <Toaster 
            position="top-center"
            toastOptions={{
              duration: 3000,
              style: {
                background: '#333',
                color: '#fff',
              },
              success: {
                duration: 3000,
                iconTheme: {
                  primary: '#4CAF50',
                  secondary: '#fff',
                },
              },
              error: {
                duration: 4000,
                iconTheme: {
                  primary: '#f44336',
                  secondary: '#fff',
                },
              },
            }}
          />
        </Providers>
      </body>
    </html>
  );
}



================================================================================

===== C:\wamp64\www\75Tribune\src\app\page.tsx =====

import Image from 'next/image';
import Link from 'next/link';
import { ArticleService } from '@/services/article.service';

export default async function Home() {
  // Récupérer les articles publiés
  const { articles } = await ArticleService.list({
    status: 'PUBLISHED',
    page: 1,
    limit: 9,
  });

  return (
    <main className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8">
      <h1 className="text-4xl font-headline mb-8 text-primary">
        Derniers Articles
      </h1>
      <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-8">
        {articles.length > 0 ? (
          articles.map((article) => (
            <div
              key={article.id}
              className="bg-white dark:bg-gray-800 shadow-sm rounded-lg overflow-hidden transition-colors duration-300"
            >
              {article.featuredImage && (
                <div className="relative w-full h-48">
                  <Image
                    src={article.featuredImage}
                    alt={article.title}
                    fill
                    className="object-cover"
                  />
                </div>
              )}
              <div className="p-4">
                <h2 className="text-xl font-headline mb-2 text-lightText dark:text-darkText transition-colors duration-300">
                  <Link
                    href={`/articles/${article.slug}`}
                    className="hover:text-accent"
                  >
                    {article.title}
                  </Link>
                </h2>
                <p className="text-sm text-gray-600 dark:text-gray-300">
                  {article.excerpt}
                </p>
              </div>
            </div>
          ))
        ) : (
          <p className="col-span-full text-center text-gray-500 dark:text-gray-300">
            Aucun article disponible pour le moment.
          </p>
        )}
      </div>
    </main>
  );
}


================================================================================

===== C:\wamp64\www\75Tribune\src\app\(admin)\layout.tsx =====

'use client';

import { Bell } from 'lucide-react';
import { ThemeToggle } from '@/components/ui/ThemeToggle';

export default function AdminLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return (
    <div className="min-h-screen bg-gray-100 dark:bg-gray-900">
      <div className="bg-white dark:bg-gray-800 shadow">
        <div className="container p-4">
          <div className="flex justify-between items-center mb-6">
            <h2 className="text-xl font-semibold text-gray-800 dark:text-white">Dashboard</h2>
            <div className="flex items-center space-x-4">
              <button 
                className="p-2 rounded-lg text-gray-600 hover:bg-gray-100 dark:text-gray-300 dark:hover:bg-gray-700"
                aria-label="Notifications"
              >
                <Bell size={20} />
              </button>
              <ThemeToggle />
            </div>
          </div>
        </div>
      </div>
      <div className="container p-4">
        {children}
      </div>
    </div>
  );
}


================================================================================

===== C:\wamp64\www\75Tribune\src\app\(admin)\dashboard\layout.tsx =====

'use client';

import { useState, useEffect } from 'react';
import { useRouter, usePathname } from 'next/navigation';
import Link from 'next/link';
import { 
  LayoutDashboard, 
  FileText, 
  Users, 
  Settings, 
  LogOut,
  Menu as MenuIcon,
  X,
  FolderTree,
  Bell,
  User,
  ChevronDown
} from 'lucide-react';
import { useSession, signOut } from 'next-auth/react';

const menuItems = [
  {
    title: 'Tableau de bord',
    icon: LayoutDashboard,
    href: '/dashboard'
  },
  {
    title: 'Articles',
    icon: FileText,
    href: '/dashboard/articles'
  },
  {
    title: 'Catégories',
    icon: FolderTree,
    href: '/dashboard/categories'
  },
  {
    title: 'Abonnés',
    icon: Users,
    href: '/dashboard/subscribers'
  },
  {
    title: 'Paramètres',
    icon: Settings,
    href: '/dashboard/settings'
  }
];

export default function DashboardLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  const [sidebarOpen, setSidebarOpen] = useState(false);
  const [sidebarCollapsed, setSidebarCollapsed] = useState(false);
  const [userMenuOpen, setUserMenuOpen] = useState(false);
  const router = useRouter();
  const pathname = usePathname();
  const { data: session } = useSession();

  // Fermer le menu latéral sur mobile lors du changement de page
  useEffect(() => {
    setSidebarOpen(false);
  }, [pathname]);

  // Sauvegarder l'état du sidebar dans le localStorage
  useEffect(() => {
    const savedState = localStorage.getItem('sidebarCollapsed');
    if (savedState !== null) {
      setSidebarCollapsed(JSON.parse(savedState));
    }
  }, []);

  useEffect(() => {
    localStorage.setItem('sidebarCollapsed', JSON.stringify(sidebarCollapsed));
  }, [sidebarCollapsed]);

  // Fermer les menus au clic en dehors
  useEffect(() => {
    const handleClickOutside = (event: MouseEvent) => {
      const target = event.target as HTMLElement;
      if (!target.closest('#sidebar') && !target.closest('#sidebar-button')) {
        setSidebarOpen(false);
      }
      if (!target.closest('#user-menu') && !target.closest('#user-menu-button')) {
        setUserMenuOpen(false);
      }
    };

    document.addEventListener('mousedown', handleClickOutside);
    return () => document.removeEventListener('mousedown', handleClickOutside);
  }, []);

  const handleLogout = async () => {
    await signOut({ redirect: false });
    router.push('/login');
  };

  const toggleSidebar = () => {
    setSidebarCollapsed(!sidebarCollapsed);
  };

  return (
    <div className="min-h-screen bg-gray-50 dark:bg-gray-900">
      {/* Header */}
      <header className="fixed top-0 left-0 right-0 z-50 bg-white dark:bg-gray-800 border-b border-gray-200 dark:border-gray-700">
        <div className="flex items-center justify-between px-4 h-16">
          {/* Logo et bouton menu */}
          <div className="flex items-center">
            <button
              id="sidebar-button"
              onClick={() => setSidebarOpen(!sidebarOpen)}
              className="p-2 rounded-lg lg:hidden text-gray-600 hover:bg-gray-100 dark:text-gray-300 dark:hover:bg-gray-700"
            >
              {sidebarOpen ? <X size={24} /> : <MenuIcon size={24} />}
            </button>
            <button
              onClick={toggleSidebar}
              className="hidden lg:flex p-2 rounded-lg text-gray-600 hover:bg-gray-100 dark:text-gray-300 dark:hover:bg-gray-700"
              title={sidebarCollapsed ? "Déplier le menu" : "Replier le menu"}
            >
              <MenuIcon size={24} />
            </button>
            <Link href="/dashboard" className="ml-3 lg:ml-0">
              <h1 className="text-xl font-bold text-primary-600 dark:text-primary-400">
                {!sidebarCollapsed && <span>75Tribune</span>}
              </h1>
            </Link>
          </div>

          {/* Actions de droite */}
          <div className="flex items-center space-x-4">
            <button className="p-2 rounded-lg text-gray-600 hover:bg-gray-100 dark:text-gray-300 dark:hover:bg-gray-700">
              <Bell size={20} />
            </button>
            <div className="relative">
              <button
                id="user-menu-button"
                onClick={() => setUserMenuOpen(!userMenuOpen)}
                className="flex items-center space-x-2 p-2 rounded-lg text-gray-600 hover:bg-gray-100 dark:text-gray-300 dark:hover:bg-gray-700"
              >
                <User size={20} />
                <span className="hidden sm:block">{session?.user?.name}</span>
                <ChevronDown size={16} />
              </button>
              {userMenuOpen && (
                <div
                  id="user-menu"
                  className="absolute right-0 mt-2 w-48 py-2 bg-white dark:bg-gray-800 rounded-lg shadow-lg border border-gray-200 dark:border-gray-700"
                >
                  <a href="/dashboard/profile" className="block px-4 py-2 text-gray-600 hover:bg-gray-100 dark:text-gray-300 dark:hover:bg-gray-700">
                    Profil
                  </a>
                  <button
                    onClick={handleLogout}
                    className="w-full text-left px-4 py-2 text-gray-600 hover:bg-gray-100 dark:text-gray-300 dark:hover:bg-gray-700"
                  >
                    Se déconnecter
                  </button>
                </div>
              )}
            </div>
          </div>
        </div>
      </header>

      {/* Sidebar */}
      <aside
        id="sidebar"
        className={`fixed top-16 left-0 z-40 h-[calc(100vh-4rem)] transition-all duration-300 ${
          sidebarOpen ? 'translate-x-0' : '-translate-x-full'
        } lg:translate-x-0 ${
          sidebarCollapsed ? 'w-16' : 'w-64'
        }`}
      >
        <nav className="relative h-full px-3 py-4 overflow-y-auto bg-white dark:bg-gray-800 border-r border-gray-200 dark:border-gray-700">
          <ul className="space-y-1">
            {menuItems.map((item) => {
              const Icon = item.icon;
              const isActive = pathname === item.href;
              return (
                <li key={item.href}>
                  <Link
                    href={item.href}
                    className={`flex items-center p-3 rounded-lg group transition-colors ${
                      isActive
                        ? 'bg-primary-50 text-primary-600 dark:bg-primary-900/50 dark:text-primary-400'
                        : 'text-gray-600 hover:bg-gray-100 dark:text-gray-300 dark:hover:bg-gray-700'
                    }`}
                    title={sidebarCollapsed ? item.title : undefined}
                  >
                    <Icon className={`w-5 h-5 ${isActive ? 'text-primary-600 dark:text-primary-400' : ''}`} />
                    {!sidebarCollapsed && <span className="ml-3">{item.title}</span>}
                  </Link>
                </li>
              );
            })}
          </ul>
        </nav>
      </aside>

      {/* Main content */}
      <main className={`min-h-screen pt-10 transition-all duration-300 ${
        sidebarCollapsed ? 'lg:pl-16' : 'lg:pl-64'
      } w-full`}>
        <div className="p-4 w-full">
          {children}
        </div>
      </main>

      {/* Overlay pour mobile */}
      {sidebarOpen && (
        <div
          className="fixed inset-0 z-30 bg-gray-900 bg-opacity-50 lg:hidden"
          onClick={() => setSidebarOpen(false)}
        />
      )}
    </div>
  );
}


================================================================================

===== C:\wamp64\www\75Tribune\src\app\(admin)\dashboard\page.tsx =====

'use client';

import { 
  Users, 
  FileText, 
  TrendingUp, 
  DollarSign,
  FolderTree,
  Settings,
  Tag,
  UserPlus
} from 'lucide-react';
import Link from 'next/link';
import { useEffect, useState } from 'react';

interface DashboardStats {
  subscribers: { total: number; growth: string };
  articles: { total: number; growth: string };
  views: { total: number; growth: string };
  revenue: { total: string; growth: string };
}

export default function DashboardPage() {
  const [stats, setStats] = useState([
    {
      title: 'Total Abonnés',
      value: '0',
      icon: Users,
      trend: '+0%',
      trendUp: true
    },
    {
      title: 'Articles Publiés',
      value: '0',
      icon: FileText,
      trend: '+0%',
      trendUp: true
    },
    {
      title: 'Vues Totales',
      value: '0',
      icon: TrendingUp,
      trend: '+0%',
      trendUp: true
    },
    {
      title: 'Revenus Mensuels',
      value: '0€',
      icon: DollarSign,
      trend: '+0%',
      trendUp: true
    }
  ]);

  useEffect(() => {
    const fetchStats = async () => {
      try {
        const response = await fetch('/api/dashboard/stats');
        if (!response.ok) throw new Error('Erreur lors de la récupération des statistiques');
        
        const data: DashboardStats = await response.json();
        
        setStats([
          {
            title: 'Total Abonnés',
            value: data.subscribers.total.toString(),
            icon: Users,
            trend: `${Number(data.subscribers.growth) >= 0 ? '+' : ''}${data.subscribers.growth}%`,
            trendUp: Number(data.subscribers.growth) >= 0
          },
          {
            title: 'Articles Publiés',
            value: data.articles.total.toString(),
            icon: FileText,
            trend: `${Number(data.articles.growth) >= 0 ? '+' : ''}${data.articles.growth}%`,
            trendUp: Number(data.articles.growth) >= 0
          },
          {
            title: 'Vues Totales',
            value: data.views.total.toString(),
            icon: TrendingUp,
            trend: `${Number(data.views.growth) >= 0 ? '+' : ''}${data.views.growth}%`,
            trendUp: Number(data.views.growth) >= 0
          },
          {
            title: 'Revenus Mensuels',
            value: `${data.revenue.total}€`,
            icon: DollarSign,
            trend: `${Number(data.revenue.growth) >= 0 ? '+' : ''}${data.revenue.growth}%`,
            trendUp: Number(data.revenue.growth) >= 0
          }
        ]);
      } catch (error) {
        console.error('Erreur lors de la récupération des statistiques:', error);
      }
    };

    fetchStats();
  }, []);

  return (
    <div className="space-y-6">
      {/* Stats Grid */}
      <div className="grid grid-cols-1 gap-6 sm:grid-cols-2 lg:grid-cols-4">
        {stats.map((stat, index) => {
          const Icon = stat.icon;
          return (
            <div
              key={index}
              className="p-6 bg-white dark:bg-gray-800 rounded-lg shadow-sm"
            >
              <div className="flex items-center">
                <div className="p-3 bg-primary-100 dark:bg-primary-900 rounded-full">
                  <Icon className="h-6 w-6 text-primary-600 dark:text-primary-400" />
                </div>
                <div className="ml-4">
                  <p className="text-sm font-medium text-gray-500 dark:text-gray-400">
                    {stat.title}
                  </p>
                  <p className="text-2xl font-semibold text-gray-900 dark:text-white">
                    {stat.value}
                  </p>
                </div>
              </div>
              <div className="mt-4">
                <div className="flex items-center">
                  <div
                    className={`inline-flex items-center px-2.5 py-0.5 rounded-full text-sm font-medium ${
                      stat.trendUp
                        ? 'bg-green-100 dark:bg-green-900 text-green-800 dark:text-green-200'
                        : 'bg-red-100 dark:bg-red-900 text-red-800 dark:text-red-200'
                    }`}
                  >
                    {stat.trend}
                  </div>
                  <span className="text-sm text-gray-500 dark:text-gray-400 ml-2">
                    vs mois dernier
                  </span>
                </div>
              </div>
            </div>
          );
        })}
      </div>

      {/* Actions rapides */}
      <div className="space-y-4">
        <h2 className="text-2xl font-bold">Actions rapides</h2>
        <div className="grid grid-cols-1 gap-4 sm:grid-cols-2 lg:grid-cols-4">
          <Link 
            href="/dashboard/categories"
            className="flex items-center p-4 bg-white dark:bg-gray-800 rounded-lg shadow-sm hover:shadow-md transition-shadow"
          >
            <FolderTree className="w-6 h-6 mr-3 text-blue-500" />
            <div>
              <h3 className="font-semibold">Catégories</h3>
              <p className="text-sm text-gray-500 dark:text-gray-400">Gérer les catégories</p>
            </div>
          </Link>

          <Link 
            href="/dashboard/tags"
            className="flex items-center p-4 bg-white dark:bg-gray-800 rounded-lg shadow-sm hover:shadow-md transition-shadow"
          >
            <Tag className="w-6 h-6 mr-3 text-green-500" />
            <div>
              <h3 className="font-semibold">Tags</h3>
              <p className="text-sm text-gray-500 dark:text-gray-400">Gérer les tags</p>
            </div>
          </Link>

          <Link 
            href="/dashboard/users"
            className="flex items-center p-4 bg-white dark:bg-gray-800 rounded-lg shadow-sm hover:shadow-md transition-shadow"
          >
            <UserPlus className="w-6 h-6 mr-3 text-purple-500" />
            <div>
              <h3 className="font-semibold">Utilisateurs</h3>
              <p className="text-sm text-gray-500 dark:text-gray-400">Gérer les utilisateurs</p>
            </div>
          </Link>

          <Link 
            href="/dashboard/settings"
            className="flex items-center p-4 bg-white dark:bg-gray-800 rounded-lg shadow-sm hover:shadow-md transition-shadow"
          >
            <Settings className="w-6 h-6 mr-3 text-orange-500" />
            <div>
              <h3 className="font-semibold">Paramètres</h3>
              <p className="text-sm text-gray-500 dark:text-gray-400">Configuration du site</p>
            </div>
          </Link>
        </div>
      </div>

      {/* Recent Activity */}
      <div className="bg-white dark:bg-gray-800 shadow-sm rounded-lg p-6">
        <h3 className="text-lg font-medium text-gray-900 dark:text-white mb-4">
          Activité Récente
        </h3>
        <div className="text-sm text-gray-500 dark:text-gray-400">
          Aucune activité récente
        </div>
      </div>
    </div>
  );
}


================================================================================

===== C:\wamp64\www\75Tribune\src\app\(admin)\dashboard\articles\page.tsx =====

'use client';

import { useState } from 'react';
import Link from 'next/link';
import Image from 'next/image';
import { 
  PlusCircle, 
  Search, 
  Filter,
  Eye,
  Lock,
  Pencil,
  Trash2,
  FileText,
  Globe,
  Youtube,
  Twitter
} from 'lucide-react';
import type { ArticleStatus, AccessLevel, Platform } from '@/types/article';
import { useArticles } from '@/hooks/useArticles';
import { useRouter } from 'next/navigation';
import { toast } from 'react-hot-toast';
import { normalizeImagePath } from '@/lib/image';

const statusColors: Record<ArticleStatus, string> = {
  DRAFT: 'bg-gray-100 text-gray-800 dark:bg-gray-700 dark:text-gray-300',
  PUBLISHED: 'bg-green-100 text-green-800 dark:bg-green-700 dark:text-green-300',
  ARCHIVED: 'bg-red-100 text-red-800 dark:bg-red-700 dark:text-red-300'
};

const accessLevelColors: Record<AccessLevel, string> = {
  FREE: 'bg-blue-100 text-blue-800 dark:bg-blue-700 dark:text-blue-300',
  BASIC: 'bg-purple-100 text-purple-800 dark:bg-purple-700 dark:text-purple-300',
  PRO: 'bg-yellow-100 text-yellow-800 dark:bg-yellow-700 dark:text-yellow-300'
};

interface PlatformInfo {
  name: string;
  icon: any;
  color: string;
}

const platforms: Record<Platform, PlatformInfo> = {
  wordpress: { name: 'WordPress', icon: Globe, color: 'text-blue-500' },
  youtube: { name: 'YouTube', icon: Youtube, color: 'text-red-500' },
  twitter: { name: 'Twitter', icon: Twitter, color: 'text-sky-500' }
};

export default function ArticlesPage() {
  const router = useRouter();
  const [currentPage, setCurrentPage] = useState(1);
  const [itemsPerPage] = useState(10);
  const [selectedStatus, setSelectedStatus] = useState<ArticleStatus | undefined>();
  const [selectedAccessLevel, setSelectedAccessLevel] = useState<AccessLevel | undefined>();
  const [searchTerm, setSearchTerm] = useState('');

  const { articles, loading, error, total, totalPages, deleteArticle } = useArticles({
    page: currentPage,
    limit: itemsPerPage,
    status: selectedStatus,
    accessLevel: selectedAccessLevel,
  });

  const handleDelete = async (id: string) => {
    if (window.confirm('Êtes-vous sûr de vouloir supprimer cet article ?')) {
      try {
        await deleteArticle(id);
        toast.success('Article supprimé avec succès');
      } catch (error) {
        toast.error('Erreur lors de la suppression de l\'article');
      }
    }
  };

  const handlePageChange = (page: number) => {
    setCurrentPage(page);
  };

  const handleStatusFilter = (status: ArticleStatus | undefined) => {
    setSelectedStatus(status);
    setCurrentPage(1); // Réinitialiser à la première page lors du filtrage
  };

  const handleAccessLevelFilter = (level: AccessLevel | undefined) => {
    setSelectedAccessLevel(level);
    setCurrentPage(1); // Réinitialiser à la première page lors du filtrage
  };

  const filteredArticles = articles.filter(article => {
    const matchesSearch = article.title.toLowerCase().includes(searchTerm.toLowerCase());
    return matchesSearch;
  });

  if (error) {
    return (
      <div className="p-4 text-red-500">
        Erreur lors de la récupération des articles: {error}
      </div>
    );
  }

  return (
    <div className="container mx-auto px-4 py-8">
      <div className="flex justify-between items-center mb-6">
        <h1 className="text-2xl font-bold text-gray-900 dark:text-white">Articles</h1>
        <Link 
          href="/dashboard/articles/new" 
          className="inline-flex items-center px-4 py-2 bg-primary text-white rounded-lg hover:bg-primary/90"
        >
          <PlusCircle className="w-5 h-5 mr-2" />
          Nouvel Article
        </Link>
      </div>

      <div className="bg-white dark:bg-gray-800 rounded-lg shadow">
        {/* Filtres */}
        <div className="p-4 border-b border-gray-200 dark:border-gray-700">
          <div className="flex flex-col md:flex-row gap-4">
            <div className="flex-1">
              <div className="relative">
                <Search className="absolute left-3 top-1/2 transform -translate-y-1/2 text-gray-400 dark:text-gray-500" />
                <input
                  type="text"
                  placeholder="Rechercher un article..."
                  className="w-full pl-10 pr-4 py-2 border rounded-lg dark:bg-gray-700 dark:border-gray-600 dark:text-white"
                  value={searchTerm}
                  onChange={(e) => setSearchTerm(e.target.value)}
                />
              </div>
            </div>
            <div className="flex gap-4">
              <select
                value={selectedStatus}
                onChange={(e) => handleStatusFilter(e.target.value as ArticleStatus | undefined)}
                className="px-4 py-2 border rounded-lg dark:bg-gray-700 dark:border-gray-600 dark:text-white"
              >
                <option value="">Tous les statuts</option>
                <option value="DRAFT">Brouillon</option>
                <option value="PUBLISHED">Publié</option>
                <option value="ARCHIVED">Archivé</option>
              </select>
              <select
                value={selectedAccessLevel}
                onChange={(e) => handleAccessLevelFilter(e.target.value as AccessLevel | undefined)}
                className="px-4 py-2 border rounded-lg dark:bg-gray-700 dark:border-gray-600 dark:text-white"
              >
                <option value="">Tous les niveaux</option>
                <option value="FREE">Gratuit</option>
                <option value="BASIC">Basic</option>
                <option value="PRO">Pro</option>
              </select>
            </div>
          </div>
        </div>

        {/* Liste des articles */}
        <div className="overflow-x-auto">
          <table className="w-full">
            <thead className="bg-gray-50 dark:bg-gray-700">
              <tr>
                <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-300 uppercase tracking-wider">
                  Article
                </th>
                <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-300 uppercase tracking-wider">
                  Status
                </th>
                <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-300 uppercase tracking-wider">
                  Accès
                </th>
                <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-300 uppercase tracking-wider">
                  Plateformes
                </th>
                <th className="px-6 py-3 text-right text-xs font-medium text-gray-500 dark:text-gray-300 uppercase tracking-wider">
                  Actions
                </th>
              </tr>
            </thead>
            <tbody className="bg-white dark:bg-gray-800 divide-y divide-gray-200 dark:divide-gray-700">
              {loading ? (
                <tr>
                  <td colSpan={5} className="px-6 py-4 text-center">
                    Chargement...
                  </td>
                </tr>
              ) : filteredArticles.length === 0 ? (
                <tr>
                  <td colSpan={5} className="px-6 py-4 text-center">
                    Aucun article trouvé
                  </td>
                </tr>
              ) : (
                filteredArticles.map((article) => (
                  <tr key={article.id}>
                    <td className="px-6 py-4">
                      <div className="flex items-start space-x-4">
                        {article.featuredImage && (
                          <div className="flex-shrink-0 w-12 h-12 relative">
                            <Image
                              src={normalizeImagePath(article.featuredImage)}
                              alt={article.title}
                              fill
                              className="object-cover rounded"
                            />
                          </div>
                        )}
                        <div>
                          <div className="text-sm font-medium text-gray-900 dark:text-white">
                            {article.title}
                          </div>
                          <div className="text-sm text-gray-500 dark:text-gray-400">
                            {article.excerpt}
                          </div>
                        </div>
                      </div>
                    </td>
                    <td className="px-6 py-4">
                      <span className={`px-2 inline-flex text-xs leading-5 font-semibold rounded-full ${statusColors[article.status]}`}>
                        {article.status === 'DRAFT' ? 'Brouillon' : article.status === 'PUBLISHED' ? 'Publié' : 'Archivé'}
                      </span>
                    </td>
                    <td className="px-6 py-4">
                      <span className={`px-2 inline-flex text-xs leading-5 font-semibold rounded-full ${accessLevelColors[article.accessLevel]}`}>
                        {article.accessLevel}
                      </span>
                    </td>
                    <td className="px-6 py-4">
                      <div className="flex space-x-2">
                        {article.publishPlatforms?.map((platform: Platform) => {
                          const PlatformIcon = platforms[platform]?.icon;
                          return PlatformIcon ? (
                            <PlatformIcon
                              key={platform}
                              className={`w-5 h-5 ${platforms[platform].color}`}
                              title={platforms[platform].name}
                            />
                          ) : null;
                        })}
                      </div>
                    </td>
                    <td className="px-6 py-4">
                      <div className="flex items-center justify-end space-x-2">
                        <button
                          onClick={() => router.push(`/articles/${article.slug}`)}
                          className="text-gray-600 dark:text-gray-400 hover:text-gray-900 dark:hover:text-gray-200"
                        >
                          <Eye className="w-5 h-5" />
                        </button>
                        <button
                          onClick={() => router.push(`/dashboard/articles/edit/${article.id}`)}
                          className="text-blue-600 dark:text-blue-400 hover:text-blue-900 dark:hover:text-blue-200"
                        >
                          <Pencil className="w-5 h-5" />
                        </button>
                        <button
                          onClick={() => handleDelete(article.id)}
                          className="text-red-600 dark:text-red-400 hover:text-red-900 dark:hover:text-red-200"
                        >
                          <Trash2 className="w-5 h-5" />
                        </button>
                      </div>
                    </td>
                  </tr>
                ))
              )}
            </tbody>
          </table>
          <div className="p-4">
            <nav aria-label="Page navigation">
              <ul className="inline-flex -space-x-px">
                {Array.from({ length: totalPages }, (_, i) => (
                  <li key={i}>
                    <button
                      onClick={() => handlePageChange(i + 1)}
                      className={`py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white ${currentPage === i + 1 ? 'bg-gray-100 text-gray-700 dark:bg-gray-700 dark:text-white' : ''}`}
                    >
                      {i + 1}
                    </button>
                  </li>
                ))}
              </ul>
            </nav>
          </div>
        </div>
      </div>
    </div>
  );
}


================================================================================

===== C:\wamp64\www\75Tribune\src\app\(admin)\dashboard\articles\edit\[id]\page.tsx =====

'use client';

import ArticleFormPage from '../../[action]/page';

export default function EditArticlePage({ params }: { params: { id: string } }) {
  return <ArticleFormPage params={{ action: 'edit', id: params.id }} />;
}

================================================================================

===== C:\wamp64\www\75Tribune\src\app\(admin)\dashboard\articles\[action]\page.tsx =====

'use client';

import { useEffect, useState } from 'react';
import { useRouter } from 'next/navigation';
import { X, Loader2 } from 'lucide-react';
import RichTextEditor from '@/components/editor/RichTextEditor';
import { toast } from 'react-hot-toast';
import { Switch } from '@/components/ui/switch';
import { Label } from '@/components/ui/label';
import { cn } from '@/lib/utils';
import { Button } from '@/components/ui/button';
import ImageUpload from '@/components/shared/ImageUpload';

interface ArticleFormData {
  title: string;
  excerpt: string;
  content: string;
  status: 'DRAFT' | 'PUBLISHED' | 'ARCHIVED';
  accessLevel: 'FREE' | 'BASIC' | 'PRO';
  tags: string[];
  categories: string[];
  featuredImage?: string;
  publishPlatforms?: string[];
}

interface ArticleFormPageProps {
  params: { action: string; id?: string };
}

export default function ArticleFormPage({ params }: ArticleFormPageProps) {
  const router = useRouter();
  const isEditing = params.action === 'edit';

  const [loading, setLoading] = useState(false);
  const [isPublishingToWordPress, setIsPublishingToWordPress] = useState(false);

  const [formData, setFormData] = useState<ArticleFormData>({
    title: '',
    excerpt: '',
    content: '',
    status: 'DRAFT',
    accessLevel: 'FREE',
    tags: [],
    categories: [],
    featuredImage: '',
    publishPlatforms: [],
  });

  const [categories, setCategories] = useState<Array<{ id: string; name: string }>>([]);
  const [currentTag, setCurrentTag] = useState('');

  // Chargement initial
  useEffect(() => {
    const fetchCategories = async () => {
      try {
        const response = await fetch('/api/categories', { credentials: 'include' });
        if (!response.ok) throw new Error('Erreur lors du chargement des catégories');
        const data = await response.json();
        setCategories(data);
      } catch (error) {
        console.error('Erreur:', error);
        toast.error('Erreur lors du chargement des catégories');
      }
    };
    fetchCategories();

    if (isEditing && params.id) {
      (async () => {
        setLoading(true);
        try {
          const response = await fetch(`/api/articles/${params.id}`, { credentials: 'include' });
          if (!response.ok) throw new Error('Article non trouvé');
          const data = await response.json();

          setFormData({
            title: data.title || '',
            excerpt: data.excerpt || '',
            content: data.content || '',
            status: data.status || 'DRAFT',
            accessLevel: data.accessLevel || 'FREE',
            tags: data.tags?.map((t: any) => t.name) || [],
            categories: data.categories?.map((c: any) => c.id) || [],
            featuredImage: data.featuredImage || '',
            publishPlatforms: data.publishPlatforms || [],
          });
        } catch (error) {
          console.error("Erreur lors du chargement de l'article:", error);
          toast.error("Erreur lors du chargement de l'article");
          router.push('/dashboard/articles');
        } finally {
          setLoading(false);
        }
      })();
    }
  }, [isEditing, params.id, router]);

  // Extraction auto de titre et excerpt
  useEffect(() => {
    if (!formData.content || (formData.title && formData.excerpt)) return;

    const parser = new DOMParser();
    const doc = parser.parseFromString(formData.content, 'text/html');

    if (!formData.title.trim()) {
      const possibleHeading = doc.querySelector('h1, h2, h3');
      if (possibleHeading?.textContent) {
        const autoTitle = possibleHeading.textContent.trim();
        if (autoTitle) {
          setFormData((prev) => ({ ...prev, title: autoTitle }));
        } else {
          callAIForTitle();
        }
      } else {
        callAIForTitle();
      }
    }

    if (!formData.excerpt.trim()) {
      const possibleParagraph = doc.querySelector('p');
      if (possibleParagraph?.textContent) {
        const rawText = possibleParagraph.textContent.trim();
        const autoExcerpt = rawText.substring(0, 150) + (rawText.length > 150 ? '…' : '');
        if (autoExcerpt) {
          setFormData((prev) => ({ ...prev, excerpt: autoExcerpt }));
        }
      }
    }
  }, [formData.content]);

  async function callAIForTitle() {
    try {
      await new Promise((r) => setTimeout(r, 1000));
      const aiResponse = await fetch('/api/ai/generate', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          prompt: `Générer un titre pour un article sur : ${formData.content.substring(0, 200)}`, 
          model: 'llama3.2:latest',
          tone: 'professional',
          type: 'title' // Ajouter ce champ pour identifier le type de requête
        }),
      });

      if (aiResponse.ok) {
        const { content } = await aiResponse.json();
        if (content && !formData.title.trim()) {
          setFormData((prev) => ({ ...prev, title: content }));
          toast.success(`Titre suggéré par l'IA : « ${content} »`);
        }
      }
    } catch (e) {
      console.error('Erreur appel IA :', e);
    }
  }

  const handlePublishToggle = (platform: string) => {
    setFormData((prev) => ({
      ...prev,
      publishPlatforms: prev.publishPlatforms?.includes(platform)
        ? prev.publishPlatforms.filter((p) => p !== platform)
        : [...(prev.publishPlatforms || []), platform],
    }));
  };

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    if (!formData.title.trim() || !formData.content.trim()) {
      return toast.error('Le titre et le contenu sont requis');
    }
    setLoading(true);

    try {
      const payload = {
        title: formData.title.trim(),
        content: formData.content.trim(),
        excerpt: formData.excerpt?.trim() || '',
        status: formData.status,
        accessLevel: formData.accessLevel,
        tags: formData.tags,
        categories: formData.categories,
        featuredImage: formData.featuredImage,
        publishPlatforms: formData.publishPlatforms,
      };

      const url = isEditing ? `/api/articles/${params.id}` : '/api/articles';
      const method = isEditing ? 'PUT' : 'POST';

      const response = await fetch(url, {
        method,
        headers: { 'Content-Type': 'application/json' },
        credentials: 'include',
        body: JSON.stringify(payload),
      });

      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(errorData.error || 'Erreur lors de la sauvegarde');
      }

      if (formData.publishPlatforms?.includes('wordpress')) {
        setIsPublishingToWordPress(true);
        toast.loading('Publication WordPress en cours…', { id: 'wp-publish' });

        try {
          const wpResponse = await fetch('/api/publish/wordpress', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            credentials: 'include',
            body: JSON.stringify(payload),
          });

          const wpData = await wpResponse.json();
          if (wpResponse.ok) {
            toast.success(`Publié sur WordPress : ${wpData.url}`, { id: 'wp-publish' });
          } else {
            throw new Error(wpData.error || 'Erreur WordPress');
          }
        } catch (wpError) {
          toast.error('Échec de la publication WordPress', { id: 'wp-publish' });
          console.error('Erreur WordPress:', wpError);
        } finally {
          setIsPublishingToWordPress(false);
        }
      }

      toast.success(isEditing ? 'Article mis à jour !' : 'Article créé avec succès !');
      router.push('/dashboard/articles');
    } catch (error) {
      toast.error('Erreur globale : ' + (error as Error).message);
      console.error('Erreur:', error);
    } finally {
      setLoading(false);
    }
  };

  const addTag = (e: React.KeyboardEvent) => {
    if (e.key === 'Enter' && currentTag.trim()) {
      e.preventDefault();
      if (!formData.tags.includes(currentTag.trim())) {
        setFormData((prev) => ({ ...prev, tags: [...prev.tags, currentTag.trim()] }));
      }
      setCurrentTag('');
    }
  };

  const removeTag = (tagToRemove: string) => {
    setFormData((prev) => ({
      ...prev,
      tags: prev.tags.filter((tag) => tag !== tagToRemove),
    }));
  };

  const handleImageUpload = (imageUrl: string) => {
    setFormData((prev) => ({ ...prev, featuredImage: imageUrl }));
  };

  const handleImageRemove = () => {
    setFormData((prev) => ({ ...prev, featuredImage: '' }));
  };

  if (loading) {
    return (
      <div className="flex items-center justify-center min-h-screen">
        <Loader2 className="h-8 w-8 animate-spin" />
      </div>
    );
  }

  return (
    <div className="container p-4 w-full">
      <div className="mb-6">
        <h1 className="text-2xl font-semibold text-gray-900 dark:text-white">
          {isEditing ? "Modifier l'article" : 'Nouvel article'}
        </h1>
      </div>

      <form onSubmit={handleSubmit} className="space-y-6">
        <div className="space-y-2">
          <Label htmlFor="featuredImage">Image mise en avant</Label>
          <ImageUpload
            value={formData.featuredImage}
            onChange={handleImageUpload}
            onRemove={handleImageRemove}
          />
        </div>

        <div>
          <Label htmlFor="title">Titre</Label>
          <input
            type="text"
            id="title"
            value={formData.title}
            onChange={(e) => setFormData((prev) => ({ ...prev, title: e.target.value }))}
            className="mt-1 block w-full px-4 py-2 rounded-lg border dark:border-gray-600
                       focus:ring-2 focus:ring-primary-500 focus:border-primary-500
                       dark:bg-gray-700 dark:text-white"
            required
          />
        </div>

        <div>
          <Label htmlFor="excerpt">Extrait</Label>
          <textarea
            id="excerpt"
            value={formData.excerpt}
            onChange={(e) => setFormData((prev) => ({ ...prev, excerpt: e.target.value }))}
            rows={3}
            className="mt-1 block w-full px-4 py-2 rounded-lg border dark:border-gray-600
                       focus:ring-2 focus:ring-primary-500 focus:border-primary-500
                       dark:bg-gray-700 dark:text-white"
          />
        </div>

        <div>
          <Label className="text-gray-700 dark:text-gray-300 mb-2 block">
            Plateformes de publication
          </Label>
          <div className="flex flex-row gap-4">
            {['wordpress', 'youtube', 'twitter'].map((platform) => (
              <div
                key={platform}
                className="flex-1 flex items-center justify-between p-2 rounded-lg
                           bg-white dark:bg-gray-800 border border-gray-200 dark:border-gray-700"
              >
                <span className="text-sm text-gray-700 dark:text-gray-300 capitalize">
                  {platform}
                </span>
                <Switch
                  checked={formData.publishPlatforms?.includes(platform)}
                  onCheckedChange={() => handlePublishToggle(platform)}
                  className={cn(
                    formData.publishPlatforms?.includes(platform)
                      ? 'bg-primary'
                      : 'bg-gray-200 dark:bg-gray-700'
                  )}
                />
              </div>
            ))}
          </div>

          {isPublishingToWordPress && (
            <div className="flex items-center space-x-2 text-sm text-gray-500
                            dark:text-gray-400 mt-2">
              <Loader2 className="w-4 h-4 animate-spin" />
              <span>Publication WordPress en cours…</span>
            </div>
          )}
        </div>

        <div className="space-y-2">
          <Label className="block text-sm font-medium text-gray-700 dark:text-gray-200">
            Catégories
          </Label>
          <div className="grid grid-cols-2 md:grid-cols-3 gap-4">
            {categories.map((category) => (
              <div key={category.id} className="flex items-center space-x-2">
                <input
                  type="checkbox"
                  id={`category-${category.id}`}
                  checked={formData.categories.includes(category.id)}
                  onChange={(e) => {
                    const isChecked = e.target.checked;
                    setFormData((prev) => ({
                      ...prev,
                      categories: isChecked
                        ? [...prev.categories, category.id]
                        : prev.categories.filter((catId) => catId !== category.id),
                    }));
                  }}
                  className="h-4 w-4 rounded border-gray-300 text-primary focus:ring-primary"
                />
                <Label
                  htmlFor={`category-${category.id}`}
                  className="text-sm text-gray-700 dark:text-gray-200"
                >
                  {category.name}
                </Label>
              </div>
            ))}
          </div>
        </div>

        <div>
          <Label className="block text-sm font-medium text-gray-700 dark:text-gray-200 mb-2">
            Contenu
          </Label>
          <RichTextEditor
            content={formData.content}
            onChange={(content) => setFormData((prev) => ({ ...prev, content }))}
          />
        </div>

        <div>
          <Label className="block text-sm font-medium text-gray-700 dark:text-gray-200 mb-2">
            Tags
          </Label>
          <div className="flex flex-wrap gap-2 mb-2">
            {formData.tags.map((tag) => (
              <span
                key={tag}
                className="inline-flex items-center px-3 py-1 rounded-full text-sm font-medium
                           bg-primary-100 text-primary-800 dark:bg-primary-900 dark:text-primary-200"
              >
                {tag}
                <button
                  type="button"
                  onClick={() => removeTag(tag)}
                  className="ml-2 inline-flex items-center hover:text-primary-900 dark:hover:text-primary-100"
                >
                  <X className="w-4 h-4" />
                </button>
              </span>
            ))}
          </div>
          <input
            type="text"
            value={currentTag}
            onChange={(e) => setCurrentTag(e.target.value)}
            onKeyDown={addTag}
            placeholder="Ajouter un tag (Entrée pour valider)"
            className="mt-1 block w-full px-4 py-2 rounded-lg border dark:border-gray-600
                       focus:ring-2 focus:ring-primary-500 focus:border-primary-500
                       dark:bg-gray-700 dark:text-white"
          />
        </div>

        <div className="grid grid-cols-1 gap-6 md:grid-cols-2">
          <div>
            <Label htmlFor="status" className="block text-sm font-medium text-gray-700
                                              dark:text-gray-200 mb-2">
              Statut
            </Label>
            <select
              id="status"
              value={formData.status}
              onChange={(e) =>
                setFormData((prev) => ({
                  ...prev,
                  status: e.target.value as 'DRAFT' | 'PUBLISHED' | 'ARCHIVED',
                }))
              }
              className="mt-1 block w-full px-4 py-2 rounded-lg border dark:border-gray-600
                         focus:ring-2 focus:ring-primary-500 focus:border-primary-500
                         dark:bg-gray-700 dark:text-white"
            >
              <option value="DRAFT">Brouillon</option>
              <option value="PUBLISHED">Publié</option>
              <option value="ARCHIVED">Archivé</option>
            </select>
          </div>

          <div>
            <Label htmlFor="accessLevel" className="block text-sm font-medium text-gray-700
                                                   dark:text-gray-200 mb-2">
              Niveau d'accès
            </Label>
            <select
              id="accessLevel"
              value={formData.accessLevel}
              onChange={(e) =>
                setFormData((prev) => ({
                  ...prev,
                  accessLevel: e.target.value as 'FREE' | 'BASIC' | 'PRO',
                }))
              }
              className="mt-1 block w-full px-4 py-2 rounded-lg border dark:border-gray-600
                         focus:ring-2 focus:ring-primary-500 focus:border-primary-500
                         dark:bg-gray-700 dark:text-white"
            >
              <option value="FREE">Gratuit</option>
              <option value="BASIC">Basic</option>
              <option value="PRO">Pro</option>
            </select>
          </div>
        </div>

        <div className="flex justify-end space-x-4">
          <Button
            type="button"
            onClick={() => router.back()}
            className="px-4 py-2 text-sm font-medium text-gray-700 dark:text-gray-200
                       bg-white dark:bg-gray-800 border dark:border-gray-600 rounded-lg
                       hover:bg-gray-50 dark:hover:bg-gray-700"
          >
            Annuler
          </Button>
          <Button
            type="submit"
            disabled={loading}
            className="px-4 py-2 text-sm font-medium text-white bg-primary
                       hover:bg-primary/90 rounded-lg disabled:opacity-50"
          >
            {loading ? 'En cours...' : isEditing ? 'Mettre à jour' : 'Créer'}
          </Button>
        </div>
      </form>
    </div>
  );
}

================================================================================

===== C:\wamp64\www\75Tribune\src\app\(admin)\dashboard\categories\categories-client.tsx =====

'use client';

import { useState, useEffect } from 'react';
import { useRouter } from 'next/navigation';
import { Plus, Pencil, Trash2, ChevronDown, ChevronRight } from 'lucide-react';
import { toast } from 'react-hot-toast';

interface Category {
  id: string;
  name: string;
  description?: string;
  parentId?: string;
  order: number;
  isActive: boolean;
  children: Category[];
  _count: {
    articles: number;
  };
}

export default function CategoriesClient() {
  const router = useRouter();
  const [categories, setCategories] = useState<Category[]>([]);
  const [expandedCategories, setExpandedCategories] = useState<Set<string>>(new Set());
  const [editingCategory, setEditingCategory] = useState<Category | null>(null);
  const [showAddForm, setShowAddForm] = useState(false);
  const [formData, setFormData] = useState({
    name: '',
    description: '',
    parentId: '',
  });
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    fetchCategories();
  }, []);

  const fetchCategories = async () => {
    try {
      setLoading(true);
      const response = await fetch('/api/categories?tree=true');
      if (!response.ok) throw new Error('Erreur lors de la récupération des catégories');
      const data = await response.json();
      setCategories(Array.isArray(data) ? data : []);
    } catch (error) {
      console.error('Erreur:', error);
      toast.error('Erreur lors de la récupération des catégories');
    } finally {
      setLoading(false);
    }
  };

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    try {
      const response = await fetch('/api/categories', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(formData),
      });

      if (!response.ok) throw new Error('Erreur lors de la création de la catégorie');
      
      await fetchCategories();
      setShowAddForm(false);
      setFormData({ name: '', description: '', parentId: '' });
      toast.success('Catégorie créée avec succès');
    } catch (error) {
      console.error('Erreur:', error);
      toast.error('Erreur lors de la création de la catégorie');
    }
  };

  const handleUpdate = async (e: React.FormEvent) => {
    e.preventDefault();
    if (!editingCategory) return;

    try {
      const response = await fetch(`/api/categories/${editingCategory.id}`, {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(formData),
      });

      if (!response.ok) throw new Error('Erreur lors de la mise à jour de la catégorie');
      
      await fetchCategories();
      setEditingCategory(null);
      setFormData({ name: '', description: '', parentId: '' });
      toast.success('Catégorie mise à jour avec succès');
    } catch (error) {
      console.error('Erreur:', error);
      toast.error('Erreur lors de la mise à jour de la catégorie');
    }
  };

  const handleDelete = async (id: string) => {
    if (!confirm('Êtes-vous sûr de vouloir supprimer cette catégorie ?')) return;

    try {
      const response = await fetch(`/api/categories/${id}`, {
        method: 'DELETE',
      });

      if (!response.ok) throw new Error('Erreur lors de la suppression de la catégorie');
      
      await fetchCategories();
      toast.success('Catégorie supprimée avec succès');
    } catch (error) {
      console.error('Erreur:', error);
      toast.error('Erreur lors de la suppression de la catégorie');
    }
  };

  const toggleExpand = (categoryId: string) => {
    setExpandedCategories(prev => {
      const next = new Set(prev);
      if (next.has(categoryId)) {
        next.delete(categoryId);
      } else {
        next.add(categoryId);
      }
      return next;
    });
  };

  const renderCategoryTree = (categories: Category[], level = 0) => {
    return categories.map(category => (
      <div key={category.id} style={{ marginLeft: `${level * 20}px` }}>
        <div className="flex items-center space-x-2 py-2">
          {category.children.length > 0 && (
            <button
              onClick={() => toggleExpand(category.id)}
              className="p-1 hover:bg-gray-100 rounded"
            >
              {expandedCategories.has(category.id) ? (
                <ChevronDown className="w-4 h-4" />
              ) : (
                <ChevronRight className="w-4 h-4" />
              )}
            </button>
          )}
          <span className="flex-1">{category.name}</span>
          <div className="flex items-center space-x-2">
            <button
              onClick={() => {
                setEditingCategory(category);
                setFormData({
                  name: category.name,
                  description: category.description || '',
                  parentId: category.parentId || '',
                });
              }}
              className="p-1 hover:bg-gray-100 rounded text-blue-600"
            >
              <Pencil className="w-4 h-4" />
            </button>
            <button
              onClick={() => handleDelete(category.id)}
              className="p-1 hover:bg-gray-100 rounded text-red-600"
            >
              <Trash2 className="w-4 h-4" />
            </button>
          </div>
        </div>
        {expandedCategories.has(category.id) && category.children.length > 0 && (
          <div className="ml-4">
            {renderCategoryTree(category.children, level + 1)}
          </div>
        )}
      </div>
    ));
  };

  const renderForm = (isEditing = false) => {
    return (
      <form onSubmit={isEditing ? handleUpdate : handleSubmit} className="space-y-4 mt-4">
        <div>
          <label className="block text-sm font-medium text-gray-700">Nom</label>
          <input
            type="text"
            value={formData.name}
            onChange={(e) => setFormData({ ...formData, name: e.target.value })}
            className="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500"
            required
          />
        </div>
        <div>
          <label className="block text-sm font-medium text-gray-700">Description</label>
          <textarea
            value={formData.description}
            onChange={(e) => setFormData({ ...formData, description: e.target.value })}
            className="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500"
          />
        </div>
        <div>
          <label className="block text-sm font-medium text-gray-700">Catégorie parente</label>
          <select
            value={formData.parentId}
            onChange={(e) => setFormData({ ...formData, parentId: e.target.value })}
            className="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500"
          >
            <option value="">Aucune</option>
            {categories.map(category => (
              <option key={category.id} value={category.id}>
                {category.name}
              </option>
            ))}
          </select>
        </div>
        <div className="flex justify-end space-x-2">
          <button
            type="button"
            onClick={() => {
              setShowAddForm(false);
              setEditingCategory(null);
              setFormData({ name: '', description: '', parentId: '' });
            }}
            className="px-4 py-2 text-sm font-medium text-gray-700 bg-white border border-gray-300 rounded-md hover:bg-gray-50"
          >
            Annuler
          </button>
          <button
            type="submit"
            className="px-4 py-2 text-sm font-medium text-white bg-blue-600 border border-transparent rounded-md hover:bg-blue-700"
          >
            {isEditing ? 'Mettre à jour' : 'Créer'}
          </button>
        </div>
      </form>
    );
  };

  if (loading) {
    return (
      <div className="flex justify-center items-center min-h-screen">
        <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-gray-900"></div>
      </div>
    );
  }

  return (
    <div className="p-4">
      <div className="flex justify-between items-center mb-6">
        <h1 className="text-2xl font-semibold">Gestion des catégories</h1>
        {!showAddForm && !editingCategory && (
          <button
            onClick={() => setShowAddForm(true)}
            className="flex items-center px-4 py-2 text-sm font-medium text-white bg-blue-600 rounded-md hover:bg-blue-700"
          >
            <Plus className="w-4 h-4 mr-2" />
            Nouvelle catégorie
          </button>
        )}
      </div>

      {showAddForm && renderForm()}
      {editingCategory && renderForm(true)}

      <div className="mt-6">
        {categories.length > 0 ? (
          renderCategoryTree(categories)
        ) : (
          <p className="text-gray-500">Aucune catégorie trouvée</p>
        )}
      </div>
    </div>
  );
}


================================================================================

===== C:\wamp64\www\75Tribune\src\app\(admin)\dashboard\categories\page.tsx =====

'use client';

import { useState, useEffect } from 'react';
import { Plus, Edit2, Trash2 } from 'lucide-react';
import { CategoryTree } from '@/services/category.service';
import { useToast } from '@/components/ui/use-toast';
import { CategoryDialog } from '@/components/categories/category-dialog';
import { useSession } from 'next-auth/react';
import { Role } from '@prisma/client';
import { redirect } from 'next/navigation';

export default function CategoriesPage() {
  const { data: session } = useSession({
    required: true,
    onUnauthenticated() {
      redirect('/login');
    },
  });

  // Vérifier si l'utilisateur a le rôle admin
  if (session?.user?.role !== Role.ADMIN) {
    redirect('/');
  }

  const [categories, setCategories] = useState<CategoryTree[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [showDialog, setShowDialog] = useState(false);
  const [editingCategory, setEditingCategory] = useState<CategoryTree | undefined>(undefined);
  const { toast } = useToast();

  const fetchCategories = async () => {
    try {
      const response = await fetch('/api/categories');
      if (!response.ok) {
        throw new Error('Erreur lors du chargement des catégories');
      }
      const data = await response.json();
      setCategories(data);
      setError(null);
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Une erreur est survenue');
      toast({
        title: "Erreur",
        description: "Impossible de charger les catégories",
        variant: "destructive",
      });
    } finally {
      setLoading(false);
    }
  };

  useEffect(() => {
    fetchCategories();
  }, []);

  const handleAddCategory = async (data: CategoryTree) => {
    try {
      const response = await fetch('/api/categories', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(data),
      });

      if (!response.ok) {
        throw new Error('Erreur lors de la création de la catégorie');
      }

      await fetchCategories();
      setShowDialog(false);
      toast({
        title: "Succès",
        description: "Catégorie créée avec succès",
      });
    } catch (err) {
      toast({
        title: "Erreur",
        description: err instanceof Error ? err.message : "Une erreur est survenue",
        variant: "destructive",
      });
    }
  };

  const handleEditCategory = async (data: CategoryTree) => {
    try {
      const response = await fetch('/api/categories', {
        method: 'PUT',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ ...data, id: editingCategory?.id }),
      });

      if (!response.ok) {
        throw new Error('Erreur lors de la modification de la catégorie');
      }

      await fetchCategories();
      setShowDialog(false);
      setEditingCategory(undefined);
      toast({
        title: "Succès",
        description: "Catégorie modifiée avec succès",
      });
    } catch (err) {
      toast({
        title: "Erreur",
        description: err instanceof Error ? err.message : "Une erreur est survenue",
        variant: "destructive",
      });
    }
  };

  const handleDeleteCategory = async (id: string) => {
    if (!confirm('Êtes-vous sûr de vouloir supprimer cette catégorie ?')) {
      return;
    }

    try {
      const response = await fetch(`/api/categories?id=${id}`, {
        method: 'DELETE',
      });

      if (!response.ok) {
        throw new Error('Erreur lors de la suppression de la catégorie');
      }

      await fetchCategories();
      toast({
        title: "Succès",
        description: "Catégorie supprimée avec succès",
      });
    } catch (err) {
      toast({
        title: "Erreur",
        description: err instanceof Error ? err.message : "Une erreur est survenue",
        variant: "destructive",
      });
    }
  };

  if (loading) {
    return (
      <div className="flex items-center justify-center min-h-screen">
        <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-gray-900 dark:border-gray-100"></div>
      </div>
    );
  }

  return (
    <div className="container p-4 w-full">
      <div className="flex justify-between items-center mb-6">
        <h1 className="text-2xl font-bold text-gray-900 dark:text-white">Gestion des catégories</h1>
        <button
          onClick={() => {
            setEditingCategory(undefined);
            setShowDialog(true);
          }}
          className="flex items-center px-4 py-2 bg-primary-600 text-white rounded-lg hover:bg-primary-700 transition-colors"
        >
          <Plus className="w-4 h-4 mr-2" />
          Nouvelle catégorie
        </button>
      </div>

      {error && (
        <div className="bg-red-100 dark:bg-red-900 border border-red-400 dark:border-red-800 text-red-700 dark:text-red-200 px-4 py-3 rounded">
          {error}
        </div>
      )}

      <div className="grid gap-4">
        {categories.map((category) => (
          <div
            key={category.id}
            className="flex items-center justify-between p-4 bg-white dark:bg-gray-800 rounded-lg shadow"
          >
            <div className="flex-1">
              <h3 className="font-semibold text-gray-900 dark:text-white">{category.name}</h3>
              <p className="text-sm text-gray-500 dark:text-gray-400">{category.description || 'Aucune description'}</p>
              <div className="flex items-center mt-2 space-x-4 text-sm text-gray-500 dark:text-gray-400">
                <span>
                  {category._count?.articles || 0} article{category._count?.articles !== 1 ? 's' : ''}
                </span>
                <span>•</span>
                <span>
                  {category._count?.children || 0} sous-catégorie{category._count?.children !== 1 ? 's' : ''}
                </span>
                <span>•</span>
                <span className={category.isActive ? 'text-green-500 dark:text-green-400' : 'text-red-500 dark:text-red-400'}>
                  {category.isActive ? 'Active' : 'Inactive'}
                </span>
              </div>
            </div>
            <div className="flex items-center space-x-2">
              <button
                onClick={() => {
                  setEditingCategory(category);
                  setShowDialog(true);
                }}
                className="p-2 text-gray-600 dark:text-gray-300 hover:text-primary-600 dark:hover:text-primary-400 transition-colors"
              >
                <Edit2 className="w-5 h-5" />
              </button>
              <button
                onClick={() => handleDeleteCategory(category.id)}
                className="p-2 text-gray-600 dark:text-gray-300 hover:text-red-600 dark:hover:text-red-400 transition-colors"
              >
                <Trash2 className="w-5 h-5" />
              </button>
            </div>
          </div>
        ))}
      </div>

      <CategoryDialog
        show={showDialog}
        onClose={() => {
          setShowDialog(false);
          setEditingCategory(undefined);
        }}
        onSubmit={editingCategory ? handleEditCategory : handleAddCategory}
        category={editingCategory}
        categories={categories}
      />
    </div>
  );
}


================================================================================

===== C:\wamp64\www\75Tribune\src\app\(admin)\dashboard\settings\page.tsx =====

"use client"

import { useEffect, useState } from "react"
import { zodResolver } from "@hookform/resolvers/zod"
import { useForm } from "react-hook-form"
import * as z from "zod"
import { toast } from "react-hot-toast"

import { Button } from "@/components/ui/button"
import {
  Form,
  FormControl,
  FormDescription,
  FormField,
  FormItem,
  FormLabel,
  FormMessage,
} from "@/components/ui/form"
import { Input } from "@/components/ui/input"
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card"
import { Separator } from "@/components/ui/separator"

const settingsFormSchema = z.object({
  siteName: z.string().min(2, {
    message: "Le nom du site doit contenir au moins 2 caractères.",
  }),
  siteUrl: z.string().url({
    message: "Veuillez entrer une URL valide.",
  }),
  contactEmail: z.string().email({
    message: "Veuillez entrer une adresse email valide.",
  }),
  adminEmail: z.string().email({
    message: "Veuillez entrer une adresse email valide.",
  }),
})

type SettingsFormValues = z.infer<typeof settingsFormSchema>

export default function SettingsPage() {
  const [isLoading, setIsLoading] = useState(false)

  const form = useForm<SettingsFormValues>({
    resolver: zodResolver(settingsFormSchema),
    defaultValues: {
      siteName: "",
      siteUrl: "",
      contactEmail: "",
      adminEmail: ""
    }
  })

  // Charger les paramètres actuels
  useEffect(() => {
    const loadSettings = async () => {
      try {
        setIsLoading(true)
        const response = await fetch("/api/settings")
        if (!response.ok) throw new Error("Erreur lors du chargement des paramètres")
        
        const settings = await response.json()
        form.reset(settings)
      } catch (error) {
        toast.error("Erreur lors du chargement des paramètres")
        console.error(error)
      } finally {
        setIsLoading(false)
      }
    }

    loadSettings()
  }, [form])

  async function onSubmit(data: SettingsFormValues) {
    try {
      setIsLoading(true)
      const response = await fetch("/api/settings", {
        method: "PUT",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify(data),
      })

      if (!response.ok) throw new Error("Erreur lors de la mise à jour des paramètres")

      toast.success("Paramètres mis à jour avec succès")
    } catch (error) {
      toast.error("Erreur lors de la mise à jour des paramètres")
      console.error(error)
    } finally {
      setIsLoading(false)
    }
  }

  return (
    <div className="container mx-auto py-10">
      <Card>
        <CardHeader>
          <CardTitle>Paramètres du site</CardTitle>
          <CardDescription>
            Configurez les paramètres généraux de votre application.
          </CardDescription>
        </CardHeader>
        <CardContent>
          <Form {...form}>
            <form onSubmit={form.handleSubmit(onSubmit)} className="space-y-8">
              <FormField
                control={form.control}
                name="siteName"
                render={({ field }) => (
                  <FormItem>
                    <FormLabel>Nom du site</FormLabel>
                    <FormControl>
                      <Input placeholder="75Tribune" {...field} disabled={isLoading} />
                    </FormControl>
                    <FormDescription>
                      Le nom qui sera affiché dans le titre du site et les emails.
                    </FormDescription>
                    <FormMessage />
                  </FormItem>
                )}
              />

              <FormField
                control={form.control}
                name="siteUrl"
                render={({ field }) => (
                  <FormItem>
                    <FormLabel>URL du site</FormLabel>
                    <FormControl>
                      <Input placeholder="https://75Tribune.com" {...field} disabled={isLoading} />
                    </FormControl>
                    <FormDescription>
                      L&apos;URL principale de votre site.
                    </FormDescription>
                    <FormMessage />
                  </FormItem>
                )}
              />

              <Separator />

              <FormField
                control={form.control}
                name="contactEmail"
                render={({ field }) => (
                  <FormItem>
                    <FormLabel>Email de contact</FormLabel>
                    <FormControl>
                      <Input placeholder="contact@75Tribune.com" {...field} disabled={isLoading} />
                    </FormControl>
                    <FormDescription>
                      L&apos;adresse email de contact principale.
                    </FormDescription>
                    <FormMessage />
                  </FormItem>
                )}
              />

              <FormField
                control={form.control}
                name="adminEmail"
                render={({ field }) => (
                  <FormItem>
                    <FormLabel>Email administrateur</FormLabel>
                    <FormControl>
                      <Input placeholder="admin@75Tribune.com" {...field} disabled={isLoading} />
                    </FormControl>
                    <FormDescription>
                      L&apos;adresse email pour les notifications administrateur.
                    </FormDescription>
                    <FormMessage />
                  </FormItem>
                )}
              />

              <Button type="submit" disabled={isLoading}>
                {isLoading ? "Enregistrement..." : "Enregistrer les modifications"}
              </Button>
            </form>
          </Form>
        </CardContent>
      </Card>
    </div>
  )
}


================================================================================

===== C:\wamp64\www\75Tribune\src\app\(admin)\dashboard\subscribers\columns.tsx =====

import { ColumnDef } from '@tanstack/react-table';
import { Role, SubscriptionType } from '@prisma/client';
import { Badge } from '@/components/ui/badge';
import { format } from 'date-fns';
import { fr } from 'date-fns/locale';
import { Button } from '@/components/ui/button';
import { MoreHorizontal, Pencil, Trash } from 'lucide-react';
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuLabel,
  DropdownMenuSeparator,
  DropdownMenuTrigger,
} from '@/components/ui/dropdown-menu';

export interface User {
  id: string;
  email: string;
  name: string | null;
  role: Role;
  subscriptionType: SubscriptionType;
  emailVerified: boolean;
  lastLogin: Date | null;
  createdAt: Date;
  updatedAt: Date;
  onEdit?: (user: User) => void;
  onDelete?: (user: User) => void;
}

export const columns: ColumnDef<User>[] = [
  {
    accessorKey: 'name',
    header: 'Nom',
    cell: ({ row }) => row.getValue('name') || 'Non défini',
  },
  {
    accessorKey: 'email',
    header: 'Email',
  },
  {
    accessorKey: 'role',
    header: 'Rôle',
    cell: ({ row }) => {
      const role = row.getValue('role') as Role;
      return (
        <Badge variant={role === 'ADMIN' ? 'destructive' : role === 'MODERATOR' ? 'default' : 'secondary'}>
          {role === 'ADMIN' ? 'Administrateur' : role === 'MODERATOR' ? 'Modérateur' : 'Utilisateur'}
        </Badge>
      );
    },
  },
  {
    accessorKey: 'subscriptionType',
    header: 'Abonnement',
    cell: ({ row }) => {
      const type = row.getValue('subscriptionType') as SubscriptionType;
      return (
        <Badge variant={type === 'PREMIUM' ? 'default' : 'secondary'}>
          {type === 'PREMIUM' ? 'Premium' : 'Gratuit'}
        </Badge>
      );
    },
  },
  {
    accessorKey: 'createdAt',
    header: 'Date création',
    cell: ({ row }) => {
      const date = row.getValue('createdAt') as Date;
      return format(new Date(date), 'Pp', { locale: fr });
    },
  },
  {
    id: 'actions',
    cell: ({ row }) => {
      const user = row.original;

      return (
        <DropdownMenu>
          <DropdownMenuTrigger asChild>
            <Button variant="ghost" className="h-8 w-8 p-0">
              <span className="sr-only">Ouvrir le menu</span>
              <MoreHorizontal className="h-4 w-4" />
            </Button>
          </DropdownMenuTrigger>
          <DropdownMenuContent align="end">
            <DropdownMenuLabel>Actions</DropdownMenuLabel>
            <DropdownMenuItem
              onClick={() => navigator.clipboard.writeText(user.id)}
            >
              Copier l'ID utilisateur
            </DropdownMenuItem>
            <DropdownMenuSeparator />
            <DropdownMenuItem onClick={() => row.original.onEdit?.(user)}>
              <Pencil className="mr-2 h-4 w-4" />
              Modifier
            </DropdownMenuItem>
            <DropdownMenuItem className="text-red-600" onClick={() => row.original.onDelete?.(user)}>
              <Trash className="mr-2 h-4 w-4" />
              Supprimer
            </DropdownMenuItem>
          </DropdownMenuContent>
        </DropdownMenu>
      );
    },
  },
];


================================================================================

===== C:\wamp64\www\75Tribune\src\app\(admin)\dashboard\subscribers\page.tsx =====

'use client';

import { useState } from 'react';
import { DataTable } from '@/components/ui/data-table';
import { columns, User } from './columns';
import { Button } from '@/components/ui/button';
import { Role, SubscriptionType } from '@prisma/client';
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
  DialogDescription,
  DialogTrigger,
} from '@/components/ui/dialog';
import { Input } from '@/components/ui/input';
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from '@/components/ui/select';
import { toast } from 'react-hot-toast';
import { useRouter } from 'next/navigation';
import { Loader2 } from 'lucide-react';
import { useUsers } from '@/hooks/useUsers';

interface FormData {
  name: string;
  email: string;
  role: Role;
  subscriptionType: SubscriptionType;
  password: string;
}

export default function SubscribersPage() {
  const router = useRouter();
  const { users, loading: usersLoading, error, createUser, updateUser, deleteUser } = useUsers();
  const [isOpen, setIsOpen] = useState(false);
  const [loading, setLoading] = useState(false);
  const [editingUser, setEditingUser] = useState<User | null>(null);
  const [formData, setFormData] = useState<FormData>({
    name: '',
    email: '',
    role: 'USER' as Role,
    subscriptionType: 'FREE' as SubscriptionType,
    password: '',
  });

  const handleEdit = (user: User) => {
    setEditingUser(user);
    setFormData({
      name: user.name || '',
      email: user.email,
      role: user.role,
      subscriptionType: user.subscriptionType,
      password: '', // On ne récupère pas le mot de passe pour des raisons de sécurité
    });
    setIsOpen(true);
  };

  const handleDelete = async (user: User) => {
    if (window.confirm('Êtes-vous sûr de vouloir supprimer cet utilisateur ?')) {
      try {
        await deleteUser(user.id);
        toast.success('Utilisateur supprimé avec succès');
        router.refresh();
      } catch (error) {
        toast.error('Erreur lors de la suppression');
      }
    }
  };

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    setLoading(true);

    try {
      if (editingUser) {
        await updateUser(editingUser.id, formData);
        toast.success('Utilisateur mis à jour avec succès');
      } else {
        await createUser(formData);
        toast.success('Utilisateur créé avec succès');
      }
      setIsOpen(false);
      router.refresh();
      resetForm();
    } catch (error) {
      toast.error(error instanceof Error ? error.message : 'Une erreur est survenue');
    } finally {
      setLoading(false);
    }
  };

  const resetForm = () => {
    setFormData({
      name: '',
      email: '',
      role: 'USER' as Role,
      subscriptionType: 'FREE' as SubscriptionType,
      password: '',
    });
    setEditingUser(null);
  };

  if (error) {
    return <div className="p-4 text-red-500">Erreur: {error}</div>;
  }

  const enrichedUsers = users?.map(user => ({
    ...user,
    onEdit: handleEdit,
    onDelete: handleDelete,
  }));

  return (
    <div className="container mx-auto py-10">
      <div className="flex justify-between items-center mb-6">
        <h1 className="text-2xl font-bold">Gestion des utilisateurs</h1>
        <Dialog open={isOpen} onOpenChange={(open) => {
          setIsOpen(open);
          if (!open) resetForm();
        }}>
          <DialogTrigger asChild>
            <Button>Nouvel utilisateur</Button>
          </DialogTrigger>
          <DialogContent className="sm:max-w-[425px]">
            <DialogHeader>
              <DialogTitle>{editingUser ? 'Modifier' : 'Ajouter'} un utilisateur</DialogTitle>
              <DialogDescription>
                {editingUser ? 'Modifiez les informations de l\'utilisateur.' : 'Ajoutez un nouvel utilisateur au système.'}
              </DialogDescription>
            </DialogHeader>
            <form onSubmit={handleSubmit} className="space-y-4 py-4">
              <div className="grid w-full gap-4">
                <div className="flex flex-col space-y-2">
                  <label htmlFor="name" className="text-sm font-medium">
                    Nom
                  </label>
                  <Input
                    id="name"
                    placeholder="Nom de l'utilisateur"
                    value={formData.name}
                    onChange={(e) => setFormData({ ...formData, name: e.target.value })}
                    className="w-full"
                  />
                </div>
                <div className="flex flex-col space-y-2">
                  <label htmlFor="email" className="text-sm font-medium">
                    Email
                  </label>
                  <Input
                    id="email"
                    type="email"
                    placeholder="email@exemple.com"
                    value={formData.email}
                    onChange={(e) => setFormData({ ...formData, email: e.target.value })}
                    className="w-full"
                  />
                </div>
                {!editingUser && (
                  <div className="flex flex-col space-y-2">
                    <label htmlFor="password" className="text-sm font-medium">
                      Mot de passe
                    </label>
                    <Input
                      id="password"
                      type="password"
                      placeholder="Mot de passe"
                      value={formData.password}
                      onChange={(e) => setFormData({ ...formData, password: e.target.value })}
                      className="w-full"
                      autoComplete={editingUser ? "new-password" : "current-password"}
                    />
                  </div>
                )}
                <div className="flex flex-col space-y-2">
                  <label htmlFor="role" className="text-sm font-medium">
                    Rôle
                  </label>
                  <Select
                    value={formData.role}
                    onValueChange={(value: Role) => setFormData({ ...formData, role: value })}
                  >
                    <SelectTrigger className="w-full">
                      <SelectValue placeholder="Sélectionner un rôle" />
                    </SelectTrigger>
                    <SelectContent>
                      <SelectItem value="USER">Utilisateur</SelectItem>
                      <SelectItem value="MODERATOR">Modérateur</SelectItem>
                      <SelectItem value="ADMIN">Administrateur</SelectItem>
                    </SelectContent>
                  </Select>
                </div>
                <div className="flex flex-col space-y-2">
                  <label htmlFor="subscriptionType" className="text-sm font-medium">
                    Type d'abonnement
                  </label>
                  <Select
                    value={formData.subscriptionType}
                    onValueChange={(value: SubscriptionType) => setFormData({ ...formData, subscriptionType: value })}
                  >
                    <SelectTrigger className="w-full">
                      <SelectValue placeholder="Sélectionner un type d'abonnement" />
                    </SelectTrigger>
                    <SelectContent>
                      <SelectItem value="FREE">Gratuit</SelectItem>
                      <SelectItem value="PREMIUM">Premium</SelectItem>
                    </SelectContent>
                  </Select>
                </div>
              </div>
              <div className="flex justify-end space-x-3 pt-4">
                <Button
                  type="button"
                  variant="outline"
                  onClick={() => {
                    setIsOpen(false);
                    resetForm();
                  }}
                >
                  Annuler
                </Button>
                <Button type="submit" disabled={loading}>
                  {loading ? (
                    <Loader2 className="h-4 w-4 animate-spin" />
                  ) : (
                    editingUser ? 'Mettre à jour' : 'Créer'
                  )}
                </Button>
              </div>
            </form>
          </DialogContent>
        </Dialog>
      </div>
      {usersLoading ? (
        <div className="flex justify-center py-8">
          <Loader2 className="h-8 w-8 animate-spin" />
        </div>
      ) : (
        <DataTable columns={columns} data={enrichedUsers || []} />
      )}
    </div>
  );
}


================================================================================

===== C:\wamp64\www\75Tribune\src\app\(auth)\layout.tsx =====

export default function AuthLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return children;
}


================================================================================

===== C:\wamp64\www\75Tribune\src\app\(auth)\forgot-password\page.tsx =====

import { Metadata } from 'next';
import { ClientForgotPasswordForm } from '@/components/auth/ClientForgotPasswordForm';

export const metadata: Metadata = {
  title: 'Mot de passe oublié | 75Tribune',
  description: 'Réinitialisez votre mot de passe 75Tribune',
};

export default function ForgotPasswordPage() {
  return (
    <div className="container relative h-[calc(100vh-4rem)] flex-col items-center justify-center grid lg:max-w-none lg:grid-cols-1 lg:px-0">
      <div className="mx-auto flex w-full flex-col justify-center space-y-6 sm:w-[350px]">
        <ClientForgotPasswordForm />
      </div>
    </div>
  );
}


================================================================================

===== C:\wamp64\www\75Tribune\src\app\(auth)\reset-password\page.tsx =====

'use client';

import { useState, Suspense } from 'react';
import { useSearchParams } from 'next/navigation';
import Link from 'next/link';
import { FormInput } from '@/components/ui/FormInput';
import { KeyRound } from 'lucide-react';

function ResetPasswordContent() {
  const searchParams = useSearchParams();
  const token = searchParams?.get('token');
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState('');
  const [success, setSuccess] = useState('');

  const handleSubmit = async (e: React.FormEvent<HTMLFormElement>) => {
    e.preventDefault();
    setLoading(true);
    setError('');
    setSuccess('');

    const formData = new FormData(e.currentTarget);
    const email = formData.get('email') as string;

    try {
      const res = await fetch('/api/auth/reset-password', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ email, token }),
      });

      const data = await res.json();

      if (data.error) {
        setError(data.error);
        return;
      }

      setSuccess(
        'Si un compte existe avec cette adresse email, vous recevrez un email avec les instructions pour réinitialiser votre mot de passe.'
      );
    } catch (error) {
      setError('Une erreur est survenue');
    } finally {
      setLoading(false);
    }
  };

  // Si nous avons un token, montrer le formulaire de nouveau mot de passe
  if (token) {
    return (
      <div className="flex min-h-screen flex-col items-center justify-center py-12 sm:px-6 lg:px-8">
        <div className="sm:mx-auto sm:w-full sm:max-w-md">
          <div className="mx-auto flex h-12 w-12 items-center justify-center rounded-full bg-blue-100">
            <KeyRound className="h-6 w-6 text-blue-600" />
          </div>
          <h2 className="mt-6 text-center text-3xl font-bold tracking-tight text-gray-900 dark:text-white">
            Nouveau mot de passe
          </h2>
        </div>

        <div className="mt-8 sm:mx-auto sm:w-full sm:max-w-md">
          <div className="bg-white dark:bg-gray-800 px-4 py-8 shadow sm:rounded-lg sm:px-10">
            <form className="space-y-6" onSubmit={handleSubmit}>
              {error && (
                <div className="rounded-md bg-red-50 p-4">
                  <div className="text-sm text-red-700">{error}</div>
                </div>
              )}
              {success && (
                <div className="rounded-md bg-green-50 p-4">
                  <div className="text-sm text-green-700">{success}</div>
                </div>
              )}

              <FormInput
                id="password"
                name="password"
                type="password"
                label="Nouveau mot de passe"
                required
              />

              <FormInput
                id="confirmPassword"
                name="confirmPassword"
                type="password"
                label="Confirmer le mot de passe"
                required
              />

              <div>
                <button
                  type="submit"
                  disabled={loading}
                  className="flex w-full justify-center rounded-md bg-blue-600 px-3 py-2 text-sm font-semibold text-white shadow-sm hover:bg-blue-500 focus-visible:outline focus-visible:outline-2 focus-visible:outline-offset-2 focus-visible:outline-blue-600 disabled:opacity-50"
                >
                  {loading ? 'Modification en cours...' : 'Modifier le mot de passe'}
                </button>
              </div>
            </form>
          </div>
        </div>
      </div>
    );
  }

  // Sinon, montrer le formulaire de demande de réinitialisation
  return (
    <div className="flex min-h-screen flex-col items-center justify-center py-12 sm:px-6 lg:px-8">
      <div className="sm:mx-auto sm:w-full sm:max-w-md">
        <div className="mx-auto flex h-12 w-12 items-center justify-center rounded-full bg-blue-100">
          <KeyRound className="h-6 w-6 text-blue-600" />
        </div>
        <h2 className="mt-6 text-center text-3xl font-bold tracking-tight text-gray-900 dark:text-white">
          Réinitialiser votre mot de passe
        </h2>
      </div>

      <div className="mt-8 sm:mx-auto sm:w-full sm:max-w-md">
        <div className="bg-white dark:bg-gray-800 px-4 py-8 shadow sm:rounded-lg sm:px-10">
          <form className="space-y-6" onSubmit={handleSubmit}>
            {error && (
              <div className="rounded-md bg-red-50 p-4">
                <div className="text-sm text-red-700">{error}</div>
              </div>
            )}
            {success && (
              <div className="rounded-md bg-green-50 p-4">
                <div className="text-sm text-green-700">{success}</div>
              </div>
            )}

            <FormInput
              id="email"
              name="email"
              type="email"
              label="Adresse email"
              required
            />

            <div>
              <button
                type="submit"
                disabled={loading}
                className="flex w-full justify-center rounded-md bg-blue-600 px-3 py-2 text-sm font-semibold text-white shadow-sm hover:bg-blue-500 focus-visible:outline focus-visible:outline-2 focus-visible:outline-offset-2 focus-visible:outline-blue-600 disabled:opacity-50"
              >
                {loading ? 'Envoi en cours...' : 'Réinitialiser le mot de passe'}
              </button>
            </div>

            <div className="text-center">
              <Link
                href="/login"
                className="text-sm text-blue-600 hover:text-blue-500"
              >
                Retour à la connexion
              </Link>
            </div>
          </form>
        </div>
      </div>
    </div>
  );
}

export default function ResetPasswordPage() {
  return (
    <Suspense fallback={<div>Chargement...</div>}>
      <ResetPasswordContent />
    </Suspense>
  );
}


================================================================================

===== C:\wamp64\www\75Tribune\src\app\(auth)\verify-email\loading.tsx =====

export default function Loading() {
  return (
    <div className="flex min-h-screen flex-col items-center justify-center py-12 sm:px-6 lg:px-8">
      <div className="sm:mx-auto sm:w-full sm:max-w-md">
        <div className="flex justify-center">
          <div className="h-8 w-8 animate-spin rounded-full border-2 border-blue-600 border-t-transparent"></div>
        </div>
      </div>
    </div>
  );
}


================================================================================

===== C:\wamp64\www\75Tribune\src\app\(auth)\verify-email\page.tsx =====

'use client';

import { useState, useEffect } from 'react';
import { useSearchParams, useRouter } from 'next/navigation';
import { Loader2 } from 'lucide-react';
import { toast } from 'react-hot-toast';

export default function VerifyEmailPage() {
  const router = useRouter();
  const searchParams = useSearchParams();
  const [verifying, setVerifying] = useState(true);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    const verifyEmail = async () => {
      try {
        const token = searchParams.get('token');
        const email = searchParams.get('email');

        if (!token || !email) {
          setError('Lien de vérification invalide');
          return;
        }

        const response = await fetch('/api/auth/verify-email', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({ token, email }),
        });

        const data = await response.json();

        if (!response.ok) {
          throw new Error(data.error || 'Une erreur est survenue');
        }

        toast.success('Email vérifié avec succès');
        
        // Rediriger vers la page de connexion après un court délai
        setTimeout(() => {
          router.push('/login');
        }, 2000);
      } catch (error) {
        console.error('Erreur vérification:', error);
        setError(error instanceof Error ? error.message : 'Une erreur est survenue');
      } finally {
        setVerifying(false);
      }
    };

    verifyEmail();
  }, [router, searchParams]);

  return (
    <div className="min-h-screen flex items-center justify-center bg-gray-100 dark:bg-gray-900">
      <div className="max-w-md w-full space-y-8 p-8 bg-white dark:bg-gray-800 rounded-lg shadow-lg">
        <div className="text-center">
          <h2 className="text-3xl font-bold text-gray-900 dark:text-white">
            Vérification de l'email
          </h2>
          <div className="mt-4">
            {verifying ? (
              <div className="flex flex-col items-center space-y-4">
                <Loader2 className="h-8 w-8 animate-spin text-blue-600" />
                <p className="text-gray-600 dark:text-gray-300">
                  Vérification de votre email en cours...
                </p>
              </div>
            ) : error ? (
              <div className="text-red-600 dark:text-red-400">
                <p>{error}</p>
                <button
                  onClick={() => router.push('/login')}
                  className="mt-4 text-blue-600 dark:text-blue-400 hover:underline"
                >
                  Retour à la connexion
                </button>
              </div>
            ) : (
              <div className="text-green-600 dark:text-green-400">
                <p>Email vérifié avec succès !</p>
                <p className="mt-2 text-gray-600 dark:text-gray-300">
                  Redirection vers la page de connexion...
                </p>
              </div>
            )}
          </div>
        </div>
      </div>
    </div>
  );
}


================================================================================

===== C:\wamp64\www\75Tribune\src\app\admin\articles\page.tsx =====

'use client';

import { useState, useEffect } from 'react';
import { useRouter } from 'next/navigation';

interface Article {
  id: string;
  title: string;
  author: {
    name: string;
  };
  status: string;
}

interface PublishDestination {
  platform: string;
  enabled: boolean;
}

export default function AdminArticlesPage() {
  const [articles, setArticles] = useState<Article[]>([]);
  const [loading, setLoading] = useState(true);
  const [destinations, setDestinations] = useState<PublishDestination[]>([
    { platform: 'wordpress', enabled: false },
    { platform: 'youtube', enabled: false },
    { platform: 'twitter', enabled: false }
  ]);
  const router = useRouter();

  useEffect(() => {
    fetchArticles();
  }, []);

  const fetchArticles = async () => {
    try {
      const response = await fetch('/api/articles');
      const data = await response.json();
      setArticles(data);
    } catch (error) {
      console.error('Error fetching articles:', error);
    } finally {
      setLoading(false);
    }
  };

  const handleDelete = async (id: string) => {
    if (window.confirm('Êtes-vous sûr de vouloir supprimer cet article ?')) {
      try {
        const response = await fetch(`/api/articles/${id}`, {
          method: 'DELETE',
        });
        if (response.ok) {
          fetchArticles(); // Refresh the list
        }
      } catch (error) {
        console.error('Error deleting article:', error);
      }
    }
  };

  const handlePublish = async (formData: any) => {
    try {
      const response = await fetch('/api/articles', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          ...formData,
          destinations: destinations.filter(d => d.enabled),
        }),
      });

      if (!response.ok) {
        throw new Error('Failed to publish article');
      }

      const result = await response.json();
      
      // Afficher les résultats de publication pour chaque plateforme
      if (result.results) {
        Object.entries(result.results).forEach(([platform, platformResult]: [string, any]) => {
          if (platformResult.success) {
            // toast.success(`Publication réussie sur ${platform}`);
          } else {
            // toast.error(`Échec de la publication sur ${platform}: ${platformResult.error}`);
          }
        });
      }

      router.push(result.localUrl || '/admin/articles');
    } catch (error) {
      console.error('Error publishing article:', error);
      // toast.error('Erreur lors de la publication');
    }
  };

  if (loading) {
    return <div className="text-center py-4">Chargement...</div>;
  }

  return (
    <div className="container p-4 w-full">
      <div className="px-4 py-6 sm:px-0">
        <div className="flex justify-between items-center mb-6">
          <h1 className="text-3xl font-bold">Gestion des Articles</h1>
          <button 
            onClick={() => router.push('/admin/articles/new')}
            className="btn-primary"
          >
            Nouvel Article
          </button>
        </div>
        <div className="card">
          <div className="overflow-x-auto">
            <table className="min-w-full divide-y divide-gray-200 dark:divide-gray-700">
              <thead>
                <tr>
                  <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wider">
                    Titre
                  </th>
                  <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wider">
                    Auteur
                  </th>
                  <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wider">
                    Statut
                  </th>
                  <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wider">
                    Actions
                  </th>
                </tr>
              </thead>
              <tbody className="divide-y divide-gray-200 dark:divide-gray-700">
                {articles.map((article) => (
                  <tr key={article.id}>
                    <td className="px-6 py-4 whitespace-nowrap text-gray-900 dark:text-white">
                      {article.title}
                    </td>
                    <td className="px-6 py-4 whitespace-nowrap text-gray-900 dark:text-white">
                      {article.author.name}
                    </td>
                    <td className="px-6 py-4 whitespace-nowrap">
                      <span className={`px-2 inline-flex text-xs leading-5 font-semibold rounded-full ${
                        article.status === 'published' 
                          ? 'bg-green-100 dark:bg-green-800 text-green-800 dark:text-green-100'
                          : 'bg-yellow-100 dark:bg-yellow-800 text-yellow-800 dark:text-yellow-100'
                      }`}>
                        {article.status === 'published' ? 'Publié' : 'Brouillon'}
                      </span>
                    </td>
                    <td className="px-6 py-4 whitespace-nowrap text-sm">
                      <button 
                        onClick={() => router.push(`/admin/articles/${article.id}/edit`)}
                        className="text-indigo-600 dark:text-indigo-400 hover:text-indigo-900 dark:hover:text-indigo-300 mr-4"
                      >
                        Éditer
                      </button>
                      <button 
                        onClick={() => handleDelete(article.id)}
                        className="text-red-600 dark:text-red-400 hover:text-red-900 dark:hover:text-red-300"
                      >
                        Supprimer
                      </button>
                    </td>
                  </tr>
                ))}
              </tbody>
            </table>
          </div>
        </div>
      </div>
    </div>
  );
}


================================================================================

===== C:\wamp64\www\75Tribune\src\app\admin\categories\page.tsx =====

'use client';

import { useState, useEffect } from 'react';
import { useRouter } from 'next/navigation';

interface Category {
  id: string;
  name: string;
  articleCount: number;
}

export default function AdminCategoriesPage() {
  const [categories, setCategories] = useState<Category[]>([]);
  const [loading, setLoading] = useState(true);
  const [newCategory, setNewCategory] = useState('');
  const [showModal, setShowModal] = useState(false);
  const router = useRouter();

  useEffect(() => {
    fetchCategories();
  }, []);

  const fetchCategories = async () => {
    try {
      const response = await fetch('/api/categories');
      const data = await response.json();
      setCategories(data);
    } catch (error) {
      console.error('Error fetching categories:', error);
    } finally {
      setLoading(false);
    }
  };

  const handleDelete = async (id: string) => {
    if (window.confirm('Êtes-vous sûr de vouloir supprimer cette catégorie ?')) {
      try {
        const response = await fetch(`/api/categories/${id}`, {
          method: 'DELETE',
        });
        if (response.ok) {
          fetchCategories();
        }
      } catch (error) {
        console.error('Error deleting category:', error);
      }
    }
  };

  const handleCreateCategory = async () => {
    try {
      const response = await fetch('/api/categories', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ name: newCategory }),
      });
      
      if (response.ok) {
        setNewCategory('');
        setShowModal(false);
        fetchCategories();
      }
    } catch (error) {
      console.error('Error creating category:', error);
    }
  };

  if (loading) {
    return <div className="text-center py-4">Chargement...</div>;
  }

  return (
    <div className="container p-4 w-full">
      <div className="px-4 py-6 sm:px-0">
        <div className="flex justify-between items-center mb-6">
          <h1 className="text-3xl font-bold">Gestion des Catégories</h1>
          <button 
            onClick={() => setShowModal(true)}
            className="btn-primary"
          >
            Nouvelle Catégorie
          </button>
        </div>
        <div className="card">
          <div className="overflow-x-auto">
            <table className="min-w-full divide-y divide-gray-200 dark:divide-gray-700">
              <thead>
                <tr>
                  <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wider">
                    Nom
                  </th>
                  <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wider">
                    Articles
                  </th>
                  <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wider">
                    Actions
                  </th>
                </tr>
              </thead>
              <tbody className="divide-y divide-gray-200 dark:divide-gray-700">
                {categories.map((category) => (
                  <tr key={category.id}>
                    <td className="px-6 py-4 whitespace-nowrap text-gray-900 dark:text-white">
                      {category.name}
                    </td>
                    <td className="px-6 py-4 whitespace-nowrap text-gray-900 dark:text-white">
                      {category.articleCount}
                    </td>
                    <td className="px-6 py-4 whitespace-nowrap text-sm">
                      <button 
                        onClick={() => router.push(`/admin/categories/${category.id}/edit`)}
                        className="text-indigo-600 dark:text-indigo-400 hover:text-indigo-900 dark:hover:text-indigo-300 mr-4"
                      >
                        Éditer
                      </button>
                      <button 
                        onClick={() => handleDelete(category.id)}
                        className="text-red-600 dark:text-red-400 hover:text-red-900 dark:hover:text-red-300"
                      >
                        Supprimer
                      </button>
                    </td>
                  </tr>
                ))}
              </tbody>
            </table>
          </div>
        </div>
      </div>

      {showModal && (
        <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center p-4">
          <div className="bg-white dark:bg-gray-800 rounded-lg p-6 w-full max-w-md">
            <h2 className="text-xl font-bold mb-4">Nouvelle Catégorie</h2>
            <input
              type="text"
              value={newCategory}
              onChange={(e) => setNewCategory(e.target.value)}
              className="w-full p-2 border rounded dark:bg-gray-700 dark:border-gray-600 mb-4"
              placeholder="Nom de la catégorie"
            />
            <div className="flex justify-end gap-2">
              <button
                onClick={() => setShowModal(false)}
                className="btn-secondary"
              >
                Annuler
              </button>
              <button
                onClick={handleCreateCategory}
                className="btn-primary"
                disabled={!newCategory.trim()}
              >
                Créer
              </button>
            </div>
          </div>
        </div>
      )}
    </div>
  );
}


================================================================================

===== C:\wamp64\www\75Tribune\src\app\admin\users\page.tsx =====

'use client';

import { useState, useEffect } from 'react';
import { useRouter } from 'next/navigation';

interface User {
  id: string;
  email: string;
  role: 'USER' | 'ADMIN';
  emailVerified: boolean;
}

export default function AdminUsersPage() {
  const [users, setUsers] = useState<User[]>([]);
  const [loading, setLoading] = useState(true);
  const router = useRouter();

  useEffect(() => {
    fetchUsers();
  }, []);

  const fetchUsers = async () => {
    try {
      const response = await fetch('/api/users');
      const data = await response.json();
      setUsers(data);
    } catch (error) {
      console.error('Error fetching users:', error);
    } finally {
      setLoading(false);
    }
  };

  const handleToggleRole = async (userId: string, currentRole: string) => {
    const newRole = currentRole === 'ADMIN' ? 'USER' : 'ADMIN';
    try {
      const response = await fetch(`/api/users/${userId}/role`, {
        method: 'PATCH',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ role: newRole }),
      });
      
      if (response.ok) {
        fetchUsers();
      }
    } catch (error) {
      console.error('Error updating user role:', error);
    }
  };

  const handleDelete = async (id: string) => {
    if (window.confirm('Êtes-vous sûr de vouloir supprimer cet utilisateur ?')) {
      try {
        const response = await fetch(`/api/users/${id}`, {
          method: 'DELETE',
        });
        if (response.ok) {
          fetchUsers();
        }
      } catch (error) {
        console.error('Error deleting user:', error);
      }
    }
  };

  if (loading) {
    return <div className="text-center py-4">Chargement...</div>;
  }

  return (
    <div className="container p-4 w-full">
      <div className="px-4 py-6 sm:px-0">
        <div className="flex justify-between items-center mb-6">
          <h1 className="text-3xl font-bold">Gestion des Utilisateurs</h1>
        </div>
        <div className="card">
          <div className="overflow-x-auto">
            <table className="min-w-full divide-y divide-gray-200 dark:divide-gray-700">
              <thead>
                <tr>
                  <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wider">
                    Email
                  </th>
                  <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wider">
                    Rôle
                  </th>
                  <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wider">
                    Statut
                  </th>
                  <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wider">
                    Actions
                  </th>
                </tr>
              </thead>
              <tbody className="divide-y divide-gray-200 dark:divide-gray-700">
                {users.map((user) => (
                  <tr key={user.id}>
                    <td className="px-6 py-4 whitespace-nowrap text-gray-900 dark:text-white">
                      {user.email}
                    </td>
                    <td className="px-6 py-4 whitespace-nowrap">
                      <span 
                        className={`px-2 inline-flex text-xs leading-5 font-semibold rounded-full ${
                          user.role === 'ADMIN'
                            ? 'bg-purple-100 dark:bg-purple-800 text-purple-800 dark:text-purple-100'
                            : 'bg-blue-100 dark:bg-blue-800 text-blue-800 dark:text-blue-100'
                        }`}
                      >
                        {user.role}
                      </span>
                    </td>
                    <td className="px-6 py-4 whitespace-nowrap">
                      <span 
                        className={`px-2 inline-flex text-xs leading-5 font-semibold rounded-full ${
                          user.emailVerified
                            ? 'bg-green-100 dark:bg-green-800 text-green-800 dark:text-green-100'
                            : 'bg-yellow-100 dark:bg-yellow-800 text-yellow-800 dark:text-yellow-100'
                        }`}
                      >
                        {user.emailVerified ? 'Vérifié' : 'Non vérifié'}
                      </span>
                    </td>
                    <td className="px-6 py-4 whitespace-nowrap text-sm">
                      <button 
                        onClick={() => handleToggleRole(user.id, user.role)}
                        className="text-indigo-600 dark:text-indigo-400 hover:text-indigo-900 dark:hover:text-indigo-300 mr-4"
                      >
                        {user.role === 'ADMIN' ? 'Rétrograder' : 'Promouvoir'}
                      </button>
                      <button 
                        onClick={() => handleDelete(user.id)}
                        className="text-red-600 dark:text-red-400 hover:text-red-900 dark:hover:text-red-300"
                      >
                        Supprimer
                      </button>
                    </td>
                  </tr>
                ))}
              </tbody>
            </table>
          </div>
        </div>
      </div>
    </div>
  );
}


================================================================================

===== C:\wamp64\www\75Tribune\src\app\api\ai\generate\route.ts =====

import { NextResponse } from 'next/server';

const PROMPT_TEMPLATES = {
  introduction: `En tant qu'expert en rédaction, génère une introduction captivante pour cet article. L'introduction doit :
1. Accrocher le lecteur dès les premières lignes
2. Présenter clairement le sujet et son importance
3. Donner un aperçu des points qui seront abordés
4. Utiliser le ton spécifié
5. Ne pas dépasser 3-4 phrases

Sujet de l'article : `,

  conclusion: `En tant qu'expert en rédaction, génère une conclusion efficace et mémorable pour cet article. La conclusion doit :
1. Résumer les points clés de manière concise
2. Offrir une réflexion finale pertinente
3. Se terminer par un appel à l'action ou une ouverture
4. Utiliser le ton spécifié
5. Ne pas dépasser 3-4 phrases

Points clés de l'article : `,

  title: `En tant qu'expert en rédaction, propose un TITRE percutant pour cet article. Le titre doit :
1. Être court, clair et accrocheur
2. Faire comprendre directement le thème
3. Employer le ton spécifié
4. Ne pas dépasser 80 caractères

Contenu de l'article ou sujet : `
};

const TONE_INSTRUCTIONS = {
  professional: "Adopte un ton professionnel, formel et expert.",
  friendly: "Utilise un ton amical, chaleureux et accessible.",
  informative: "Garde un ton informatif, clair et pédagogique.",
  humorous: "Ajoute une touche d'humour léger et approprié.",
  motivational: "Emploie un ton motivant et encourageant.",
  empathetic: "Montre de l'empathie et de la compréhension.",
  direct: "Va droit au but avec un ton direct et concis.",
  creative: "Sois créatif et original dans ton approche.",
  serious: "Maintiens un ton sérieux et posé.",
  optimistic: "Adopte un ton optimiste et positif.",
  enthusiastic: "Montre de l'enthousiasme et de la passion.",
  persuasive: "Utilise un ton persuasif et convaincant.",
  neutral: "Reste neutre et objectif.",
  strict: "Adopte un ton strict et rigoureux.",
  sincere: "Sois sincère et authentique.",
  technical: "Utilise un ton technique et précis.",
  academic: "Adopte un style académique et savant."
};

export async function POST(request: Request) {
  try {
    // On récupère le JSON envoyé par le client
    const { prompt, model = 'mistral', tone = 'professional' } = await request.json();

    if (!prompt) {
      return NextResponse.json(
        { error: 'Aucun prompt fourni' },
        { status: 400 }
      );
    }

    // 1) Choix du ton (ou fallback sur "professional" si invalide)
    const toneInstruction = TONE_INSTRUCTIONS[tone as keyof typeof TONE_INSTRUCTIONS]
      || TONE_INSTRUCTIONS.professional;

    // 2) Déterminer s’il s’agit d’une demande "introduction", "conclusion" ou "title"
    //    => On adapte le template en fonction des mots-clés détectés.
    let finalPrompt = prompt;
    const promptLower = prompt.toLowerCase();

    if (promptLower.includes('introduction')) {
      finalPrompt = PROMPT_TEMPLATES.introduction + prompt;
    } else if (promptLower.includes('conclusion')) {
      finalPrompt = PROMPT_TEMPLATES.conclusion + prompt;
    } else if (promptLower.includes('title') || promptLower.includes('titre')) {
      finalPrompt = PROMPT_TEMPLATES.title + prompt;
    }

    // 3) Ajouter l’instruction de ton en en-tête
    finalPrompt = `${toneInstruction}\n\n${finalPrompt}`;

    // 4) Appel Ollama
    const response = await fetch('http://localhost:11434/api/generate', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        model: model,
        prompt: finalPrompt,
        stream: false,
        options: {
          temperature: 0.7,
          top_p: 0.9,
          top_k: 40,
          max_tokens: 300
        }
      })
    });

    if (!response.ok) {
      const error = await response.json();
      return NextResponse.json({ error: error.message }, { status: response.status });
    }

    // 5) Renvoyer la réponse d’Ollama (data.response)
    const data = await response.json();
    return NextResponse.json({ content: data.response });
  } catch (error) {
    console.error('Erreur de génération:', error);
    return NextResponse.json(
      { error: error instanceof Error ? error.message : 'Erreur lors de la génération' },
      { status: 500 }
    );
  }
}


================================================================================

===== C:\wamp64\www\75Tribune\src\app\api\ai\suggest\route.ts =====

import { NextResponse } from 'next/server';

export async function POST(request: Request) {
  try {
    const { prompt, model, tone } = await request.json();

    if (!prompt || !model || !tone) {
      return NextResponse.json(
        { error: 'Prompt, model et tone sont requis' },
        { status: 400 }
      );
    }

    // Construire le prompt avec le ton demandé
    const fullPrompt = `En utilisant un ton ${tone}, ${prompt}`;

    // Appeler l'API Ollama
    const response = await fetch('http://localhost:11434/api/generate', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        model: model,
        prompt: fullPrompt,
        stream: false,
      }),
    });

    if (!response.ok) {
      throw new Error('Erreur lors de l\'appel à Ollama');
    }

    const data = await response.json();
    
    return NextResponse.json({
      suggestion: data.response,
    });
  } catch (error) {
    console.error('Erreur AI:', error);
    return NextResponse.json(
      { error: 'Erreur lors de la génération de la suggestion' },
      { status: 500 }
    );
  }
}


================================================================================

===== C:\wamp64\www\75Tribune\src\app\api\articles\route.ts =====

import { NextRequest, NextResponse } from 'next/server';
import { ArticleService } from '@/services/article.service';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/lib/auth';
import { z } from 'zod';
import { Role, ArticleStatus } from '@prisma/client';

// Schéma de validation Zod pour la création d'articles
const createArticleSchema = z.object({
  title: z.string().min(1, 'Le titre est requis'),
  content: z.string().min(1, 'Le contenu est requis'),
  excerpt: z.string().optional(),
  status: z.enum(['DRAFT', 'PUBLISHED', 'ARCHIVED']).default('DRAFT'),
  accessLevel: z.enum(['FREE', 'BASIC', 'PRO']).default('FREE'),
  tags: z.array(z.string()).optional(),
  categories: z.array(z.string()).optional(),
  publishPlatforms: z.array(z.enum(['wordpress', 'youtube', 'twitter'])).optional(),
  featuredImage: z.string().optional(),
});

export async function POST(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return NextResponse.json({ error: 'Non autorisé' }, { status: 401 });
    }

    if (session.user.role !== Role.ADMIN) {
      return NextResponse.json(
        { error: 'Seuls les administrateurs peuvent publier des articles' },
        { status: 403 }
      );
    }

    const data = await request.json();
    console.log('Données reçues pour création article:', data);

    // Valider les données avec Zod
    const validatedData = createArticleSchema.parse(data);

    const article = await ArticleService.create({
      title: validatedData.title,
      content: validatedData.content,
      excerpt: validatedData.excerpt,
      status: validatedData.status,
      accessLevel: validatedData.accessLevel,
      tags: validatedData.tags || [],
      categories: validatedData.categories || [],
      authorId: session.user.id,
      publishPlatforms: validatedData.publishPlatforms || [],
      featuredImage: validatedData.featuredImage,
    });

    console.log('Article créé avec succès:', article.id);
    return NextResponse.json({ success: true, article }, { status: 201 });
  } catch (error) {
    console.error('Erreur dans POST /api/articles:', error);
    if (error instanceof z.ZodError) {
      return NextResponse.json(
        { error: 'Données invalides', details: error.errors },
        { status: 400 }
      );
    }
    return NextResponse.json(
      { error: error instanceof Error ? error.message : 'Erreur serveur' },
      { status: 500 }
    );
  }
}

export async function GET(request: NextRequest) {
  try {
    const searchParams = request.nextUrl.searchParams;
    const status = searchParams.get('status') as ArticleStatus | undefined;
    const page = parseInt(searchParams.get('page') || '1');
    const limit = parseInt(searchParams.get('limit') || '10');

    const articles = await ArticleService.list({
      status,
      page,
      limit,
    });

    return NextResponse.json(articles);
  } catch (error) {
    console.error('Erreur dans GET /api/articles:', error);
    return NextResponse.json(
      { error: 'Erreur lors de la récupération des articles' },
      { status: 500 }
    );
  }
}

================================================================================

===== C:\wamp64\www\75Tribune\src\app\api\articles\by-category\[id]\route.ts =====

import { NextRequest, NextResponse } from 'next/server';
import { prisma } from '@/lib/prisma';
import { ArticleStatus } from '@prisma/client';

export async function GET(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const articles = await prisma.article.findMany({
      where: {
        categories: {
          some: {
            id: params.id
          }
        },
        status: ArticleStatus.PUBLISHED
      },
      include: {
        author: {
          select: {
            id: true,
            name: true,
            email: true,
          },
        },
        tags: true,
        categories: true,
      },
      orderBy: {
        createdAt: 'desc',
      },
    });

    return NextResponse.json(articles);
  } catch (error) {
    console.error('Erreur lors de la récupération des articles:', error);
    return NextResponse.json(
      { error: 'Erreur lors de la récupération des articles' },
      { status: 500 }
    );
  }
}


================================================================================

===== C:\wamp64\www\75Tribune\src\app\api\articles\by-slug\[slug]\route.ts =====

import { NextResponse } from 'next/server';
import { prisma } from '@/lib/prisma';

export async function GET(
  request: Request,
  { params }: { params: { slug: string } }
) {
  try {
    const article = await prisma.article.findUnique({
      where: { slug: params.slug },
      include: {
        author: {
          select: {
            id: true,
            name: true,
            email: true,
          },
        },
        categories: true,
        tags: true,
      },
    });

    if (!article) {
      return NextResponse.json(
        { error: 'Article non trouvé' },
        { status: 404 }
      );
    }

    return NextResponse.json(article);
  } catch (error) {
    console.error('Erreur lors de la récupération de l\'article:', error);
    return NextResponse.json(
      { error: 'Erreur lors de la récupération de l\'article' },
      { status: 500 }
    );
  }
}


================================================================================

===== C:\wamp64\www\75Tribune\src\app\api\articles\views\route.ts =====

import { NextResponse } from 'next/server';
import { ArticleService } from '@/services/article.service';
import { ArticleViewService } from '@/services/articleView.service';
import { headers } from 'next/headers';

export async function POST(request: Request) {
  try {
    const { articleId, userId } = await request.json();
    const headersList = headers();
    const ip = headersList.get('x-forwarded-for') || headersList.get('x-real-ip');

    if (!articleId) {
      return NextResponse.json({ error: 'Article ID requis' }, { status: 400 });
    }

    // Enregistrer la vue directement avec l'ID
    await ArticleViewService.addView(articleId, userId, ip || undefined);

    return NextResponse.json({ success: true });
  } catch (error) {
    console.error('Erreur lors de l\'enregistrement de la vue:', error);
    return NextResponse.json(
      { error: 'Erreur lors de l\'enregistrement de la vue' },
      { status: 500 }
    );
  }
}


================================================================================

===== C:\wamp64\www\75Tribune\src\app\api\articles\[id]\route.ts =====

import { NextResponse } from 'next/server';
import { ArticleService } from '@/services/article.service';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/lib/auth';
import { UpdateArticleDTO, Platform } from '@/types/article';
import { ArticleStatus, AccessLevel, Role } from '@prisma/client';
// Importez votre WordPressPublisher
import { WordPressPublisher } from '@/services/publishers/WordPressPublisher';

export const GET = async (
  request: Request,
  { params }: { params: { id: string } }
) => {
  console.log('=== GET Article Start ===');
  console.log('Article ID:', params.id);
  
  try {
    const session = await getServerSession(authOptions);
    console.log('Session:', {
      user: session?.user,
      expires: session?.expires
    });

    if (!session?.user) {
      console.log('No session found, returning 401');
      return NextResponse.json(
        { error: 'Non autorisé - Authentification requise' },
        { status: 401 }
      );
    }

    const article = await ArticleService.getById(params.id);
    console.log('Article found:', {
      id: article?.id,
      title: article?.title,
      authorId: article?.authorId
    });

    if (!article) {
      console.log('Article not found, returning 404');
      return NextResponse.json({ error: 'Article non trouvé' }, { status: 404 });
    }

    // Vérifier si l'utilisateur est l'auteur ou a un rôle suffisant
    const isAdminOrModerator =
      session.user.role === Role.ADMIN || session.user.role === Role.MODERATOR;
    const isAuthor = article.authorId === session.user.id;
    
    console.log('Permission check:', {
      isAdminOrModerator,
      isAuthor,
      userRole: session.user.role,
      articleAuthorId: article.authorId,
      userId: session.user.id
    });

    if (!isAuthor && !isAdminOrModerator) {
      console.log('User not authorized, returning 403');
      return NextResponse.json(
        { error: 'Non autorisé - Vous n\'avez pas les permissions nécessaires' },
        { status: 403 }
      );
    }

    console.log('Access granted, returning article');
    return NextResponse.json(article);
  } catch (error) {
    console.error('Error in GET article:', error);
    return NextResponse.json(
      { error: 'Erreur lors de la récupération de l\'article' },
      { status: 500 }
    );
  } finally {
    console.log('=== GET Article End ===');
  }
};

export const PUT = async (
  request: Request,
  { params }: { params: { id: string } }
) => {
  console.log('=== PUT Article Start ===');
  console.log('Article ID:', params.id);
  
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      console.log('No session found, returning 401');
      return NextResponse.json({
        success: false,
        error: 'Non autorisé'
      }, { status: 401 });
    }

    const body = await request.json();
    console.log('Request body:', body);

    const article = await ArticleService.getById(params.id);
    if (!article) {
      console.log('Article not found, returning 404');
      return NextResponse.json({
        success: false,
        error: 'Article non trouvé'
      }, { status: 404 });
    }

    // Vérifier si l'utilisateur est l'auteur ou a un rôle suffisant
    const isAdminOrModerator =
      session.user.role === Role.ADMIN || session.user.role === Role.MODERATOR;
    const isAuthor = article.authorId === session.user.id;

    console.log('Permission check:', {
      isAdminOrModerator,
      isAuthor,
      userRole: session.user.role,
      articleAuthorId: article.authorId,
      userId: session.user.id
    });

    if (!isAuthor && !isAdminOrModerator) {
      console.log('User not authorized, returning 403');
      return NextResponse.json(
        {
          success: false,
          error: 'Non autorisé - Vous n\'avez pas les permissions nécessaires'
        },
        { status: 403 }
      );
    }

    console.log('Updating article with data:', {
      id: params.id,
      ...body
    });

    // 1) Mettre à jour l’article dans la BDD
    const updatedArticle = await ArticleService.update({
      id: params.id,
      ...body,
    });

    console.log('Article updated successfully:', {
      id: updatedArticle.id,
      title: updatedArticle.title,
      status: updatedArticle.status,
      publishPlatforms: updatedArticle.publishPlatforms,
    });

    // 2) Publication WordPress si la plateforme 'wordpress' est cochée
    //    ET que le statut de l'article est PUBLISHED
    if (
      updatedArticle.publishPlatforms?.includes('wordpress') &&
      updatedArticle.status === ArticleStatus.PUBLISHED
    ) {
      console.log('wordpress is in publishPlatforms; calling WordPressPublisher...');
      
      const publisher = new WordPressPublisher();
      const publishResult = await publisher.publish({
        title: updatedArticle.title,
        excerpt: updatedArticle.excerpt || '',
        content: updatedArticle.content || '',
        featuredImage: updatedArticle.featuredImage || undefined,
        categories: updatedArticle.categories?.map((cat: any) => cat.id) || [],
        tags: updatedArticle.tags?.map((tag: any) => tag.id) || [],
        slug: updatedArticle.slug || '', // <-- Ajouter la propriété slug ici
      });


      if (!publishResult.success) {
        console.error('Failed to publish to WordPress:', publishResult.error);
        // Vous pouvez soit ignorer l’erreur, soit le signaler.
      } else {
        console.log('Article published to WordPress:', publishResult.url);
        // Optionnel : stocker publishResult.url ou publishResult.platformId en BDD
      }
    }

    return NextResponse.json({
      success: true,
      article: updatedArticle
    });
  } catch (error: any) {
    console.error('Error in PUT article:', error);
    return NextResponse.json(
      {
        success: false,
        error: error.message || 'Erreur lors de la mise à jour de l\'article'
      },
      { status: 500 }
    );
  } finally {
    console.log('=== PUT Article End ===');
  }
};

export const DELETE = async (
  request: Request,
  { params }: { params: { id: string } }
) => {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return NextResponse.json({ error: 'Non autorisé' }, { status: 401 });
    }

    // Only admins can delete articles
    if (session.user.role !== Role.ADMIN) {
      return NextResponse.json(
        { error: 'Non autorisé - Action réservée aux administrateurs' },
        { status: 403 }
      );
    }

    await ArticleService.delete(params.id);
    return NextResponse.json({ success: true });
  } catch (error) {
    console.error('Error in DELETE article:', error);
    return NextResponse.json(
      { error: 'Erreur lors de la suppression de l\'article' },
      { status: 500 }
    );
  }
};


================================================================================

===== C:\wamp64\www\75Tribune\src\app\api\auth\check\route.ts =====

import { NextRequest, NextResponse } from 'next/server';
import { getAuthUser } from '@/lib/auth.utils';
import type { AuthUser } from '@/types/auth';

export const dynamic = 'force-dynamic';

export async function GET(request: NextRequest) {
  try {
    const user = await getAuthUser();
    
    if (!user) {
      return NextResponse.json({ user: null });
    }

    // Ne pas renvoyer d'informations sensibles
    const safeUser: AuthUser = {
      id: user.id,
      email: user.email,
      role: user.role,
    };

    // Ajouter le nom seulement s'il existe
    if (user.name) {
      safeUser.name = user.name;
    }

    return NextResponse.json({ user: safeUser });
  } catch (error) {
    console.error('Erreur vérification auth:', error);
    return NextResponse.json(
      { error: 'Erreur lors de la vérification de l\'authentification' },
      { status: 500 }
    );
  }
}


================================================================================

===== C:\wamp64\www\75Tribune\src\app\api\auth\forgot-password\route.ts =====

import { NextResponse } from 'next/server';
import { prisma } from '@/lib/prisma';
import { randomBytes } from 'crypto';
import { sendEmail } from '@/lib/email';

export async function POST(req: Request) {
  try {
    const { email } = await req.json();

    if (!email) {
      return NextResponse.json(
        { error: 'Email requis' },
        { status: 400 }
      );
    }

    // Générer un token de réinitialisation
    const passwordResetToken = randomBytes(32).toString('hex');
    const passwordResetExpires = new Date(Date.now() + 24 * 60 * 60 * 1000); // 24 heures

    // Mettre à jour ou créer un token de réinitialisation
    await prisma.user.update({
      where: { email: email.toLowerCase() },
      data: {
        passwordResetToken,
        passwordResetExpires,
      },
    });

    // Construire l'URL de réinitialisation
    const resetUrl = `${process.env.NEXT_PUBLIC_APP_URL}/reset-password?token=${passwordResetToken}`;

    // Envoyer l'email
    await sendEmail({
      to: email,
      subject: 'Réinitialisation de votre mot de passe 75Tribune',
      text: `Pour réinitialiser votre mot de passe, cliquez sur ce lien : ${resetUrl}`,
      html: `
        <div>
          <h1>Réinitialisation de votre mot de passe</h1>
          <p>Vous avez demandé la réinitialisation de votre mot de passe.</p>
          <p>Cliquez sur le lien ci-dessous pour définir un nouveau mot de passe :</p>
          <a href="${resetUrl}">Réinitialiser mon mot de passe</a>
          <p>Ce lien expirera dans 24 heures.</p>
          <p>Si vous n'avez pas demandé cette réinitialisation, vous pouvez ignorer cet email.</p>
        </div>
      `,
    });

    // Pour des raisons de sécurité, nous retournons toujours un succès
    return NextResponse.json({ success: true });
  } catch (error) {
    console.error('Erreur lors de la réinitialisation du mot de passe:', error);
    // Pour des raisons de sécurité, nous retournons toujours un succès
    return NextResponse.json({ success: true });
  }
}


================================================================================

===== C:\wamp64\www\75Tribune\src\app\api\auth\login\route.ts =====

import { NextRequest, NextResponse } from 'next/server';
import { prisma } from '@/lib/prisma';
import { comparePasswords, createToken, setAuthCookie } from '@/lib/auth.utils';
import { LoginCredentials } from '@/types/auth';
import { Role } from '@prisma/client';

export const dynamic = 'force-dynamic';
export const runtime = 'nodejs';

export async function POST(request: NextRequest) {
  try {
    const body = (await request.json()) as LoginCredentials;
    const { email, password } = body;

    console.log('Login attempt for:', email);

    if (!email || !password) {
      return NextResponse.json(
        { error: 'Email et mot de passe requis' },
        { status: 400 }
      );
    }

    const user = await prisma.user.findUnique({
      where: { email },
      select: {
        id: true,
        email: true,
        password: true,
        role: true,
        emailVerified: true,
        name: true
      }
    });

    console.log('User found:', {
      id: user?.id,
      email: user?.email,
      role: user?.role
    });

    if (!user) {
      return NextResponse.json(
        { error: 'Email ou mot de passe incorrect' },
        { status: 401 }
      );
    }

    const isValidPassword = await comparePasswords(password, user.password);

    if (!isValidPassword) {
      return NextResponse.json(
        { error: 'Email ou mot de passe incorrect' },
        { status: 401 }
      );
    }

    if (!user.emailVerified) {
      return NextResponse.json(
        { error: 'Veuillez vérifier votre email avant de vous connecter' },
        { status: 403 }
      );
    }

    // Créer le token avec le rôle correct
    const userForToken = {
      id: user.id,
      email: user.email,
      role: user.role as Role,
      name: user.name
    };

    console.log('Creating token for user:', userForToken);
    const token = await createToken(userForToken);

    const response = NextResponse.json({ 
      success: true,
      user: userForToken
    });

    await setAuthCookie(response, token);
    
    // Mettre à jour lastLogin
    await prisma.user.update({
      where: { id: user.id },
      data: { lastLogin: new Date() }
    });

    return response;

  } catch (error) {
    console.error('Erreur login:', error);
    return NextResponse.json(
      { error: 'Une erreur est survenue lors de la connexion' },
      { status: 500 }
    );
  }
}


================================================================================

===== C:\wamp64\www\75Tribune\src\app\api\auth\logout\route.ts =====

import { NextResponse } from 'next/server';
import { removeAuthCookie } from '@/lib/auth.utils';

export async function POST() {
  try {
    removeAuthCookie();
    return NextResponse.json({ success: true });
  } catch (error) {
    console.error('Erreur logout:', error);
    return NextResponse.json(
      { error: 'Erreur lors de la déconnexion' },
      { status: 500 }
    );
  }
}


================================================================================

===== C:\wamp64\www\75Tribune\src\app\api\auth\me\route.ts =====

import { NextResponse } from 'next/server';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/lib/auth';

export async function GET() {
  try {
    const session = await getServerSession(authOptions);

    if (!session?.user) {
      return NextResponse.json(
        { error: 'Non authentifié' },
        { status: 401 }
      );
    }

    return NextResponse.json({
      id: session.user.id,
      email: session.user.email,
      name: session.user.name,
      role: session.user.role,
    });
  } catch (error) {
    console.error('Erreur lors de la récupération des informations utilisateur:', error);
    return NextResponse.json(
      { error: 'Une erreur est survenue' },
      { status: 500 }
    );
  }
}


================================================================================

===== C:\wamp64\www\75Tribune\src\app\api\auth\register\route.ts =====

import { NextRequest, NextResponse } from 'next/server';
import { prisma } from '@/lib/prisma';
import { hashPassword, createToken, setAuthCookie, generateVerificationToken } from '@/lib/auth.utils';
import { RegisterCredentials } from '@/types/auth';
import { sendEmail } from '@/lib/email';

export const dynamic = 'force-dynamic';
export const runtime = 'nodejs';

export async function POST(request: NextRequest) {
  try {
    const body = (await request.json()) as RegisterCredentials;
    const { email, password, name } = body;

    if (!email || !password) {
      return NextResponse.json(
        { error: 'Email et mot de passe requis' },
        { status: 400 }
      );
    }

    // Vérifier si l'utilisateur existe déjà
    const existingUser = await prisma.user.findUnique({
      where: { email },
    });

    if (existingUser) {
      return NextResponse.json(
        { error: 'Cet email est déjà utilisé' },
        { status: 400 }
      );
    }

    const hashedPassword = await hashPassword(password);
    const verificationToken = await generateVerificationToken();
    console.log('Token généré:', verificationToken);

    const user = await prisma.user.create({
      data: {
        email,
        password: hashedPassword,
        name,
        role: 'USER',
        subscriptionType: 'FREE',
        emailVerificationToken: verificationToken,
        emailVerified: false,
      },
      select: {
        id: true,
        email: true,
        role: true,
        name: true,
        emailVerificationToken: true,
      },
    });

    console.log('Utilisateur créé avec token:', user.emailVerificationToken);

    // Envoyer l'email de vérification
    const verificationUrl = `${process.env.NEXTAUTH_URL}/verify-email?token=${verificationToken}&email=${encodeURIComponent(email)}`;
    
    try {
      await sendEmail({
        to: email,
        subject: 'Vérification de votre compte - 75Tribune',
        text: `Bonjour ${name},\n\nMerci de vous être inscrit sur 75Tribune. Pour vérifier votre compte, veuillez cliquer sur le lien suivant :\n\n${verificationUrl}\n\nSi vous n'avez pas créé de compte sur 75Tribune, vous pouvez ignorer cet email.\n\nCordialement,\nL'équipe 75Tribune`,
        html: `
          <h1>Bienvenue sur 75Tribune !</h1>
          <p>Bonjour ${name},</p>
          <p>Merci de vous être inscrit sur 75Tribune. Pour vérifier votre compte, veuillez cliquer sur le lien suivant :</p>
          <p><a href="${verificationUrl}">Vérifier mon compte</a></p>
          <p>Si vous n'avez pas créé de compte sur 75Tribune, vous pouvez ignorer cet email.</p>
          <p>Cordialement,<br>L'équipe 75Tribune</p>
        `
      });
      console.log('Email de vérification envoyé à:', email);
    } catch (emailError) {
      console.error('Erreur détaillée lors de l\'envoi de l\'email:', emailError);
      // On continue malgré l'erreur d'email, l'utilisateur pourra utiliser la fonction de renvoi
    }

    const token = await createToken({
      id: user.id,
      email: user.email,
      role: user.role,
    });

    const response = NextResponse.json({ 
      success: true,
      message: 'Inscription réussie. Veuillez vérifier votre email.',
      debug: process.env.NODE_ENV === 'development' ? { verificationToken } : undefined
    });

    await setAuthCookie(response, token);
    return response;

  } catch (error) {
    console.error('Erreur complète lors de l\'inscription:', error);
    return NextResponse.json(
      { error: 'Une erreur est survenue lors de l\'inscription' },
      { status: 500 }
    );
  }
}


================================================================================

===== C:\wamp64\www\75Tribune\src\app\api\auth\resend-verification\route.ts =====

import { NextResponse } from 'next/server';
import { prisma } from '@/lib/prisma';
import { sendEmail } from '@/lib/email';
import crypto from 'crypto';

export async function POST(request: Request) {
  try {
    const { email } = await request.json();

    if (!email) {
      return NextResponse.json(
        { error: 'Email requis' },
        { status: 400 }
      );
    }

    const user = await prisma.user.findUnique({
      where: { email },
      select: {
        id: true,
        emailVerified: true,
        name: true
      }
    });

    if (!user || user.emailVerified) {
      // Retourner une réponse positive même si l'utilisateur n'existe pas
      // pour éviter la divulgation d'informations
      return NextResponse.json({
        message: 'Si un compte non vérifié existe avec cet email, un nouveau lien de vérification sera envoyé.'
      });
    }

    // Générer un nouveau token de vérification
    const verificationToken = crypto.randomBytes(32).toString('hex');

    // Mettre à jour le token dans la base de données
    await prisma.user.update({
      where: { id: user.id },
      data: {
        emailVerificationToken: verificationToken
      }
    });

    const verificationUrl = `${process.env.NEXTAUTH_URL}/verify-email?token=${verificationToken}`;

    // Envoyer l'email
    await sendEmail({
      to: email,
      subject: 'Vérification de votre compte - 75Tribune',
      text: `Bonjour ${user.name},\n\nMerci de vous être inscrit sur 75Tribune. Pour vérifier votre compte, veuillez cliquer sur le lien suivant :\n\n${verificationUrl}\n\nSi vous n'avez pas créé de compte sur 75Tribune, vous pouvez ignorer cet email.\n\nCordialement,\nL'équipe 75Tribune`,
      html: `
        <h1>Vérification de votre compte</h1>
        <p>Bonjour ${user.name},</p>
        <p>Merci de vous être inscrit sur 75Tribune. Pour vérifier votre compte, veuillez cliquer sur le bouton ci-dessous :</p>
        <p style="text-align: center; margin: 30px 0;">
          <a href="${verificationUrl}" style="background-color: #0284c7; color: white; padding: 12px 24px; text-decoration: none; border-radius: 5px; display: inline-block;">
            Vérifier mon compte
          </a>
        </p>
        <p>Si le bouton ne fonctionne pas, vous pouvez copier et coller le lien suivant dans votre navigateur :</p>
        <p style="background-color: #f3f4f6; padding: 10px; word-break: break-all;">
          ${verificationUrl}
        </p>
        <p>Si vous n'avez pas créé de compte sur 75Tribune, vous pouvez ignorer cet email.</p>
        <p>Cordialement,<br>L'équipe 75Tribune</p>
      `
    });

    return NextResponse.json({
      message: 'Un nouveau lien de vérification a été envoyé à votre adresse email.'
    });
  } catch (error) {
    console.error('Erreur lors du renvoi du lien de vérification:', error);
    return NextResponse.json(
      { error: 'Une erreur est survenue lors de l\'envoi du lien de vérification.' },
      { status: 500 }
    );
  }
}


================================================================================

===== C:\wamp64\www\75Tribune\src\app\api\auth\reset-password\route.ts =====

import { NextResponse } from 'next/server';
import { prisma } from '@/lib/prisma';
import { hashPassword } from '@/lib/auth.utils';

export async function POST(request: Request) {
  try {
    const { token, password } = await request.json();

    if (!token || !password) {
      return NextResponse.json(
        { error: 'Token et mot de passe requis' },
        { status: 400 }
      );
    }

    // Trouver l'utilisateur avec le token de réinitialisation
    const user = await prisma.user.findFirst({
      where: {
        passwordResetToken: token,
        passwordResetExpires: {
          gt: new Date()
        }
      },
      select: {
        id: true
      }
    });

    if (!user) {
      return NextResponse.json(
        { error: 'Token invalide ou expiré' },
        { status: 400 }
      );
    }

    // Hasher le nouveau mot de passe
    const hashedPassword = await hashPassword(password);

    // Mettre à jour le mot de passe et supprimer le token
    await prisma.user.update({
      where: { id: user.id },
      data: {
        password: hashedPassword,
        passwordResetToken: null,
        passwordResetExpires: null
      }
    });

    return NextResponse.json({
      message: 'Mot de passe mis à jour avec succès'
    });
  } catch (error) {
    console.error('Erreur lors de la réinitialisation du mot de passe:', error);
    return NextResponse.json(
      { error: 'Erreur lors de la réinitialisation du mot de passe' },
      { status: 500 }
    );
  }
}


================================================================================

===== C:\wamp64\www\75Tribune\src\app\api\auth\verify-email\route.ts =====

import { NextRequest, NextResponse } from 'next/server';
import { prisma } from '@/lib/prisma';

export const dynamic = 'force-dynamic';

export async function POST(request: NextRequest) {
  try {
    const { token, email } = await request.json();

    if (!token || !email) {
      return NextResponse.json(
        { error: 'Token et email requis' },
        { status: 400 }
      );
    }

    // Rechercher l'utilisateur par email et token
    const user = await prisma.user.findFirst({
      where: {
        email,
        emailVerificationToken: token,
      },
      select: {
        id: true
      }
    });

    if (!user) {
      return NextResponse.json(
        { error: 'Token invalide ou expiré' },
        { status: 400 }
      );
    }

    // Marquer l'email comme vérifié et supprimer le token
    await prisma.user.update({
      where: { id: user.id },
      data: {
        emailVerified: true,
        emailVerificationToken: null,
      },
    });

    return NextResponse.json({
      success: true,
      message: 'Email vérifié avec succès',
    });
  } catch (error) {
    console.error('Erreur vérification email:', error);
    return NextResponse.json(
      { error: 'Erreur lors de la vérification de l\'email' },
      { status: 500 }
    );
  }
}


================================================================================

===== C:\wamp64\www\75Tribune\src\app\api\auth\[...nextauth]\route.ts =====

import NextAuth from "next-auth";
import { authOptions } from "@/lib/auth";

const handler = NextAuth(authOptions);

export { handler as GET, handler as POST };

================================================================================

===== C:\wamp64\www\75Tribune\src\app\api\categories\route.ts =====

import { NextRequest, NextResponse } from 'next/server';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/lib/auth';
import { CategoryService } from '@/services/category.service';
import { Role } from '@prisma/client';
import { ZodError } from 'zod';
import { createCategorySchema, updateCategorySchema } from '@/lib/validations/category';

const categoryService = new CategoryService();

export async function GET(request: NextRequest) {
  try {
    const searchParams = request.nextUrl.searchParams;
    const activeOnly = searchParams.get('activeOnly') === 'true';
    const tree = searchParams.get('tree') === 'true';

    const categories = tree 
      ? await categoryService.getTree(activeOnly)
      : await categoryService.findAll(activeOnly);
      
    return NextResponse.json(categories);
  } catch (error) {
    console.error('Erreur lors de la récupération des catégories:', error);
    return NextResponse.json(
      { error: 'Erreur lors de la récupération des catégories' },
      { status: 500 }
    );
  }
}

export async function POST(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions);
    
    if (!session?.user || session.user.role !== Role.ADMIN) {
      return NextResponse.json(
        { error: 'Non autorisé' },
        { status: 403 }
      );
    }

    const data = await request.json();
    
    try {
      const validatedData = createCategorySchema.parse(data);
      const category = await categoryService.create(validatedData);
      return NextResponse.json(category, { status: 201 });
    } catch (error) {
      if (error instanceof ZodError) {
        return NextResponse.json(
          { error: 'Données invalides', details: error.errors },
          { status: 400 }
        );
      }
      throw error;
    }
  } catch (error) {
    console.error('Erreur lors de la création de la catégorie:', error);
    return NextResponse.json(
      { error: 'Erreur lors de la création de la catégorie' },
      { status: 500 }
    );
  }
}

export async function PUT(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions);
    
    if (!session?.user || session.user.role !== Role.ADMIN) {
      return NextResponse.json(
        { error: 'Non autorisé' },
        { status: 403 }
      );
    }

    const data = await request.json();
    
    try {
      const validatedData = updateCategorySchema.parse(data);
      const category = await categoryService.update(validatedData);
      return NextResponse.json(category);
    } catch (error) {
      if (error instanceof ZodError) {
        return NextResponse.json(
          { error: 'Données invalides', details: error.errors },
          { status: 400 }
        );
      }
      throw error;
    }
  } catch (error) {
    console.error('Erreur lors de la mise à jour de la catégorie:', error);
    return NextResponse.json(
      { error: 'Erreur lors de la mise à jour de la catégorie' },
      { status: 500 }
    );
  }
}

export async function DELETE(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions);
    
    if (!session?.user || session.user.role !== Role.ADMIN) {
      return NextResponse.json(
        { error: 'Non autorisé' },
        { status: 403 }
      );
    }

    const searchParams = request.nextUrl.searchParams;
    const id = searchParams.get('id');

    if (!id) {
      return NextResponse.json(
        { error: 'ID de catégorie manquant' },
        { status: 400 }
      );
    }

    await categoryService.delete(id);
    return new NextResponse(null, { status: 204 });
  } catch (error) {
    console.error('Erreur lors de la suppression de la catégorie:', error);
    if (error instanceof Error && error.message === 'Cannot delete category with articles or subcategories') {
      return NextResponse.json(
        { error: 'Impossible de supprimer une catégorie contenant des articles ou des sous-catégories' },
        { status: 400 }
      );
    }
    return NextResponse.json(
      { error: 'Erreur lors de la suppression de la catégorie' },
      { status: 500 }
    );
  }
}


================================================================================

===== C:\wamp64\www\75Tribune\src\app\api\categories\by-slug\route.ts =====

import { NextRequest, NextResponse } from 'next/server';
import { prisma } from '@/lib/prisma';

export async function GET(
  request: NextRequest,
  { params }: { params: { slug: string } }
) {
  try {
    const slug = params.slug;
    const category = await prisma.category.findFirst({
      where: { slug },
      include: {
        parent: true,
        children: true,
      },
    });

    if (!category) {
      return NextResponse.json(
        { error: 'Catégorie non trouvée' },
        { status: 404 }
      );
    }

    return NextResponse.json(category);
  } catch (error) {
    console.error('Erreur lors de la récupération de la catégorie:', error);
    return NextResponse.json(
      { error: 'Erreur lors de la récupération de la catégorie' },
      { status: 500 }
    );
  }
}


================================================================================

===== C:\wamp64\www\75Tribune\src\app\api\categories\by-slug\[slug]\route.ts =====

import { NextRequest, NextResponse } from 'next/server';
import { CategoryService } from '@/services/category.service';

const categoryService = new CategoryService();

export async function GET(
  request: NextRequest,
  { params }: { params: { slug: string } }
) {
  try {
    const category = await categoryService.findBySlug(params.slug);

    if (!category) {
      return NextResponse.json(
        { error: 'Catégorie non trouvée' },
        { status: 404 }
      );
    }

    return NextResponse.json(category);
  } catch (error) {
    console.error('Erreur lors de la récupération de la catégorie:', error);
    return NextResponse.json(
      { error: 'Erreur lors de la récupération de la catégorie' },
      { status: 500 }
    );
  }
}


================================================================================

===== C:\wamp64\www\75Tribune\src\app\api\categories\[id]\route.ts =====

import { NextRequest, NextResponse } from 'next/server';
import { CategoryService } from '@/services/category.service';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/lib/auth';
import { Role } from '@prisma/client';

export async function GET(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const category = await CategoryService.getById(params.id);
    if (!category) {
      return NextResponse.json({ error: 'Catégorie non trouvée' }, { status: 404 });
    }
    return NextResponse.json(category);
  } catch (error) {
    console.error('Erreur lors de la récupération de la catégorie:', error);
    return NextResponse.json(
      { error: 'Erreur lors de la récupération de la catégorie' },
      { status: 500 }
    );
  }
}

export async function PUT(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const session = await getServerSession(authOptions);
    // Vérifier si l'utilisateur est admin
    if (!session?.user || session.user.role !== Role.ADMIN) {
      return NextResponse.json(
        { error: 'Non autorisé' },
        { status: 403 }
      );
    }

    const data = await request.json();
    const category = await CategoryService.update(params.id, data);

    return NextResponse.json(category);
  } catch (error) {
    console.error('Erreur lors de la mise à jour de la catégorie:', error);
    return NextResponse.json(
      { error: 'Erreur lors de la mise à jour de la catégorie' },
      { status: 500 }
    );
  }
}

export async function DELETE(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user || session.user.role !== Role.ADMIN) {
      return NextResponse.json(
        { error: 'Non autorisé' },
        { status: 403 }
      );
    }

    const result = await CategoryService.delete(params.id);
    return NextResponse.json({ success: true, data: result });
  } catch (error) {
    console.error('Erreur lors de la suppression de la catégorie:', error);
    return NextResponse.json(
      { error: 'Erreur lors de la suppression de la catégorie' },
      { status: 500 }
    );
  }
}


================================================================================

===== C:\wamp64\www\75Tribune\src\app\api\comments\route.ts =====

import { NextResponse } from 'next/server';
import { prisma } from '@/lib/prisma';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/lib/auth';
import { createNotification } from '../notifications/route';

// GET /api/comments?articleId=xxx
export async function GET(request: Request) {
  try {
    const { searchParams } = new URL(request.url);
    const articleId = searchParams.get('articleId');

    if (!articleId) {
      return NextResponse.json({ error: 'Article ID requis' }, { status: 400 });
    }

    const comments = await prisma.comment.findMany({
      where: {
        articleId,
        isApproved: true,
        parent: null
      },
      include: {
        author: true,
        parent: true,
        replies: {
          where: {
            isApproved: true,
          },
          include: {
            author: true,
          },
          orderBy: {
            createdAt: 'asc',
          },
        },
      },
      orderBy: {
        createdAt: 'desc',
      },
    });

    console.log('Comments with authors:', JSON.stringify(comments, null, 2));

    return NextResponse.json(comments);
  } catch (error) {
    console.error('Erreur lors de la récupération des commentaires:', error);
    return NextResponse.json(
      { error: 'Erreur lors de la récupération des commentaires' },
      { status: 500 }
    );
  }
}

// POST /api/comments
export async function POST(request: Request) {
  try {
    const session = await getServerSession(authOptions);
    if (!session) {
      return NextResponse.json(
        { error: 'Vous devez être connecté' },
        { status: 401 }
      );
    }

    const { content, articleId, parentId } = await request.json();

    if (!content || !articleId) {
      return NextResponse.json(
        { error: 'Contenu et ID de l\'article requis' },
        { status: 400 }
      );
    }

    // Si c'est une réponse, vérifier que le commentaire parent existe
    if (parentId) {
      const parentComment = await prisma.comment.findUnique({
        where: { id: parentId },
      });

      if (!parentComment) {
        return NextResponse.json(
          { error: 'Commentaire parent non trouvé' },
          { status: 404 }
        );
      }
    }

    // Créer le commentaire
    const comment = await prisma.comment.create({
      data: {
        content,
        author: {
          connect: { id: session.user.id }
        },
        article: {
          connect: { id: articleId }
        },
        ...(parentId && {
          parent: {
            connect: { id: parentId }
          }
        }),
        isApproved: true
      },
      include: {
        author: {
          select: {
            id: true,
            name: true,
            avatar: true,
          }
        },
        parent: true,
        replies: true
      }
    });

    // Si c'est une réponse, créer une notification
    if (parentId) {
      const parentComment = await prisma.comment.findUnique({
        where: { id: parentId },
        include: { author: true }
      });

      if (parentComment && parentComment.author.id !== session.user.id) {
        await createNotification({
          type: 'COMMENT_REPLY',
          content: `${session.user.name} a répondu à votre commentaire`,
          userId: parentComment.author.id,
          articleId,
          commentId: comment.id
        });
      }
    }

    return NextResponse.json(comment);
  } catch (error) {
    console.error('Erreur lors de la création du commentaire:', error);
    return NextResponse.json(
      { error: 'Erreur lors de la création du commentaire' },
      { status: 500 }
    );
  }
}


================================================================================

===== C:\wamp64\www\75Tribune\src\app\api\comments\[id]\route.ts =====

import { NextResponse } from 'next/server';
import { prisma } from '@/lib/prisma';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/lib/auth';

// PATCH /api/comments/[id] - Pour approuver/désapprouver un commentaire
export async function PATCH(
  request: Request,
  { params }: { params: { id: string } }
) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user || session.user.role !== 'ADMIN') {
      return NextResponse.json(
        { error: 'Non autorisé' },
        { status: 403 }
      );
    }

    const { id } = params;
    const json = await request.json();
    const { isApproved } = json;

    const comment = await prisma.comment.update({
      where: { id },
      data: { isApproved },
      include: {
        author: {
          select: {
            id: true,
            name: true,
          },
        },
      },
    });

    return NextResponse.json(comment);
  } catch (error) {
    console.error('Erreur lors de la mise à jour du commentaire:', error);
    return NextResponse.json(
      { error: 'Erreur lors de la mise à jour du commentaire' },
      { status: 500 }
    );
  }
}

// DELETE /api/comments/[id]
export async function DELETE(
  request: Request,
  { params }: { params: { id: string } }
) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return NextResponse.json(
        { error: 'Non autorisé' },
        { status: 403 }
      );
    }

    const { id } = params;
    
    // Vérifier si l'utilisateur est l'auteur du commentaire ou un admin
    const comment = await prisma.comment.findUnique({
      where: { id },
      select: { authorId: true },
    });

    if (!comment) {
      return NextResponse.json(
        { error: 'Commentaire non trouvé' },
        { status: 404 }
      );
    }

    if (comment.authorId !== session.user.id && session.user.role !== 'ADMIN') {
      return NextResponse.json(
        { error: 'Non autorisé' },
        { status: 403 }
      );
    }

    await prisma.comment.delete({
      where: { id },
    });

    return NextResponse.json({ success: true });
  } catch (error) {
    console.error('Erreur lors de la suppression du commentaire:', error);
    return NextResponse.json(
      { error: 'Erreur lors de la suppression du commentaire' },
      { status: 500 }
    );
  }
}


================================================================================

===== C:\wamp64\www\75Tribune\src\app\api\dashboard\stats\route.ts =====

import { NextResponse } from 'next/server';
import { prisma } from '@/lib/prisma';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/lib/auth';
import { Role, SubscriptionType } from '@prisma/client';

export async function GET() {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user || session.user.role !== Role.ADMIN) {
      return NextResponse.json({ error: 'Non autorisé' }, { status: 401 });
    }

    // Get current date and last month date
    const now = new Date();
    const lastMonth = new Date(now.getFullYear(), now.getMonth() - 1, now.getDate());

    // Get total subscribers
    const totalSubscribers = await prisma.user.count({
      where: {
        subscriptionType: {
          not: SubscriptionType.FREE
        }
      }
    });

    // Get last month subscribers
    const lastMonthSubscribers = await prisma.user.count({
      where: {
        subscriptionType: {
          not: SubscriptionType.FREE
        },
        createdAt: {
          lt: now,
          gte: lastMonth
        }
      }
    });

    // Get published articles count
    const publishedArticles = await prisma.article.count({
      where: {
        status: 'PUBLISHED'
      }
    });

    // Get last month published articles
    const lastMonthPublishedArticles = await prisma.article.count({
      where: {
        status: 'PUBLISHED',
        createdAt: {
          lt: now,
          gte: lastMonth
        }
      }
    });

    // Calculate monthly revenue (assuming premium is 9.99€ and pro is 19.99€)
    const subscriptionCounts = await prisma.user.groupBy({
      by: ['subscriptionType'],
      where: {
        subscriptionType: {
          not: SubscriptionType.FREE
        }
      },
      _count: true
    });

    let monthlyRevenue = 0;
    let lastMonthRevenue = 0;

    for (const sub of subscriptionCounts) {
      const price = sub.subscriptionType === SubscriptionType.PREMIUM ? 9.99 : 19.99;
      monthlyRevenue += price * sub._count;
    }

    // Last month revenue calculation
    const lastMonthSubs = await prisma.user.groupBy({
      by: ['subscriptionType'],
      where: {
        subscriptionType: {
          not: SubscriptionType.FREE
        },
        createdAt: {
          lt: now,
          gte: lastMonth
        }
      },
      _count: true
    });

    for (const sub of lastMonthSubs) {
      const price = sub.subscriptionType === SubscriptionType.PREMIUM ? 9.99 : 19.99;
      lastMonthRevenue += price * sub._count;
    }

    // Calculate percentages
    const subscriberGrowth = totalSubscribers > 0 
      ? ((totalSubscribers - lastMonthSubscribers) / totalSubscribers) * 100 
      : 0;
    
    const articleGrowth = publishedArticles > 0 
      ? ((publishedArticles - lastMonthPublishedArticles) / publishedArticles) * 100 
      : 0;

    const revenueGrowth = monthlyRevenue > 0 
      ? ((monthlyRevenue - lastMonthRevenue) / monthlyRevenue) * 100 
      : 0;

    // Get total views (you might need to implement a view tracking system)
    const totalViews = 0; // Implement view tracking
    const lastMonthViews = 0; // Implement view tracking
    const viewsGrowth = 0;

    return NextResponse.json({
      subscribers: {
        total: totalSubscribers,
        growth: subscriberGrowth.toFixed(1)
      },
      articles: {
        total: publishedArticles,
        growth: articleGrowth.toFixed(1)
      },
      views: {
        total: totalViews,
        growth: viewsGrowth.toFixed(1)
      },
      revenue: {
        total: monthlyRevenue.toFixed(2),
        growth: revenueGrowth.toFixed(1)
      }
    });

  } catch (error) {
    console.error('Error fetching dashboard stats:', error);
    return NextResponse.json(
      { error: 'Erreur lors de la récupération des statistiques' },
      { status: 500 }
    );
  }
}


================================================================================

===== C:\wamp64\www\75Tribune\src\app\api\notifications\route.ts =====

import { NextResponse } from 'next/server';
import { prisma } from '@/lib/prisma';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/lib/auth';

// GET /api/notifications
export async function GET(request: Request) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return NextResponse.json(
        { error: 'Non autorisé' },
        { status: 401 }
      );
    }

    const notifications = await prisma.notification.findMany({
      where: {
        userId: session.user.id,
      },
      include: {
        article: {
          select: {
            id: true,
            title: true,
            slug: true,
          },
        },
        comment: {
          select: {
            id: true,
            content: true,
            author: {
              select: {
                name: true,
              },
            },
          },
        },
      },
      orderBy: {
        createdAt: 'desc',
      },
    });

    return NextResponse.json(notifications);
  } catch (error) {
    console.error('Erreur lors de la récupération des notifications:', error);
    return NextResponse.json(
      { error: 'Erreur lors de la récupération des notifications' },
      { status: 500 }
    );
  }
}

// PATCH /api/notifications?id=xxx - Marquer comme lu
export async function PATCH(request: Request) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return NextResponse.json(
        { error: 'Non autorisé' },
        { status: 401 }
      );
    }

    const { searchParams } = new URL(request.url);
    const id = searchParams.get('id');

    if (!id) {
      return NextResponse.json(
        { error: 'ID de notification requis' },
        { status: 400 }
      );
    }

    const notification = await prisma.notification.findUnique({
      where: { id },
      select: { userId: true },
    });

    if (!notification || notification.userId !== session.user.id) {
      return NextResponse.json(
        { error: 'Notification non trouvée' },
        { status: 404 }
      );
    }

    const updatedNotification = await prisma.notification.update({
      where: { id },
      data: { isRead: true },
    });

    return NextResponse.json(updatedNotification);
  } catch (error) {
    console.error('Erreur lors de la mise à jour de la notification:', error);
    return NextResponse.json(
      { error: 'Erreur lors de la mise à jour de la notification' },
      { status: 500 }
    );
  }
}

// Fonction utilitaire pour créer une notification
export async function createNotification(data: {
  type: 'COMMENT_REPLY' | 'NEW_COMMENT';
  content: string;
  userId: string;
  articleId?: string;
  commentId?: string;
}) {
  return prisma.notification.create({
    data,
  });
}


================================================================================

===== C:\wamp64\www\75Tribune\src\app\api\ollama\route.ts =====

import { NextResponse } from 'next/server';

function formatContent(content: string): string {
  // Nettoyer le contenu initial
  let formattedContent = content.trim();

  // Forcer les points à être suivis d'un double saut de ligne pour créer des paragraphes
  formattedContent = formattedContent.replace(/\.\s+/g, '.\n\n');
  formattedContent = formattedContent.replace(/!\s+/g, '!\n\n');
  formattedContent = formattedContent.replace(/\?\s+/g, '?\n\n');

  // Séparer en paragraphes
  const paragraphs = formattedContent
    .split(/\n\n+/)
    .map(p => p.trim())
    .filter(p => p.length > 0);

  // Traiter chaque paragraphe
  const processedParagraphs = paragraphs.map(paragraph => {
    // Vérifier si c'est une liste
    if (paragraph.includes('\n-') || paragraph.startsWith('-')) {
      const items = paragraph
        .split(/\n-/)
        .map(item => item.trim())
        .filter(item => item.length > 0)
        .map(item => `<li>${item}</li>`)
        .join('');
      return `<ul class="list-disc list-inside my-4">${items}</ul>`;
    }

    // Vérifier si c'est un titre
    if (paragraph.startsWith('#')) {
      const matches = paragraph.match(/^#+/);
      if (!matches) return `<p class="my-4">${paragraph}</p>`;
      const level = Math.min(matches[0].length, 6);
      const text = paragraph.replace(/^#+\s*/, '');
      const classes = level === 1 ? 'text-3xl font-bold my-6' :
                     level === 2 ? 'text-2xl font-bold my-5' :
                     'text-xl font-bold my-4';
      return `<h${level} class="${classes}">${text}</h${level}>`;
    }

    // Traiter le texte du paragraphe
    let processedText = paragraph
      // Gras
      .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
      // Italique
      .replace(/\*(.*?)\*/g, '<em>$1</em>');

    // Retourner le paragraphe avec espacement
    return `<p class="my-4 leading-relaxed">${processedText}</p>`;
  });

  // Joindre tous les éléments avec des sauts de ligne
  return processedParagraphs.join('\n');
}

export async function POST(request: Request) {
  try {
    const { model, prompt, tone, context } = await request.json();

    const fullPrompt = `
      Ton: ${tone}
      Contexte: ${context}
      
      Instructions de formatage:
      - Termine chaque phrase par un point suivi d'un retour à la ligne
      - Utilise des paragraphes courts (2-3 phrases)
      - Commence les nouveaux paragraphes par un double retour à la ligne
      - Utilise des titres avec # pour les sections principales
      - Utilise des listes avec - pour énumérer des points
      - Mets en **gras** les points importants
      - Utilise l'*italique* pour l'emphase
      
      ${prompt}
    `;

    const ollamaResponse = await fetch('http://localhost:11434/api/generate', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        model: model,
        prompt: fullPrompt,
        stream: false,
      }),
    });

    if (!ollamaResponse.ok) {
      throw new Error('Erreur lors de la communication avec Ollama');
    }

    const data = await ollamaResponse.json();
    const formattedContent = formatContent(data.response);

    return NextResponse.json({
      content: formattedContent,
    });
  } catch (error) {
    console.error('Erreur API Ollama:', error);
    return NextResponse.json(
      { error: 'Erreur lors de la génération du contenu' },
      { status: 500 }
    );
  }
}


================================================================================

===== C:\wamp64\www\75Tribune\src\app\api\publish\wordpress\route.ts =====

import { NextResponse } from 'next/server';
import { WordPressPublisher } from '@/services/publishers/WordPressPublisher';

export async function POST(request: Request) {
  try {
    const data = await request.json();
    console.log("📤 Publication sur WordPress avec les données :", data);

    // Publier l'article sur WordPress
    const publisher = new WordPressPublisher();
    const result = await publisher.publish(data);

    if (!result.success) {
      console.error("❌ Erreur WordPress :", result.error);
      throw new Error(result.error);
    }

    console.log(`✅ Article publié avec succès sur WordPress : ${result.url}`);
    return NextResponse.json({ url: result.url });

  } catch (error) {
    console.error('❌ Erreur lors de la publication sur WordPress:', error);
    return NextResponse.json({ error: error instanceof Error ? error.message : 'Erreur serveur' }, { status: 500 });
  }
}


================================================================================

===== C:\wamp64\www\75Tribune\src\app\api\settings\route.ts =====

import { NextResponse } from "next/server"
import { prisma } from "@/lib/prisma"

export async function GET() {
  try {
    const settings = await prisma.settings.findFirst()
    return NextResponse.json(settings)
  } catch (error) {
    console.error("Erreur lors de la récupération des paramètres:", error)
    return new NextResponse("Erreur interne du serveur", { status: 500 })
  }
}

export async function PUT(request: Request) {
  try {
    const body = await request.json()
    
    const settings = await prisma.settings.upsert({
      where: {
        id: 1, // Nous utilisons un ID fixe car nous n'avons qu'un seul enregistrement de paramètres
      },
      update: {
        siteName: body.siteName,
        siteUrl: body.siteUrl,
        contactEmail: body.contactEmail,
        adminEmail: body.adminEmail,
      },
      create: {
        siteName: body.siteName,
        siteUrl: body.siteUrl,
        contactEmail: body.contactEmail,
        adminEmail: body.adminEmail,
      },
    })

    return NextResponse.json(settings)
  } catch (error) {
    console.error("Erreur lors de la mise à jour des paramètres:", error)
    return new NextResponse("Erreur interne du serveur", { status: 500 })
  }
}


================================================================================

===== C:\wamp64\www\75Tribune\src\app\api\upload\route.ts =====

import { NextResponse } from 'next/server';
import { UploadService } from '@/services/upload.service';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/lib/auth';

export async function POST(request: Request) {
  try {
    const session = await getServerSession(authOptions);
    
    if (!session?.user) {
      return NextResponse.json({ error: 'Non autorisé' }, { status: 401 });
    }

    const formData = await request.formData();
    const file = formData.get('file') as File;

    if (!file) {
      return NextResponse.json(
        { error: 'Aucun fichier fourni' },
        { status: 400 }
      );
    }

    const imagePath = await UploadService.saveImage(file);

    return NextResponse.json({ url: imagePath });
  } catch (error) {
    console.error('Erreur upload image:', error);
    return NextResponse.json(
      { error: error instanceof Error ? error.message : 'Erreur lors de l\'upload' },
      { status: 500 }
    );
  }
}

export async function DELETE(request: Request) {
  try {
    const session = await getServerSession(authOptions);
    
    if (!session?.user) {
      return NextResponse.json({ error: 'Non autorisé' }, { status: 401 });
    }

    const { searchParams } = new URL(request.url);
    const fileName = searchParams.get('file');

    if (!fileName) {
      return NextResponse.json(
        { error: 'Nom de fichier non fourni' },
        { status: 400 }
      );
    }

    await UploadService.deleteImage(fileName);

    return NextResponse.json({ success: true });
  } catch (error) {
    console.error('Erreur suppression image:', error);
    return NextResponse.json(
      { error: error instanceof Error ? error.message : 'Erreur lors de la suppression' },
      { status: 500 }
    );
  }
}


================================================================================

===== C:\wamp64\www\75Tribune\src\app\api\user\avatar\route.ts =====

import { NextResponse } from 'next/server';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/lib/auth';
import { prisma } from '@/lib/prisma';
import { join } from 'path';
import { writeFile, mkdir, unlink } from 'fs/promises';
import { existsSync } from 'fs';

const MAX_FILE_SIZE = 5 * 1024 * 1024; // 5MB

export const config = {
  api: {
    bodyParser: false,
  },
};

export async function POST(request: Request) {
  try {
    console.log('Starting avatar upload process...');
    const session = await getServerSession(authOptions);
    console.log('Session:', session);
    
    if (!session?.user?.id) {
      console.log('No session found or no user ID');
      return NextResponse.json({ error: 'Non autorisé' }, { status: 401 });
    }

    // Créer le dossier uploads s'il n'existe pas
    const uploadDir = join(process.cwd(), 'public', 'uploads', 'avatars');
    console.log('Upload directory:', uploadDir);
    
    if (!existsSync(uploadDir)) {
      console.log('Creating upload directory...');
      await mkdir(uploadDir, { recursive: true });
    }

    const formData = await request.formData();
    const file = formData.get('avatar') as File;
    console.log('Received file:', { name: file?.name, type: file?.type, size: file?.size });
    
    if (!file) {
      console.log('No file provided');
      return NextResponse.json({ error: 'Aucun fichier fourni' }, { status: 400 });
    }

    // Vérifier le type de fichier
    if (!['image/jpeg', 'image/png', 'image/gif', 'image/webp'].includes(file.type)) {
      console.log('Invalid file type:', file.type);
      return NextResponse.json(
        { error: 'Le fichier doit être une image (JPG, PNG, GIF ou WEBP)' },
        { status: 400 }
      );
    }

    // Vérifier la taille du fichier (5MB)
    if (file.size > MAX_FILE_SIZE) {
      console.log('File too large:', file.size);
      return NextResponse.json(
        { error: 'Le fichier est trop volumineux (max 5MB)' },
        { status: 400 }
      );
    }

    try {
      // Générer un nom de fichier unique
      const extension = file.type.split('/')[1];
      const fileName = `${session.user.id}-${Date.now()}.${extension}`;
      const filePath = join(uploadDir, fileName);
      const avatarUrl = `/uploads/avatars/${fileName}`;
      
      console.log('Processing file upload:', {
        fileName,
        filePath,
        avatarUrl
      });

      // Convertir le File en Buffer et sauvegarder
      const bytes = await file.arrayBuffer();
      const buffer = Buffer.from(bytes);
      await writeFile(filePath, buffer);
      console.log('File written successfully');

      // Mettre à jour l'URL de l'avatar dans la base de données
      const updatedUser = await prisma.user.update({
        where: { id: session.user.id },
        data: { avatar: avatarUrl },
        select: {
          id: true,
          email: true,
          name: true,
          role: true,
          avatar: true,
          subscriptionType: true
        }
      });
      
      console.log('Database update result:', updatedUser);

      if (!updatedUser || !updatedUser.avatar) {
        throw new Error('Failed to update avatar in database');
      }

      // Supprimer l'ancien avatar si nécessaire
      const currentUser = await prisma.user.findUnique({
        where: { id: session.user.id },
        select: { avatar: true }
      });

      if (currentUser?.avatar && currentUser.avatar !== avatarUrl) {
        const oldAvatarPath = join(process.cwd(), 'public', currentUser.avatar);
        if (existsSync(oldAvatarPath)) {
          await unlink(oldAvatarPath);
          console.log('Old avatar deleted:', oldAvatarPath);
        }
      }

      return NextResponse.json({
        success: true,
        avatar: avatarUrl,
        user: updatedUser,
        message: 'Avatar mis à jour avec succès'
      });

    } catch (error) {
      console.error('Error processing avatar:', error);
      return NextResponse.json(
        { error: 'Erreur lors du traitement de l\'avatar' },
        { status: 500 }
      );
    }
  } catch (error) {
    console.error('Global error:', error);
    return NextResponse.json(
      { error: 'Erreur lors du traitement de la requête' },
      { status: 500 }
    );
  }
}

export async function OPTIONS(request: Request) {
  return new NextResponse(null, {
    status: 204,
    headers: {
      'Access-Control-Allow-Methods': 'POST',
      'Access-Control-Allow-Headers': 'Content-Type',
    },
  });
}


================================================================================

===== C:\wamp64\www\75Tribune\src\app\api\user\profile\route.ts =====

import { NextResponse } from 'next/server';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/lib/auth';
import { prisma } from '@/lib/prisma';
import bcrypt from 'bcrypt';

export async function PUT(request: Request) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return NextResponse.json(
        { error: 'Non autorisé' },
        { status: 401 }
      );
    }

    const { name, email, avatar, currentPassword, newPassword } = await request.json();

    // Vérifier si l'email est déjà utilisé par un autre utilisateur
    if (email !== session.user.email) {
      const existingUser = await prisma.user.findUnique({
        where: { email },
      });

      if (existingUser) {
        return NextResponse.json(
          { error: 'Cet email est déjà utilisé' },
          { status: 400 }
        );
      }
    }

    // Mettre à jour l'utilisateur
    const updateData: any = {
      name: name || null,
      email,
    };

    // Ne pas toucher à l'avatar lors de la mise à jour du profil
    if (avatar !== undefined) {
      updateData.avatar = avatar;
    }

    if (newPassword && currentPassword) {
      // Vérifier l'ancien mot de passe
      const user = await prisma.user.findUnique({
        where: { id: session.user.id },
        select: { password: true },
      });

      const isValidPassword = await bcrypt.compare(
        currentPassword,
        user?.password || ''
      );

      if (!isValidPassword) {
        return NextResponse.json(
          { error: 'Mot de passe actuel incorrect' },
          { status: 400 }
        );
      }

      // Hasher le nouveau mot de passe
      const hashedPassword = await bcrypt.hash(newPassword, 10);
      updateData.password = hashedPassword;
    }

    const updatedUser = await prisma.user.update({
      where: { id: session.user.id },
      data: updateData,
      select: {
        id: true,
        name: true,
        email: true,
        role: true,
        subscriptionType: true
      },
    });

    return NextResponse.json({
      ...updatedUser,
      avatar: updateData.avatar
    });
  } catch (error) {
    console.error('Erreur lors de la mise à jour du profil:', error);
    return NextResponse.json(
      { error: 'Erreur lors de la mise à jour du profil' },
      { status: 500 }
    );
  }
}


================================================================================

===== C:\wamp64\www\75Tribune\src\app\api\users\route.ts =====

import { NextRequest, NextResponse } from 'next/server';
import { UserService } from '@/services/user.service';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/lib/auth';

export async function GET(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions);
    
    if (!session?.user) {
      return NextResponse.json({ error: 'Non authentifié' }, { status: 401 });
    }

    // Vérifier si l'utilisateur est admin
    const user = await UserService.getById(session.user.id);
    if (!user || user.role !== 'ADMIN') {
      return NextResponse.json({ error: 'Non autorisé' }, { status: 403 });
    }

    const users = await UserService.list();
    return NextResponse.json(users);
  } catch (error) {
    console.error('Erreur liste utilisateurs:', error);
    return NextResponse.json(
      { error: 'Erreur lors de la récupération des utilisateurs' },
      { status: 500 }
    );
  }
}

export async function POST(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions);
    
    if (!session?.user) {
      return NextResponse.json({ error: 'Non authentifié' }, { status: 401 });
    }

    // Vérifier si l'utilisateur est admin
    const user = await UserService.getById(session.user.id);
    if (!user || user.role !== 'ADMIN') {
      return NextResponse.json({ error: 'Non autorisé' }, { status: 403 });
    }

    const data = await request.json();

    // Validation des données
    if (!data.email?.trim()) {
      return NextResponse.json({ error: 'Email requis' }, { status: 400 });
    }

    if (!data.password?.trim()) {
      return NextResponse.json({ error: 'Mot de passe requis' }, { status: 400 });
    }

    const newUser = await UserService.create({
      email: data.email.trim(),
      password: data.password.trim(),
      name: data.name?.trim(),
      role: data.role,
      subscriptionType: data.subscriptionType,
    });

    return NextResponse.json({
      success: true,
      user: newUser,
    });
  } catch (error: any) {
    console.error('Erreur création utilisateur:', error);
    return NextResponse.json(
      { error: error.message || 'Erreur lors de la création de l\'utilisateur' },
      { status: 500 }
    );
  }
}


================================================================================

===== C:\wamp64\www\75Tribune\src\app\api\users\[id]\route.ts =====

import { NextResponse } from 'next/server';
import { UserService } from '@/services/user.service';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/lib/auth';
import { Role, SubscriptionType } from '@prisma/client';

export async function GET(
  request: Request,
  { params }: { params: { id: string } }
) {
  try {
    const session = await getServerSession(authOptions);
    
    if (!session?.user) {
      return NextResponse.json({ error: 'Non authentifié' }, { status: 401 });
    }

    // Vérifier si l'utilisateur est admin
    const user = await UserService.getById(session.user.id);
    if (!user || user.role !== 'ADMIN') {
      return NextResponse.json({ error: 'Non autorisé' }, { status: 403 });
    }

    const targetUser = await UserService.getById(params.id);
    if (!targetUser) {
      return NextResponse.json({ error: 'Utilisateur non trouvé' }, { status: 404 });
    }

    return NextResponse.json(targetUser);
  } catch (error) {
    console.error('Erreur récupération utilisateur:', error);
    return NextResponse.json(
      { error: 'Erreur lors de la récupération de l\'utilisateur' },
      { status: 500 }
    );
  }
}

export async function PUT(
  request: Request,
  { params }: { params: { id: string } }
) {
  try {
    const session = await getServerSession(authOptions);
    
    if (!session?.user) {
      return NextResponse.json({ error: 'Non authentifié' }, { status: 401 });
    }

    // Vérifier si l'utilisateur est admin
    const user = await UserService.getById(session.user.id);
    if (!user || user.role !== 'ADMIN') {
      return NextResponse.json({ error: 'Non autorisé' }, { status: 403 });
    }

    const data = await request.json();
    
    // Validation de base
    if (data.email && !data.email.trim()) {
      return NextResponse.json({ error: 'Email invalide' }, { status: 400 });
    }

    // Validation du rôle
    if (data.role && !Object.values(Role).includes(data.role)) {
      return NextResponse.json({ error: 'Rôle invalide' }, { status: 400 });
    }

    // Validation du type d'abonnement
    if (data.subscriptionType && !Object.values(SubscriptionType).includes(data.subscriptionType)) {
      return NextResponse.json({ error: 'Type d\'abonnement invalide' }, { status: 400 });
    }

    const updatedUser = await UserService.update({
      id: params.id,
      email: data.email?.trim(),
      name: data.name?.trim(),
      role: data.role,
      subscriptionType: data.subscriptionType,
      password: data.password?.trim(),
    });

    return NextResponse.json({
      success: true,
      user: updatedUser,
    });
  } catch (error: any) {
    console.error('Erreur mise à jour utilisateur:', error);
    return NextResponse.json(
      { error: error.message || 'Erreur lors de la mise à jour de l\'utilisateur' },
      { status: 500 }
    );
  }
}

export async function DELETE(
  request: Request,
  { params }: { params: { id: string } }
) {
  try {
    const session = await getServerSession(authOptions);
    
    if (!session?.user) {
      return NextResponse.json({ error: 'Non authentifié' }, { status: 401 });
    }

    // Vérifier si l'utilisateur est admin
    const user = await UserService.getById(session.user.id);
    if (!user || user.role !== 'ADMIN') {
      return NextResponse.json({ error: 'Non autorisé' }, { status: 403 });
    }

    // Empêcher la suppression de son propre compte
    if (params.id === session.user.id) {
      return NextResponse.json(
        { error: 'Vous ne pouvez pas supprimer votre propre compte' },
        { status: 400 }
      );
    }

    await UserService.delete(params.id);

    return NextResponse.json({
      success: true,
      message: 'Utilisateur supprimé avec succès',
    });
  } catch (error) {
    console.error('Erreur suppression utilisateur:', error);
    return NextResponse.json(
      { error: 'Erreur lors de la suppression de l\'utilisateur' },
      { status: 500 }
    );
  }
}


================================================================================

===== C:\wamp64\www\75Tribune\src\app\articles\page.tsx =====

'use client';

import { useState } from 'react';
import { Search } from 'lucide-react';
import { useArticles } from '@/hooks/useArticles';
import { format } from 'date-fns';
import { fr } from 'date-fns/locale';
import Link from 'next/link';
import Image from 'next/image';
import { normalizeImagePath } from '@/lib/image';

export default function ArticlesPage() {
  const [searchQuery, setSearchQuery] = useState('');
  const { articles, loading, error } = useArticles({ status: 'PUBLISHED' });

  // Filtrer la liste selon la recherche
  const filteredArticles = articles.filter(article =>
    article.title.toLowerCase().includes(searchQuery.toLowerCase()) ||
    article.excerpt.toLowerCase().includes(searchQuery.toLowerCase())
  );

  if (loading) {
    // Indicateur de chargement (squelette)
    return (
      <div className="container p-4 w-full">
        <div className="animate-pulse space-y-4">
          <div className="h-4 bg-nyt-gray-200 rounded w-1/4"></div>
          <div className="h-4 bg-nyt-gray-200 rounded w-1/2"></div>
          <div className="h-4 bg-nyt-gray-200 rounded w-3/4"></div>
        </div>
      </div>
    );
  }

  if (error) {
    return (
      <div className="container p-4 w-full text-red-500">
        Erreur: {error}
      </div>
    );
  }

  return (
    <div className="container p-4 w-full pt-20">
      {/* En-tête avec titre de page et champ de recherche */}
      <div className="px-4 sm:px-0 space-y-6">
        <div className="flex justify-between items-center">
          <h1 className="text-3xl font-bold text-nyt-black dark:text-nyt-white">Articles</h1>
          <div className="w-72">
            <div className="relative">
              <Search className="absolute left-3 top-1/2 transform -translate-y-1/2 text-nyt-gray-500 dark:text-nyt-gray-300" />
              <input
                type="text"
                placeholder="Rechercher un article..."
                value={searchQuery}
                onChange={(e) => setSearchQuery(e.target.value)}
                className="w-full pl-10 pr-4 py-2 border rounded-lg dark:bg-nyt-black dark:border-nyt-gray-500 dark:text-nyt-white"
              />
            </div>
          </div>
        </div>

        {/* Grille des articles filtrés */}
        {filteredArticles.length > 0 ? (
          <div className="grid gap-6 md:grid-cols-2 lg:grid-cols-3">
            {filteredArticles.map((article) => (
              <Link 
                href={`/articles/${article.slug}`}
                key={article.id}
                className="group relative bg-nyt-white dark:bg-nyt-black rounded-lg shadow-sm hover:shadow-md transition-shadow overflow-hidden"
              >
                {article.featuredImage && (
                  <div className="relative aspect-video">
                    <Image
                      src={normalizeImagePath(article.featuredImage)}
                      alt={article.title}
                      fill
                      sizes="(max-width: 768px) 100vw, (max-width: 1200px) 50vw, 33vw"
                      className="object-cover"
                    />
                    {/* Indicateur "Premium" pour les articles PRO */}
                    {article.accessLevel === 'PRO' && (
                      <div className="absolute top-2 right-2">
                        <span className="inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium bg-gradient-to-r from-nyt-blue to-nyt-blue/80 text-nyt-white">
                          Premium
                        </span>
                      </div>
                    )}
                  </div>
                )}
                <div className="p-4">
                  <h2 className="text-xl font-headline mb-2 text-nyt-black dark:text-nyt-white group-hover:text-nyt-blue">
                    {article.title}
                  </h2>
                  <p className="text-nyt-gray-500 dark:text-nyt-gray-200 text-sm mb-4 font-body">
                    {article.excerpt}
                  </p>
                  <div className="flex items-center text-sm text-nyt-gray-500 dark:text-nyt-gray-300 space-x-4">
                    <time dateTime={article.publishedAt || article.updatedAt}>
                      {format(new Date(article.publishedAt || article.updatedAt), 'dd MMMM yyyy', { locale: fr })}
                    </time>
                    <span>•</span>
                    <span>5 min de lecture</span>
                  </div>
                </div>
              </Link>
            ))}
          </div>
        ) : (
          <div className="text-center py-12">
            <p className="text-nyt-gray-500 dark:text-nyt-gray-300">
              Aucun article ne correspond à votre recherche.
            </p>
          </div>
        )}
      </div>
    </div>
  );
}


================================================================================

===== C:\wamp64\www\75Tribune\src\app\articles\[slug]\page.tsx =====

'use client';

import React, { useEffect, useState } from 'react';
import Image from 'next/image';
import Link from 'next/link';
import { ArticleService } from '@/services/article.service';
import { notFound, redirect } from 'next/navigation';
import { format } from 'date-fns';
import { fr } from 'date-fns/locale';
import ArticleContent from '@/components/ArticleContent';
import CommentSection from '@/components/comments/CommentSection';
import { AccessLevel, Tag, SubscriptionType } from '@prisma/client';
import { normalizeImagePath } from '@/lib/image';
import { useParams, useRouter } from 'next/navigation';
import { useSession } from 'next-auth/react';
import { Button } from '@/components/ui/button';
import { Shield, Lock } from 'lucide-react';
import PremiumArticleView from '@/components/articles/PremiumArticleView';
import Breadcrumb from '@/components/Breadcrumb';

interface ArticlePageProps {
  params: {
    slug: string;
  };
}

export default function ArticlePage({ params }: ArticlePageProps) {
  const { data: session } = useSession();
  const router = useRouter();
  const [article, setArticle] = useState<any>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  const canAccessPremiumContent = session?.user?.subscriptionType === SubscriptionType.PREMIUM || 
                                session?.user?.role === 'ADMIN';

  useEffect(() => {
    const fetchArticle = async () => {
      try {
        const response = await fetch(`/api/articles/by-slug/${params.slug}`);
        if (!response.ok) {
          throw new Error('Article non trouvé');
        }
        const data = await response.json();
        setArticle(data);
      } catch (error) {
        console.error('Erreur lors de la récupération de l\'article:', error);
        setError('Article non trouvé');
      } finally {
        setLoading(false);
      }
    };

    fetchArticle();
  }, [params.slug]);

  useEffect(() => {
    if (article?.id) {
      const recordView = async () => {
        try {
          await fetch('/api/articles/views', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
            },
            body: JSON.stringify({ articleId: article.id }),
          });
        } catch (error) {
          console.error('Erreur lors de l\'enregistrement de la vue:', error);
        }
      };

      recordView();
    }
  }, [article?.id]);

  if (loading) {
    return (
      <div className="flex items-center justify-center min-h-screen bg-nyt-white dark:bg-nyt-black">
        <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-nyt-black dark:border-nyt-white"></div>
      </div>
    );
  }

  if (error) {
    return (
      <div className="container mx-auto px-4 py-8 bg-nyt-white dark:bg-nyt-black">
        <div className="max-w-2xl mx-auto text-center">
          <div className="mb-4">
            <Shield className="mx-auto h-16 w-16 text-red-500" />
          </div>
          <h1 className="text-2xl font-headline mb-4 text-nyt-black dark:text-nyt-white">{error}</h1>
        </div>
      </div>
    );
  }

  if (!article) {
    return notFound();
  }

  if (article.accessLevel === AccessLevel.PRO && !canAccessPremiumContent) {
    return <PremiumArticleView article={article} session={session} />;
  }

  return (
    <div className="container mx-auto px-4 py-8 bg-nyt-white dark:bg-nyt-black">
      {article.categories && article.categories.length > 0 && (
        <Breadcrumb
          items={[
            { label: 'Catégories', href: '/categories' },
            ...article.categories.map((category: any) => ({
              label: category.name,
              href: `/categories/${category.slug}`
            })),
            { label: article.title }
          ]}
        />
      )}

      <article className="max-w-4xl mx-auto">
        {article.featuredImage && (
          <div className="relative aspect-video mb-8 rounded-lg overflow-hidden">
            <Image
              src={normalizeImagePath(article.featuredImage)}
              alt={article.title}
              fill
              className="object-cover"
              priority
            />
            {article.accessLevel === AccessLevel.PRO && (
              <div className="absolute top-4 right-4">
                <span className="inline-flex items-center px-3 py-1 rounded-full text-sm font-medium bg-gradient-to-r from-nyt-blue to-nyt-blue/80 text-nyt-white">
                  Premium
                </span>
              </div>
            )}
          </div>
        )}

        <div className="mb-8">
          <h1 className="text-4xl font-headline mb-4 text-nyt-black dark:text-nyt-white">{article.title}</h1>
          <div className="flex items-center text-sm text-nyt-gray-500 dark:text-nyt-gray-200 mb-4 font-body">
            <time dateTime={article.publishedAt || article.updatedAt}>
              {format(new Date(article.publishedAt || article.updatedAt), 'dd MMMM yyyy', { locale: fr })}
            </time>
            <span className="mx-2">•</span>
            <span>{article.author?.name}</span>
          </div>
          <p className="text-xl text-nyt-gray-600 dark:text-nyt-gray-300 font-body">{article.excerpt}</p>
        </div>

        <div className="prose-nyt dark:prose-invert max-w-none font-body text-nyt-black dark:text-nyt-white">
          <ArticleContent content={article.content} />
        </div>

        {article.tags && article.tags.length > 0 && (
          <div className="mt-8 flex flex-wrap gap-2">
            {article.tags.map((tag: Tag) => (
              <span
                key={tag.id}
                className="inline-flex items-center px-3 py-1 rounded-full text-sm font-medium bg-nyt-gray-100 dark:bg-nyt-gray-800 text-nyt-black dark:text-nyt-white font-body"
              >
                {tag.name}
              </span>
            ))}
          </div>
        )}

        {article.categories && article.categories.length > 0 && (
          <div className="mt-4 flex flex-wrap gap-2">
            {article.categories.map((category: any) => (
              <span
                key={category.id}
                className="inline-flex items-center px-3 py-1 rounded-full text-sm font-medium bg-nyt-blue text-nyt-white font-body"
              >
                {category.name}
              </span>
            ))}
          </div>
        )}

        <CommentSection articleId={article.id} />
      </article>
    </div>
  );
}

================================================================================

===== C:\wamp64\www\75Tribune\src\app\categories\[slug]\page.tsx =====

'use client';

import React, { useEffect, useState } from 'react';
import { Search } from 'lucide-react';
import Breadcrumb from '@/components/Breadcrumb';
import { Category } from '@prisma/client';
import ArticleCard from '@/components/articles/ArticleCard';

interface CategoryPageProps {
  params: {
    slug: string;
  };
}

export default function CategoryPage({ params }: CategoryPageProps) {
  const [category, setCategory] = useState<Category | null>(null);
  const [articles, setArticles] = useState<any[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [searchQuery, setSearchQuery] = useState('');

  useEffect(() => {
    const fetchCategoryAndArticles = async () => {
      try {
        // Fetch category
        const categoryResponse = await fetch(`/api/categories/by-slug/${params.slug}`);
        if (!categoryResponse.ok) {
          throw new Error('Catégorie non trouvée');
        }
        const categoryData = await categoryResponse.json();
        setCategory(categoryData);

        // Fetch articles for this category
        const articlesResponse = await fetch(`/api/articles/by-category/${categoryData.id}`);
        if (!articlesResponse.ok) {
          throw new Error('Erreur lors de la récupération des articles');
        }
        const articlesData = await articlesResponse.json();
        setArticles(articlesData);
      } catch (error) {
        console.error('Erreur:', error);
        setError(error instanceof Error ? error.message : 'Une erreur est survenue');
      } finally {
        setLoading(false);
      }
    };

    fetchCategoryAndArticles();
  }, [params.slug]);

  // Filtrer les articles en fonction de la recherche
  const filteredArticles = articles.filter(article =>
    article.title.toLowerCase().includes(searchQuery.toLowerCase()) ||
    article.excerpt.toLowerCase().includes(searchQuery.toLowerCase())
  );

  if (loading) {
    return (
      <div className="container p-4 w-full">
        <div className="animate-pulse space-y-4">
          <div className="h-4 bg-gray-200 rounded w-1/4"></div>
          <div className="h-4 bg-gray-200 rounded w-1/2"></div>
          <div className="h-4 bg-gray-200 rounded w-3/4"></div>
        </div>
      </div>
    );
  }

  if (error) {
    return (
      <div className="container p-4 w-full text-red-500">
        Erreur: {error}
      </div>
    );
  }

  return (
    <div className="container p-4 w-full pt-20">
      <div className="px-4 sm:px-0 space-y-6">
        {category && (
          <Breadcrumb
            items={[
              { label: 'Catégories', href: '/categories' },
              { label: category.name }
            ]}
          />
        )}

        <div className="flex justify-between items-center flex-wrap gap-4">
          <div>
            <h1 className="text-3xl font-bold text-gray-900 dark:text-white mb-2">
              {category?.name}
            </h1>
            {category?.description && (
              <p className="text-gray-600 dark:text-gray-300 text-lg">
                {category.description}
              </p>
            )}
          </div>
          
          <div className="w-full md:w-72">
            <div className="relative">
              <Search className="absolute left-3 top-1/2 transform -translate-y-1/2 text-gray-400 dark:text-gray-500" />
              <input
                type="text"
                placeholder="Rechercher un article..."
                value={searchQuery}
                onChange={(e) => setSearchQuery(e.target.value)}
                className="w-full pl-10 pr-4 py-2 border rounded-lg dark:bg-gray-800 dark:border-gray-700 dark:text-white"
              />
            </div>
          </div>
        </div>

        {filteredArticles.length === 0 ? (
          <div className="text-center py-12">
            <p className="text-gray-500">Aucun article trouvé dans cette catégorie.</p>
          </div>
        ) : (
          <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
            {filteredArticles.map((article) => (
              <ArticleCard key={article.id} article={article} />
            ))}
          </div>
        )}
      </div>
    </div>
  );
}


================================================================================

===== C:\wamp64\www\75Tribune\src\app\login\page.tsx =====

import { Metadata } from 'next';
import { ClientLoginForm } from '@/components/auth/ClientLoginForm';

export const metadata: Metadata = {
  title: 'Connexion | 75Tribune',
  description: 'Connectez-vous à votre compte 75Tribune',
};

export default function LoginPage() {
  return (
    <div className="container relative h-[calc(100vh-4rem)] flex-col items-center justify-center grid lg:max-w-none lg:grid-cols-1 lg:px-0">
      <div className="mx-auto flex w-full flex-col justify-center space-y-6 sm:w-[350px]">
        <ClientLoginForm />
      </div>
    </div>
  );
}

================================================================================

===== C:\wamp64\www\75Tribune\src\app\pricing\page.tsx =====

'use client';

import { useRouter } from 'next/navigation';
import { useState } from 'react';
import { motion, AnimatePresence } from "framer-motion";
import { Button } from "@/components/ui/button";
import { Check, Clock, Video, Download, Code, Eye } from "lucide-react";

export default function PricingPage() {
  const router = useRouter();
  const [isYearly, setIsYearly] = useState(false);

  const monthlyPrice = 5;
  const yearlyPrice = monthlyPrice * 10; // 2 mois gratuits

  const features = [
    {
      icon: Clock,
      text: "Visionner les tutoriels en avance"
    },
    {
      icon: Video,
      text: "Voir les vidéos premium"
    },
    {
      icon: Download,
      text: "Télécharger les vidéos"
    },
    {
      icon: Code,
      text: "Télécharger les sources"
    }
  ];

  return (
    <div className="container mx-auto px-4 py-24">
      <motion.div
        initial={{ opacity: 0, y: 20 }}
        animate={{ opacity: 1, y: 0 }}
        transition={{ duration: 0.5 }}
        className="text-center mb-16"
      >
        <h1 className="text-4xl font-bold mb-4">
          Abonnement Premium
        </h1>
        <p className="text-xl text-muted-foreground max-w-2xl mx-auto">
          Soutenez le projet et accédez à du contenu exclusif
        </p>
      </motion.div>

      <div className="max-w-6xl mx-auto">
        <div className="grid grid-cols-1 md:grid-cols-2 gap-12">
          {/* Colonne de gauche - Prix et fonctionnalités */}
          <motion.div
            initial={{ opacity: 0, x: -20 }}
            animate={{ opacity: 1, x: 0 }}
            transition={{ duration: 0.6 }}
            className="rounded-2xl border border-primary-500 bg-primary-500/5 p-8"
          >
            <div className="space-y-6">
              {/* Toggle Mensuel/Annuel */}
              <div className="flex justify-center gap-4 mb-8">
                <Button
                  variant={!isYearly ? "default" : "outline"}
                  onClick={() => setIsYearly(false)}
                  className="relative"
                >
                  Mensuel
                  {!isYearly && (
                    <motion.div
                      layoutId="pricingSelector"
                      className="absolute inset-0 bg-primary rounded-md -z-10"
                      transition={{ type: "spring", bounce: 0.2, duration: 0.6 }}
                    />
                  )}
                </Button>
                <Button
                  variant={isYearly ? "default" : "outline"}
                  onClick={() => setIsYearly(true)}
                  className="relative"
                >
                  Annuel
                  {isYearly && (
                    <motion.div
                      layoutId="pricingSelector"
                      className="absolute inset-0 bg-primary rounded-md -z-10"
                      transition={{ type: "spring", bounce: 0.2, duration: 0.6 }}
                    />
                  )}
                </Button>
              </div>

              {/* Prix avec animation */}
              <div className="text-center">
                <AnimatePresence mode="wait">
                  <motion.div
                    key={isYearly ? 'yearly' : 'monthly'}
                    initial={{ opacity: 0, y: 20 }}
                    animate={{ opacity: 1, y: 0 }}
                    exit={{ opacity: 0, y: -20 }}
                    className="flex items-center justify-center gap-2"
                  >
                    <div className="text-4xl font-bold">
                      {isYearly ? `${yearlyPrice}€` : `${monthlyPrice}€`} TTC
                    </div>
                    <div className="text-sm text-muted-foreground">
                      /{isYearly ? 'an' : 'mois'}
                    </div>
                  </motion.div>
                </AnimatePresence>
                {isYearly && (
                  <motion.div
                    initial={{ opacity: 0, scale: 0.8 }}
                    animate={{ opacity: 1, scale: 1 }}
                    className="text-sm text-primary-500 font-medium mt-2"
                  >
                    2 mois gratuits !
                  </motion.div>
                )}
              </div>

              <motion.ul 
                className="space-y-4 mt-8"
                variants={{
                  hidden: {},
                  show: {
                    transition: {
                      staggerChildren: 0.1,
                    },
                  },
                }}
                initial="hidden"
                animate="show"
              >
                {features.map((feature, idx) => (
                  <motion.li
                    key={idx}
                    variants={{
                      hidden: { opacity: 0, x: -20 },
                      show: { opacity: 1, x: 0 }
                    }}
                    className="flex items-center gap-3"
                  >
                    <div className="flex h-10 w-10 shrink-0 items-center justify-center rounded-full bg-primary-500/10">
                      <feature.icon className="h-5 w-5 text-primary-500" />
                    </div>
                    <span className="text-base">{feature.text}</span>
                  </motion.li>
                ))}
              </motion.ul>

              <Button
                onClick={() => router.push('/login')}
                className="w-full bg-primary-500 text-white hover:bg-primary-600"
                size="lg"
              >
                Commencer maintenant
              </Button>
            </div>
          </motion.div>

          {/* Colonne de droite - Pourquoi cette offre */}
          <motion.div
            initial={{ opacity: 0, x: 20 }}
            animate={{ opacity: 1, x: 0 }}
            transition={{ duration: 0.6 }}
            className="space-y-6"
          >
            <h2 className="text-2xl font-semibold mb-6">
              Pourquoi cette offre ?
            </h2>
            
            <div className="prose dark:prose-invert">
              <p className="text-base leading-relaxed">
                Mon but à travers 75Tribune.fr est de partager mes connaissances avec le plus grand nombre, 
                c&apos;est pourquoi j&apos;essaie de rendre un maximum de contenu gratuit et public.
              </p>

              <p className="text-base leading-relaxed mt-4">
                Malgré tout, la préparation, l&apos;enregistrement et le montage des tutoriels prend un temps 
                considérable (10 à 20 heures par semaine). Du coup proposer des options payantes, comme 
                le téléchargement des sources, me permet d&apos;amortir une partie du temps passé et de 
                continuer à faire vivre le site.
              </p>
            </div>

            <div className="mt-8 p-4 bg-muted/50 rounded-lg">
              <p className="text-sm text-muted-foreground">
                En vous abonnant, vous soutenez directement la création de contenu de qualité 
                et permettez au projet de continuer à se développer.
              </p>
            </div>
          </motion.div>
        </div>
      </div>
    </div>
  );
}


================================================================================

===== C:\wamp64\www\75Tribune\src\app\profile\page.tsx =====

'use client';

import { useSession } from 'next-auth/react';
import { useRouter } from 'next/navigation';
import { useEffect, useState } from 'react';
import { Loader2 } from 'lucide-react';
import { toast } from 'react-hot-toast';
import { Avatar, AvatarImage, AvatarFallback } from '@/components/ui/avatar';
import { prisma } from '@/lib/prisma';

export default function ProfilePage() {
  const { data: session, status, update } = useSession();
  const router = useRouter();
  const [isEditing, setIsEditing] = useState(false);
  const [formData, setFormData] = useState({
    name: '',
    email: '',
    currentPassword: '',
    newPassword: '',
    confirmPassword: '',
  });
  const [avatarFile, setAvatarFile] = useState<File | null>(null);
  const [avatarPreview, setAvatarPreview] = useState<string>('');
  const [loading, setLoading] = useState(false);
  const [isUploading, setIsUploading] = useState(false);

  useEffect(() => {
    if (status === 'unauthenticated') {
      router.push('/login');
    }
    if (session?.user) {
      // Si l'utilisateur est ADMIN, rediriger vers le dashboard
      if (session.user.role === 'ADMIN') {
        router.push('/dashboard');
        return;
      }
      
      setFormData(prev => ({
        ...prev,
        name: session.user.name || '',
        email: session.user.email || '',
      }));
      
      // Mise à jour de l'avatar preview avec l'avatar de la session
      if (session.user.avatar) {
        console.log('Setting avatar from session:', session.user.avatar);
        setAvatarPreview(session.user.avatar);
      }
    }
  }, [status, router, session]);

  const handleChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const { name, value } = e.target;
    setFormData(prev => ({ ...prev, [name]: value }));
  };

  const handleAvatarChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const file = e.target.files?.[0];
    if (file) {
      console.log('Avatar file selected:', file);
      setAvatarFile(file);
      
      const reader = new FileReader();
      reader.onloadend = () => {
        const result = reader.result as string;
        console.log('Avatar preview generated:', result);
        setAvatarPreview(result);
      };
      reader.readAsDataURL(file);
    }
  };

  const handleAvatarUpload = async (file: File) => {
    try {
      setIsUploading(true);
      console.log('Starting avatar upload for file:', file.name);

      const formData = new FormData();
      formData.append('avatar', file);

      const response = await fetch('/api/user/avatar', {
        method: 'POST',
        body: formData,
      });

      const data = await response.json();
      console.log('Avatar upload response:', data);

      if (!response.ok) {
        throw new Error(data.error || 'Erreur lors du téléchargement de l\'avatar');
      }

      if (!data.success || !data.user || !data.avatar) {
        throw new Error('Réponse invalide du serveur');
      }

      // Mettre à jour l'aperçu immédiatement
      setAvatarPreview(data.avatar);

      // Mettre à jour la session avec les données complètes de l'utilisateur
      await update({
        ...session,
        user: {
          ...session?.user,
          ...data.user
        }
      });

      toast.success('Avatar mis à jour avec succès');
    } catch (error) {
      console.error('Erreur lors de l\'upload:', error);
      toast.error(error instanceof Error ? error.message : 'Erreur lors de la mise à jour de l\'avatar');
    } finally {
      setIsUploading(false);
    }
  };

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    setLoading(true);

    try {
      // Upload avatar if changed
      if (avatarFile) {
        await handleAvatarUpload(avatarFile);
      }

      // Update other profile data if editing
      if (isEditing) {
        const profileData = {
          name: formData.name,
          email: formData.email,
          currentPassword: formData.currentPassword,
          newPassword: formData.newPassword,
        };

        const profileResponse = await fetch('/api/user/profile', {
          method: 'PUT',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(profileData),
        });

        if (!profileResponse.ok) {
          const errorData = await profileResponse.json();
          throw new Error(errorData.error || 'Erreur lors de la mise à jour du profil');
        }

        // Forcer la mise à jour de la session
        await update({
          ...session,
          user: {
            ...session?.user,
            name: formData.name,
            email: formData.email
          }
        });

        toast.success('Profil mis à jour avec succès');
        setIsEditing(false);
      }
    } catch (error: any) {
      console.error('Error updating profile:', error);
      toast.error(error.message);
    } finally {
      setLoading(false);
    }
  };

  if (status === 'loading') {
    return (
      <div className="flex min-h-screen items-center justify-center pt-16">
        <Loader2 className="h-8 w-8 animate-spin text-blue-600" />
      </div>
    );
  }

  if (!session?.user) {
    return null;
  }

  return (
    <div className="container mx-auto px-4 py-8 pt-24">
      <div className="max-w-3xl mx-auto bg-white dark:bg-gray-800 rounded-lg shadow-md p-8">
        <div className="space-y-6">
          <div className="flex items-center space-x-4 mb-6">
            <div className="h-24 w-24">
              <Avatar className="h-full w-full">
                <AvatarImage 
                  src={avatarPreview || session.user.avatar || '/uploads/avatars/default-avatar.png'} 
                  alt={`Avatar de ${session.user.name || 'l\'utilisateur'}`}
                />
                <AvatarFallback>
                  {session?.user?.name?.charAt(0).toUpperCase() || 'U'}
                </AvatarFallback>
              </Avatar>
            </div>
            {isEditing && (
              <div>
                <input
                  type="file"
                  accept="image/jpeg,image/png,image/gif,image/webp"
                  onChange={handleAvatarChange}
                  className="hidden"
                  id="avatar-upload"
                />
                <label
                  htmlFor="avatar-upload"
                  className="cursor-pointer inline-flex items-center px-4 py-2 border border-transparent text-sm font-medium rounded-md shadow-sm text-white bg-blue-600 hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500"
                >
                  Changer l'avatar
                </label>
              </div>
            )}
          </div>

          <form onSubmit={handleSubmit} className="space-y-6">
            <div className="grid grid-cols-1 gap-6">
              <div>
                <label htmlFor="name" className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
                  Nom
                </label>
                <input
                  type="text"
                  name="name"
                  id="name"
                  value={formData.name}
                  onChange={handleChange}
                  className="w-full px-4 py-2 text-sm border rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500 dark:bg-gray-700 dark:border-gray-600 dark:text-white"
                  disabled={!isEditing}
                  autoComplete="name"
                />
              </div>

              <div>
                <label htmlFor="email" className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
                  Email
                </label>
                <input
                  type="email"
                  name="email"
                  id="email"
                  value={formData.email}
                  onChange={handleChange}
                  className="w-full px-4 py-2 text-sm border rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500 dark:bg-gray-700 dark:border-gray-600 dark:text-white"
                  disabled={!isEditing}
                  autoComplete="email"
                />
              </div>

              {isEditing && (
                <>
                  <div>
                    <label htmlFor="currentPassword" className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
                      Mot de passe actuel
                    </label>
                    <input
                      type="password"
                      name="currentPassword"
                      id="currentPassword"
                      value={formData.currentPassword}
                      onChange={handleChange}
                      className="w-full px-4 py-2 text-sm border rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500 dark:bg-gray-700 dark:border-gray-600 dark:text-white"
                      autoComplete="current-password"
                    />
                  </div>

                  <div>
                    <label htmlFor="newPassword" className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
                      Nouveau mot de passe
                    </label>
                    <input
                      type="password"
                      name="newPassword"
                      id="newPassword"
                      value={formData.newPassword}
                      onChange={handleChange}
                      className="w-full px-4 py-2 text-sm border rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500 dark:bg-gray-700 dark:border-gray-600 dark:text-white"
                      autoComplete="new-password"
                    />
                  </div>

                  <div>
                    <label htmlFor="confirmPassword" className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
                      Confirmer le nouveau mot de passe
                    </label>
                    <input
                      type="password"
                      name="confirmPassword"
                      id="confirmPassword"
                      value={formData.confirmPassword}
                      onChange={handleChange}
                      className="w-full px-4 py-2 text-sm border rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500 dark:bg-gray-700 dark:border-gray-600 dark:text-white"
                      autoComplete="new-password"
                    />
                  </div>
                </>
              )}
            </div>

            <div className="flex justify-end space-x-3 pt-4">
              {!isEditing ? (
                <button
                  type="button"
                  onClick={() => setIsEditing(true)}
                  className="px-4 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2"
                >
                  Modifier
                </button>
              ) : (
                <>
                  <button
                    type="button"
                    onClick={() => {
                      setIsEditing(false);
                      setFormData(prev => ({
                        ...prev,
                        currentPassword: '',
                        newPassword: '',
                        confirmPassword: '',
                      }));
                    }}
                    className="px-4 py-2 bg-gray-200 text-gray-700 rounded-md hover:bg-gray-300 focus:outline-none focus:ring-2 focus:ring-gray-500 focus:ring-offset-2"
                    disabled={loading}
                  >
                    Annuler
                  </button>
                  <button
                    type="submit"
                    className="px-4 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2"
                    disabled={loading}
                  >
                    {loading ? (
                      <Loader2 className="h-5 w-5 animate-spin" />
                    ) : (
                      'Enregistrer'
                    )}
                  </button>
                </>
              )}
            </div>
          </form>
        </div>
      </div>
    </div>
  );
}


================================================================================

===== C:\wamp64\www\75Tribune\src\app\register\page.tsx =====

import { Metadata } from 'next';
import { ClientRegisterForm } from '@/components/auth/ClientRegisterForm';

export const metadata: Metadata = {
  title: 'Inscription | 75Tribune',
  description: 'Créez votre compte 75Tribune',
};

export default function RegisterPage() {
  return (
    <div className="container relative h-[calc(100vh-4rem)] flex-col items-center justify-center grid lg:max-w-none lg:grid-cols-1 lg:px-0">
      <div className="mx-auto flex w-full flex-col justify-center space-y-6 sm:w-[350px]">
        <ClientRegisterForm />
      </div>
    </div>
  );
}

================================================================================

===== C:\wamp64\www\75Tribune\src\app\subscription\page.tsx =====

'use client';

export default function SubscriptionPage() {
  return (
    <div className="container p-4 w-full">
      <div className="px-4 py-6 sm:px-0">
        <h1 className="text-3xl font-bold mb-6">Abonnement</h1>
        <div className="grid gap-6 md:grid-cols-2 lg:grid-cols-3">
          <div className="card">
            <h2 className="text-xl font-semibold mb-4">Plan Gratuit</h2>
            <ul className="space-y-2 mb-4">
              <li className="flex items-center">
                <svg className="h-5 w-5 text-green-500" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M5 13l4 4L19 7" />
                </svg>
                <span className="ml-2">Accès aux articles publics</span>
              </li>
            </ul>
            <button className="btn-primary w-full">Actuel</button>
          </div>

          <div className="card">
            <h2 className="text-xl font-semibold mb-4">Premium</h2>
            <ul className="space-y-2 mb-4">
              <li className="flex items-center">
                <svg className="h-5 w-5 text-green-500" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M5 13l4 4L19 7" />
                </svg>
                <span className="ml-2">Accès à tout le contenu</span>
              </li>
            </ul>
            <button className="btn-secondary w-full">Souscrire</button>
          </div>
        </div>
      </div>
    </div>
  );
}


================================================================================

===== C:\wamp64\www\75Tribune\src\app\terms\page.tsx =====

import { Metadata } from 'next';

export const metadata: Metadata = {
  title: "Conditions d'utilisation | 75Tribune",
  description: "Conditions d'utilisation de la plateforme 75Tribune",
};

export default function TermsPage() {
  return (
    <div className="container py-8 md:py-12">
      <div className="mx-auto max-w-3xl space-y-8">
        <div>
          <h1 className="text-3xl font-bold">Conditions d&apos;utilisation</h1>
          <p className="mt-2 text-muted-foreground">
            Dernière mise à jour : {new Date().toLocaleDateString()}
          </p>
        </div>

        <section className="space-y-4">
          <h2 className="text-2xl font-semibold">1. Acceptation des conditions</h2>
          <p>
            En accédant et en utilisant la plateforme 75Tribune, vous acceptez d&apos;être lié par ces
            conditions d&apos;utilisation. Si vous n&apos;acceptez pas ces conditions, veuillez ne pas
            utiliser notre service.
          </p>
        </section>

        <section className="space-y-4">
          <h2 className="text-2xl font-semibold">2. Description du service</h2>
          <p>
            75Tribune est une plateforme SaaS qui fournit [description de vos services]. Nous nous
            réservons le droit de modifier, suspendre ou interrompre tout aspect du service à tout
            moment.
          </p>
        </section>

        <section className="space-y-4">
          <h2 className="text-2xl font-semibold">3. Confidentialité</h2>
          <p>
            Votre utilisation de 75Tribune est également régie par notre politique de confidentialité.
            Veuillez consulter notre politique de confidentialité pour comprendre nos pratiques.
          </p>
        </section>

        <section className="space-y-4">
          <h2 className="text-2xl font-semibold">4. Comptes utilisateurs</h2>
          <p>
            Vous êtes responsable du maintien de la confidentialité de votre compte et mot de passe.
            Vous acceptez de nous notifier immédiatement de toute utilisation non autorisée de votre
            compte.
          </p>
        </section>

        <section className="space-y-4">
          <h2 className="text-2xl font-semibold">5. Propriété intellectuelle</h2>
          <p>
            Tout le contenu présent sur 75Tribune, incluant mais non limité aux textes, graphiques,
            logos, et code source, est la propriété de 75Tribune et est protégé par les lois sur la
            propriété intellectuelle.
          </p>
        </section>

        <section className="space-y-4">
          <h2 className="text-2xl font-semibold">6. Limitation de responsabilité</h2>
          <p>
            75Tribune ne sera pas responsable des dommages directs, indirects, accessoires, spéciaux
            ou consécutifs résultant de l&apos;utilisation ou de l&apos;impossibilité d&apos;utiliser nos services.
          </p>
        </section>

        <section className="space-y-4">
          <h2 className="text-2xl font-semibold">7. Modifications des conditions</h2>
          <p>
            Nous nous réservons le droit de modifier ces conditions à tout moment. Les modifications
            entrent en vigueur dès leur publication sur cette page.
          </p>
        </section>

        <section className="space-y-4">
          <h2 className="text-2xl font-semibold">8. Contact</h2>
          <p>
            Si vous avez des questions concernant ces conditions, veuillez nous contacter à{' '}
            <a href="mailto:contact@75Tribune.com" className="text-primary hover:underline">
              contact@75Tribune.com
            </a>
            .
          </p>
        </section>
      </div>
    </div>
  );
}


================================================================================

===== C:\wamp64\www\75Tribune\src\components\ArticleContent.tsx =====

'use client';

import React, { useState, useEffect } from 'react';
import CodeBlock from './CodeBlock';

interface CodeBlockData {
  placeholder: string;
  code: string;
  language: string;
}

// Fonction pour détecter le langage en fonction du contenu
function detectLanguage(code: string): string {
  // Nettoyage du code
  const cleanCode = code.trim();
  
  // Détection Python
  if (
    cleanCode.match(/^(import\s+[\w.]+|from\s+[\w.]+\s+import)/) || // import statements
    cleanCode.match(/^def\s+\w+\s*\(/) || // function definitions
    cleanCode.match(/print\s*\(/) || // print statements
    cleanCode.includes('self.') || // class methods
    cleanCode.match(/(True|False|None)(?![a-zA-Z])/) || // Python literals
    cleanCode.match(/\s{4}[\w]/) // Python indentation
  ) return 'python';

  // Détection PHP
  if (cleanCode.includes('<?php') || cleanCode.match(/^\s*<\?/)) return 'php';

  // Détection HTML
  if (
    cleanCode.match(/^<!DOCTYPE\s+html/i) ||
    cleanCode.match(/^<html/i) ||
    (cleanCode.match(/<[a-z]+.*>/) && cleanCode.match(/<\/[a-z]+>/))
  ) return 'html';

  // Détection CSS
  if (
    cleanCode.match(/^[\w-]+\s*{/) ||
    cleanCode.match(/@media\s+/) ||
    cleanCode.match(/^[.#][a-zA-Z][\w-]*\s*{/)
  ) return 'css';

  // Détection JavaScript
  if (
    cleanCode.match(/^(const|let|var|function|class|import|export)\s/) ||
    cleanCode.match(/=>\s*{/) ||
    cleanCode.match(/\$\(document\)/) ||
    cleanCode.includes('useState(') ||
    cleanCode.includes('useEffect(')
  ) return 'javascript';

  // Détection TypeScript
  if (
    cleanCode.match(/^(interface|type|namespace)\s/) ||
    cleanCode.match(/:\s*(string|number|boolean|any)\s*[,;=]/) ||
    cleanCode.match(/<[A-Z][a-zA-Z]+>/) // Generics
  ) return 'typescript';

  // Détection SQL
  if (
    cleanCode.match(/^(SELECT|INSERT|UPDATE|DELETE|CREATE|ALTER|DROP)\s/i) ||
    cleanCode.match(/\s(FROM|WHERE|JOIN|GROUP BY|ORDER BY|HAVING)\s/i)
  ) return 'sql';

  // Détection JSON
  if (
    cleanCode.match(/^[\s\n]*[{\[][\s\S]*[\}\]][\s\n]*$/) &&
    (cleanCode.includes('"') || cleanCode.includes(':'))
  ) return 'json';

  // Détection YAML
  if (
    cleanCode.match(/^[\s-]*[\w-]+:\s+.+$/m) &&
    !cleanCode.includes('{') &&
    !cleanCode.includes('}')
  ) return 'yaml';

  // Détection Shell/Bash
  if (
    cleanCode.match(/^[#!]\/bin\//) ||
    cleanCode.match(/^\s*\$\s+/) ||
    cleanCode.match(/^(sudo|apt|yum|dnf|brew|npm|yarn|pip)\s/)
  ) return 'bash';

  return 'text';
}

// Fonction pour extraire le langage de la classe CSS
function getLanguageFromClass(className: string, code: string): string {
  if (!className) {
    // Si pas de classe, on essaie de détecter le langage
    return detectLanguage(code);
  }
  const match = className.match(/language-(\w+)/);
  return match ? match[1] : detectLanguage(code);
}

interface ArticleContentProps {
  content: string;
}

export default function ArticleContent({ content }: ArticleContentProps) {
  const [processedContent, setProcessedContent] = useState<{
    html: string;
    codeBlocks: CodeBlockData[];
  }>({ html: content, codeBlocks: [] });

  useEffect(() => {
    const transformContent = (content: string) => {
      const tempDiv = document.createElement('div');
      tempDiv.innerHTML = content;
      
      // Traitement des blocs de code
      const codeBlocks = tempDiv.querySelectorAll('pre > code');
      const codeBlocksData: CodeBlockData[] = [];
      
      codeBlocks.forEach((codeBlock, index) => {
        const pre = codeBlock.parentElement;
        if (!pre) return;

        const code = codeBlock.textContent || '';
        const language = getLanguageFromClass(codeBlock.className, code);
        
        const placeholder = `___CODE_BLOCK_${index}___`;
        pre.outerHTML = placeholder;
        
        codeBlocksData.push({ placeholder, code, language });
      });

      // Appliquer les styles personnalisés
      const styledElements = tempDiv.querySelectorAll('[style]');
      styledElements.forEach(element => {
        const style = element.getAttribute('style');
        if (style) {
          // Conserver les styles existants
          element.setAttribute('style', style);
          
          // Ajouter des classes Tailwind équivalentes
          if (style.includes('font-size')) {
            if (style.includes('14px')) element.classList.add('text-sm');
            else if (style.includes('16px')) element.classList.add('text-base');
            else if (style.includes('18px')) element.classList.add('text-lg');
            else if (style.includes('20px')) element.classList.add('text-xl');
          }
          
          if (style.includes('line-height')) {
            if (style.includes('1.25')) element.classList.add('leading-tight');
            else if (style.includes('1.5')) element.classList.add('leading-normal');
            else if (style.includes('1.75')) element.classList.add('leading-relaxed');
            else if (style.includes('2')) element.classList.add('leading-loose');
          }
        }
      });

      // Préserver les espaces et les sauts de ligne
      const paragraphs = tempDiv.querySelectorAll('p');
      paragraphs.forEach(p => {
        // Ajouter des marges aux paragraphes
        p.classList.add('mb-6');
        
        // Préserver les espaces multiples
        if (p.innerHTML.includes('&nbsp;')) {
          p.style.whiteSpace = 'pre-wrap';
        }
      });

      // Traiter les sauts de ligne consécutifs
      const emptyParagraphs = tempDiv.querySelectorAll('p:empty');
      emptyParagraphs.forEach(p => {
        p.classList.add('h-6');
      });

      return {
        html: tempDiv.innerHTML,
        codeBlocks: codeBlocksData
      };
    };

    setProcessedContent(transformContent(content));
  }, [content]);

  return (
    <div className="prose prose-lg dark:prose-invert max-w-none [&_p]:my-6 [&_p:empty]:h-6 [&_p]:whitespace-pre-wrap">
      {processedContent.html.split(/___CODE_BLOCK_\d+___/).map((text, index) => (
        <React.Fragment key={index}>
          {text && (
            <div 
              dangerouslySetInnerHTML={{ __html: text }}
              className="[&_span[style]]:inline-block"
            />
          )}
          {processedContent.codeBlocks[index] && (
            <CodeBlock
              code={processedContent.codeBlocks[index].code}
              language={processedContent.codeBlocks[index].language}
            />
          )}
        </React.Fragment>
      ))}
    </div>
  );
}


================================================================================

===== C:\wamp64\www\75Tribune\src\components\Breadcrumb.tsx =====

import React from 'react';
import Link from 'next/link';
import { ChevronRight } from 'lucide-react';

interface BreadcrumbItem {
  label: string;
  href?: string;
}

interface BreadcrumbProps {
  items: BreadcrumbItem[];
}

export default function Breadcrumb({ items }: BreadcrumbProps) {
  return (
    <nav className="flex items-center space-x-2 text-sm text-gray-500 dark:text-gray-400 mb-6">
      <Link 
        href="/"
        className="hover:text-gray-700 dark:hover:text-gray-300 transition-colors"
      >
        Accueil
      </Link>
      
      {items.map((item, index) => (
        <React.Fragment key={index}>
          <ChevronRight className="w-4 h-4" />
          {item.href ? (
            <Link
              href={item.href}
              className="hover:text-gray-700 dark:hover:text-gray-300 transition-colors"
            >
              {item.label}
            </Link>
          ) : (
            <span className="text-gray-900 dark:text-gray-100">{item.label}</span>
          )}
        </React.Fragment>
      ))}
    </nav>
  );
}


================================================================================

===== C:\wamp64\www\75Tribune\src\components\CodeBlock.tsx =====

'use client';

import { useState, useCallback } from 'react';
import { Copy, Check } from 'lucide-react';
import { Highlight, themes } from 'prism-react-renderer';

interface CodeBlockProps {
  code: string;
  language?: string;
}

// Liste des langages supportés par Prism
const SUPPORTED_LANGUAGES = {
  markup: 'HTML',
  html: 'HTML',
  xml: 'XML',
  svg: 'SVG',
  mathml: 'MathML',
  ssml: 'SSML',
  atom: 'ATOM',
  rss: 'RSS',
  css: 'CSS',
  clike: 'C-like',
  javascript: 'JavaScript',
  js: 'JavaScript',
  jsx: 'JSX',
  typescript: 'TypeScript',
  ts: 'TypeScript',
  tsx: 'TSX',
  php: 'PHP',
  python: 'Python',
  py: 'Python',
  ruby: 'Ruby',
  rb: 'Ruby',
  go: 'Go',
  rust: 'Rust',
  sql: 'SQL',
  bash: 'Bash',
  shell: 'Shell',
  json: 'JSON',
  yaml: 'YAML',
  yml: 'YAML',
  markdown: 'Markdown',
  md: 'Markdown',
} as const;

// Fonction pour normaliser le langage
function normalizeLanguage(lang: string): string {
  // Enlever le préfixe 'language-' s'il existe
  const cleanLang = lang.replace(/^language-/, '').toLowerCase();
  
  // Correspondances spécifiques
  const languageMap: { [key: string]: string } = {
    js: 'javascript',
    py: 'python',
    rb: 'ruby',
    ts: 'typescript',
    yml: 'yaml',
    md: 'markdown',
    html: 'markup',
    xml: 'markup',
    svg: 'markup',
    mathml: 'markup',
    ssml: 'markup',
    atom: 'markup',
    rss: 'markup'
  };

  return languageMap[cleanLang] || cleanLang;
}

export default function CodeBlock({ code, language = 'text' }: CodeBlockProps) {
  const [copied, setCopied] = useState(false);

  const handleCopy = useCallback(async () => {
    try {
      await navigator.clipboard.writeText(code);
      setCopied(true);
      setTimeout(() => setCopied(false), 2000);
    } catch (err) {
      console.error('Failed to copy:', err);
    }
  }, [code]);

  const normalizedLang = normalizeLanguage(language);
  const displayLang = SUPPORTED_LANGUAGES[normalizedLang as keyof typeof SUPPORTED_LANGUAGES] || language.toUpperCase();

  return (
    <div className="not-prose my-8 overflow-hidden rounded-lg border border-gray-700 bg-gray-800 dark:bg-gray-900">
      {/* En-tête avec le nom du langage et le bouton copier */}
      <div className="flex items-center justify-between px-4 py-2 text-xs text-gray-400 border-b border-gray-700">
        <span className="font-mono">{displayLang}</span>
        <button
          onClick={handleCopy}
          className="flex items-center gap-1 px-2 py-1 rounded hover:bg-gray-700 dark:hover:bg-gray-800 transition-colors"
          title="Copier le code"
        >
          {copied ? (
            <>
              <Check className="w-3 h-3" />
              <span>Copié!</span>
            </>
          ) : (
            <>
              <Copy className="w-3 h-3" />
              <span>Copier</span>
            </>
          )}
        </button>
      </div>

      {/* Bloc de code avec coloration syntaxique */}
      <Highlight
        theme={themes.nightOwl}
        code={code.trim()}
        language={normalizedLang}
      >
        {({ className, style, tokens, getLineProps, getTokenProps }) => (
          <pre
            className="p-4 text-sm overflow-x-auto"
            style={{
              ...style,
              margin: 0, // Supprime la marge par défaut des <pre>
            }}
          >
            {tokens.map((line, i) => (
              <div key={i} {...getLineProps({ line })} style={{ minWidth: 'fit-content' }}>
                {line.map((token, key) => (
                  <span key={key} {...getTokenProps({ token })} />
                ))}
              </div>
            ))}
          </pre>
        )}
      </Highlight>
    </div>
  );
}


================================================================================

===== C:\wamp64\www\75Tribune\src\components\LogoutButton.tsx =====

'use client';

import { useAuth } from '@/providers/AuthProvider';

export default function LogoutButton() {
  const { clearAuth } = useAuth();

  return (
    <button
      onClick={clearAuth}
      className="text-gray-700 dark:text-gray-200 hover:text-red-600 dark:hover:text-red-400 transition-colors"
    >
      Déconnexion
    </button>
  );
}


================================================================================

===== C:\wamp64\www\75Tribune\src\components\PublishDestinations.tsx =====

import { PublishDestination } from '@/services/publishers/types';
import { Switch } from './ui/switch';
import Label from './ui/label';

interface PublishDestinationsProps {
  destinations: PublishDestination[];
  onChange: (platform: string) => void;
}

export function PublishDestinations({ destinations, onChange }: PublishDestinationsProps) {
  return (
    <div>
      <Label className="text-gray-700 dark:text-gray-300 mb-2 block">
        Plateformes de publication
      </Label>
      <div className="flex flex-row gap-4">
        {destinations.map((dest) => (
          <div
            key={dest.platform}
            className="flex-1 flex items-center justify-between p-2 rounded-lg bg-white dark:bg-gray-800 border border-gray-200 dark:border-gray-700"
          >
            <span className="text-sm text-gray-700 dark:text-gray-300 capitalize">
              {dest.platform}
            </span>
            <Switch
              checked={dest.enabled}
              onCheckedChange={() => onChange(dest.platform)}
            />
          </div>
        ))}
      </div>
    </div>
  );
}


================================================================================

===== C:\wamp64\www\75Tribune\src\components\articles\ArticleCard.tsx =====

import React from 'react';
import Image from 'next/image';
import Link from 'next/link';
import { format } from 'date-fns';
import { fr } from 'date-fns/locale';
import { normalizeImagePath } from '@/lib/image';
import { AccessLevel, Tag } from '@prisma/client';
import { Badge } from '@/components/ui/badge';
import { Sparkles } from 'lucide-react';
import { motion } from 'framer-motion';

interface ArticleCardProps {
  article: {
    slug: string;
    title: string;
    excerpt: string;
    featuredImage: string | null;
    publishedAt: Date;
    updatedAt: Date;
    author?: {
      name: string;
    };
    tags?: Tag[];
    accessLevel: AccessLevel;
  };
}

export default function ArticleCard({ article }: ArticleCardProps) {
  return (
    <motion.article
      initial={{ opacity: 0, scale: 0.95 }}
      whileInView={{ opacity: 1, scale: 1 }}
      viewport={{ once: true }}
      transition={{ duration: 0.5 }}
      className="flex flex-col bg-white dark:bg-gray-800 rounded-lg shadow-md overflow-hidden hover:shadow-lg transition-shadow"
    >
      <Link href={`/articles/${article.slug}`} className="group">
        {article.featuredImage && (
          <div className="relative aspect-video">
            <Image
              src={normalizeImagePath(article.featuredImage)}
              alt={article.title}
              fill
              className="object-cover group-hover:scale-105 transition-transform duration-300"
            />
            {article.accessLevel === AccessLevel.PRO && (
              <div className="absolute top-4 right-4 z-10">
                <Badge variant="premium" className="flex items-center gap-1">
                  <Sparkles className="h-3 w-3" />
                  Premium
                </Badge>
              </div>
            )}
          </div>
        )}

        <div className="p-6">
          <h2 className="text-xl font-bold mb-2 group-hover:text-primary-500 transition-colors">
            {article.title}
          </h2>
          <p className="text-gray-600 dark:text-gray-300 mb-4 line-clamp-2">
            {article.excerpt}
          </p>
          
          <div className="flex items-center justify-between text-sm text-gray-500 dark:text-gray-400">
            <div className="flex items-center">
              <time dateTime={article.publishedAt?.toString() || article.updatedAt?.toString()}>
                {format(
                  new Date(article.publishedAt || article.updatedAt),
                  'dd MMMM yyyy',
                  { locale: fr }
                )}
              </time>
              {article.author && (
                <>
                  <span className="mx-2">•</span>
                  <span>{article.author.name}</span>
                </>
              )}
            </div>
          </div>

          {article.tags && article.tags.length > 0 && (
            <div className="mt-4 flex flex-wrap gap-2">
              {article.tags.map((tag) => (
                <Badge key={tag.id} variant="outline">
                  {tag.name}
                </Badge>
              ))}
            </div>
          )}
        </div>
      </Link>
    </motion.article>
  );
}

================================================================================

===== C:\wamp64\www\75Tribune\src\components\articles\ArticleGrid.tsx =====

'use client';

import Link from 'next/link';
import Image from 'next/image';
import { Clock, Tag } from 'lucide-react';
import { Article, Category, Tag as PrismaTag, User } from '@prisma/client';
import { normalizeImagePath } from '@/lib/image';

interface ArticleWithRelations extends Article {
  author: User | null;
  category: Category | null;
  tags: PrismaTag[];
  readingTime?: number;
  publishedAt?: Date | null;
}

interface ArticleGridProps {
  articles: ArticleWithRelations[];
}

export default function ArticleGrid({ articles }: ArticleGridProps) {
  return (
    <div className="grid gap-6 md:grid-cols-2 lg:grid-cols-3">
      {articles.map((article) => (
        <article 
          key={article.id}
          className="bg-white dark:bg-gray-800 rounded-lg shadow-sm overflow-hidden hover:shadow-md transition-shadow"
        >
          {/* Image de couverture */}
          <div className="relative aspect-video bg-gray-100 dark:bg-gray-700">
            {article.featuredImage && (
              <Image
                src={normalizeImagePath(article.featuredImage)}
                alt={article.title}
                fill
                sizes="(max-width: 768px) 100vw, (max-width: 1200px) 50vw, 33vw"
                className="object-cover"
                priority={false}
              />
            )}
          </div>
          
          <div className="p-6">
            {/* Tags */}
            {article.tags && article.tags.length > 0 && (
              <div className="flex flex-wrap gap-2 mb-3">
                {article.tags.map((tag) => (
                  <span 
                    key={tag.id}
                    className="inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium bg-primary-100 text-primary-800 dark:bg-primary-800 dark:text-primary-100"
                  >
                    <Tag className="w-3 h-3 mr-1" />
                    {tag.name}
                  </span>
                ))}
              </div>
            )}

            {/* Titre */}
            <h2 className="text-xl font-semibold mb-2 text-gray-900 dark:text-white">
              <Link href={`/articles/${article.slug}`} className="hover:text-primary-600 dark:hover:text-primary-400">
                {article.title}
              </Link>
            </h2>

            {/* Extrait */}
            <p className="text-gray-600 dark:text-gray-300 mb-4">
              {article.excerpt}
            </p>

            {/* Métadonnées */}
            <div className="flex items-center text-sm text-gray-500 dark:text-gray-400">
              <Clock className="w-4 h-4 mr-1" />
              <time dateTime={new Date(article.createdAt).toISOString()}>
                {new Date(article.createdAt).toLocaleDateString()}
              </time>
            </div>
          </div>
        </article>
      ))}
    </div>
  );
}


================================================================================

===== C:\wamp64\www\75Tribune\src\components\articles\PremiumArticleView.tsx =====

'use client';

import React, { useState } from 'react';
import Image from 'next/image';
import { useRouter } from 'next/navigation';
import { motion, useMotionValue, useSpring, useTransform } from "framer-motion";
import { Badge } from "@/components/ui/badge";
import { Button } from '@/components/ui/button';
import { Lock, Sparkles, LogIn, BookOpen, FileText, Star } from 'lucide-react';
import { normalizeImagePath } from '@/lib/image';
import ArticleContent from '@/components/ArticleContent';

// Composant Confetti
const Confetti = ({ isHovered }: { isHovered: boolean }) => {
  return (
    <div className="absolute inset-0 pointer-events-none">
      {isHovered && Array.from({ length: 20 }).map((_, i) => (
        <motion.div
          key={i}
          initial={{ 
            x: "50%", 
            y: "50%", 
            scale: 0,
            opacity: 1 
          }}
          animate={{ 
            x: `${Math.random() * 200 - 100}%`,
            y: `${Math.random() * 200 - 100}%`,
            scale: Math.random() * 1.5,
            opacity: 0
          }}
          transition={{ 
            duration: 0.8 + Math.random() * 0.5,
            ease: "easeOut"
          }}
          className={`absolute w-2 h-2 rounded-full ${
            ['bg-primary-400', 'bg-blue-400', 'bg-purple-400', 'bg-amber-400'][Math.floor(Math.random() * 4)]
          }`}
        />
      ))}
    </div>
  );
};

export default function PremiumArticleView({ article, session }: { article: any, session: any }) {
  const router = useRouter();
  const [isButtonHovered, setIsButtonHovered] = useState(false);
  const mouseX = useMotionValue(0);
  const mouseY = useMotionValue(0);

  const springConfig = { damping: 30, stiffness: 200 };
  const moveX = useSpring(mouseX, springConfig);
  const moveY = useSpring(mouseY, springConfig);

  const rotateX = useTransform(moveY, [-300, 300], [10, -10]);
  const rotateY = useTransform(moveX, [-300, 300], [-10, 10]);

  const handleMouseMove = (e: React.MouseEvent) => {
    const rect = e.currentTarget.getBoundingClientRect();
    const centerX = rect.left + rect.width / 2;
    const centerY = rect.top + rect.height / 2;
    mouseX.set(e.clientX - centerX);
    mouseY.set(e.clientY - centerY);
  };

  const handleMouseLeave = () => {
    mouseX.set(0);
    mouseY.set(0);
  };

  return (
    <div className="container mx-auto px-4 pt-24 pb-8">
      <article className="max-w-4xl mx-auto">
        {/* En-tête de l'article avec animation d'entrée */}
        <motion.div 
          initial={{ opacity: 0, y: 20 }}
          animate={{ opacity: 1, y: 0 }}
          transition={{ duration: 0.6 }}
          className="mb-8"
        >
          <h1 className="text-4xl font-bold mb-4">{article.title}</h1>
          <p className="text-xl text-muted-foreground mb-6">{article.excerpt}</p>
          
          {article.featuredImage && (
            <div className="relative aspect-video rounded-xl overflow-hidden">
              <Image
                src={normalizeImagePath(article.featuredImage)}
                alt={article.title}
                fill
                className="object-cover"
                priority
              />
            </div>
          )}
        </motion.div>

        {/* Aperçu du contenu avec transition fluide */}
        <motion.div 
          initial={{ opacity: 0 }}
          animate={{ opacity: 1 }}
          transition={{ duration: 0.6, delay: 0.2 }}
          className="relative prose dark:prose-invert max-w-none mb-8"
        >
          <div className="relative">
            <div className="line-clamp-3">
              <ArticleContent content={article.content.slice(0, 500)} />
            </div>
            {/* Effet de fondu pour la transition */}
            <div className="absolute inset-0 bg-gradient-to-b from-transparent via-transparent to-background pointer-events-none" 
              style={{ 
                background: 'linear-gradient(to bottom, transparent 0%, transparent 50%, var(--background) 100%)',
                height: '150%',
                top: '0%'
              }} 
            />
          </div>
        </motion.div>

        {/* Section Premium avec Glassmorphism et effet de parallaxe */}
        <motion.div 
          initial={{ opacity: 0, y: 40 }}
          animate={{ opacity: 1, y: 0 }}
          transition={{ 
            duration: 0.8, 
            delay: 0.4,
            type: "spring",
            stiffness: 100 
          }}
          style={{ 
            perspective: 1000,
            rotateX,
            rotateY
          }}
          onMouseMove={handleMouseMove}
          onMouseLeave={handleMouseLeave}
          className="relative transform-gpu"
        >
          {/* Effet de flou progressif */}
          <motion.div 
            className="absolute inset-0 bg-gradient-to-b from-transparent via-background/50 to-background"
            style={{
              rotateX,
              rotateY,
              transformStyle: "preserve-3d"
            }}
          />

          <div className="relative backdrop-blur-md bg-white/10 dark:bg-black/10 border border-white/20 rounded-3xl p-8 shadow-2xl">
            <div className="flex flex-col items-center text-center space-y-6">
              {/* Badge Premium avec effet de lueur et animation */}
              <motion.div 
                className="relative"
                whileHover={{ scale: 1.05 }}
                whileTap={{ scale: 0.95 }}
              >
                <motion.div 
                  className="absolute -inset-4 bg-primary-500/20 blur-lg rounded-full"
                  animate={{ 
                    scale: [1, 1.2, 1],
                    opacity: [0.5, 0.8, 0.5] 
                  }}
                  transition={{ 
                    duration: 2,
                    repeat: Infinity,
                    ease: "easeInOut" 
                  }}
                />
                <Badge variant="secondary" className="relative bg-gradient-to-r from-primary-500 to-primary-600 text-white px-4 py-1 text-sm">
                  Contenu Premium
                </Badge>
              </motion.div>

              {/* Icône de verrouillage avec effet de lueur et parallaxe */}
              <motion.div 
                className="relative"
                whileHover={{ scale: 1.1 }}
                whileTap={{ scale: 0.9 }}
                style={{
                  rotateX: useTransform(moveY, [-300, 300], [20, -20]),
                  rotateY: useTransform(moveX, [-300, 300], [-20, 20]),
                }}
              >
                <motion.div 
                  className="absolute -inset-6 bg-primary-500/20 blur-xl rounded-full"
                  animate={{ 
                    scale: [1, 1.2, 1],
                    opacity: [0.3, 0.6, 0.3] 
                  }}
                  transition={{ 
                    duration: 3,
                    repeat: Infinity,
                    ease: "easeInOut" 
                  }}
                />
                <motion.div 
                  className="relative w-20 h-20 flex items-center justify-center"
                  whileHover={{ rotate: [0, -10, 10, 0] }}
                  transition={{ duration: 0.5 }}
                >
                  <div className="absolute inset-0 bg-gradient-to-br from-primary-400 to-primary-600 rounded-full opacity-20 animate-pulse" />
                  <Lock className="w-12 h-12 text-primary-600 dark:text-primary-400" strokeWidth={1.5} />
                </motion.div>
              </motion.div>

              {/* Message principal avec animation */}
              <motion.div 
                className="space-y-4"
                initial={{ opacity: 0, y: 20 }}
                animate={{ opacity: 1, y: 0 }}
                transition={{ duration: 0.6, delay: 0.6 }}
              >
                <h2 className="text-2xl font-semibold">
                  Accédez au contenu premium
                </h2>
                <p className="text-muted-foreground">
                  Profitez d'analyses approfondies et de contenus exclusifs avec notre abonnement Premium.
                </p>
              </motion.div>

              {/* Boutons d'action avec animation et confetti */}
              <motion.div 
                className="flex flex-col sm:flex-row gap-4 mt-6"
                initial={{ opacity: 0, y: 20 }}
                animate={{ opacity: 1, y: 0 }}
                transition={{ duration: 0.6, delay: 0.8 }}
              >
                <div className="relative">
                  <Button
                    onClick={() => router.push('/pricing')}
                    className="bg-primary-600 hover:bg-primary-700 text-white relative overflow-hidden group"
                    size="lg"
                    onMouseEnter={() => setIsButtonHovered(true)}
                    onMouseLeave={() => setIsButtonHovered(false)}
                  >
                    <motion.div
                      className="absolute inset-0 bg-white opacity-0 group-hover:opacity-20"
                      initial={false}
                      whileHover={{ scale: 2, x: 50 }}
                      transition={{ duration: 0.5 }}
                    />
                    <Sparkles className="mr-2 h-4 w-4" />
                    Voir les abonnements
                  </Button>
                  <Confetti isHovered={isButtonHovered} />
                </div>

                {!session && (
                  <Button
                    variant="outline"
                    onClick={() => router.push('/login')}
                    size="lg"
                    className="relative overflow-hidden group"
                  >
                    <motion.div
                      className="absolute inset-0 bg-primary-500 opacity-0 group-hover:opacity-10"
                      initial={false}
                      whileHover={{ scale: 2, x: 50 }}
                      transition={{ duration: 0.5 }}
                    />
                    <LogIn className="mr-2 h-4 w-4" />
                    Se connecter
                  </Button>
                )}
              </motion.div>

              {/* Grille de fonctionnalités avec animation */}
              <motion.div 
                className="grid grid-cols-1 sm:grid-cols-3 gap-6 mt-8 w-full"
                initial={{ opacity: 0, y: 20 }}
                animate={{ opacity: 1, y: 0 }}
                transition={{ duration: 0.6, delay: 1 }}
              >
                {[
                  {
                    icon: (
                      <motion.div 
                        className="relative w-12 h-12 flex items-center justify-center"
                        whileHover={{ scale: 1.1, rotate: 5 }}
                        whileTap={{ scale: 0.9 }}
                      >
                        <motion.div 
                          className="absolute inset-0 bg-gradient-to-br from-blue-400 to-blue-600 rounded-xl opacity-20"
                          animate={{ 
                            scale: [1, 1.2, 1],
                            opacity: [0.2, 0.3, 0.2] 
                          }}
                          transition={{ 
                            duration: 3,
                            repeat: Infinity,
                            ease: "easeInOut" 
                          }}
                        />
                        <div className="absolute inset-0 bg-blue-500/10 rounded-xl backdrop-blur-sm" />
                        <BookOpen className="w-6 h-6 text-blue-600 dark:text-blue-400" strokeWidth={1.5} />
                      </motion.div>
                    ),
                    title: "Articles exclusifs",
                    description: "Accédez à tous nos articles premium"
                  },
                  {
                    icon: (
                      <motion.div 
                        className="relative w-12 h-12 flex items-center justify-center"
                        whileHover={{ scale: 1.1, rotate: -5 }}
                        whileTap={{ scale: 0.9 }}
                      >
                        <motion.div 
                          className="absolute inset-0 bg-gradient-to-br from-purple-400 to-purple-600 rounded-xl opacity-20"
                          animate={{ 
                            scale: [1, 1.2, 1],
                            opacity: [0.2, 0.3, 0.2] 
                          }}
                          transition={{ 
                            duration: 3,
                            delay: 1,
                            repeat: Infinity,
                            ease: "easeInOut" 
                          }}
                        />
                        <div className="absolute inset-0 bg-purple-500/10 rounded-xl backdrop-blur-sm" />
                        <FileText className="w-6 h-6 text-purple-600 dark:text-purple-400" strokeWidth={1.5} />
                      </motion.div>
                    ),
                    title: "Analyses détaillées",
                    description: "Des analyses approfondies et expertises"
                  },
                  {
                    icon: (
                      <motion.div 
                        className="relative w-12 h-12 flex items-center justify-center"
                        whileHover={{ scale: 1.1, rotate: 5 }}
                        whileTap={{ scale: 0.9 }}
                      >
                        <motion.div 
                          className="absolute inset-0 bg-gradient-to-br from-amber-400 to-amber-600 rounded-xl opacity-20"
                          animate={{ 
                            scale: [1, 1.2, 1],
                            opacity: [0.2, 0.3, 0.2] 
                          }}
                          transition={{ 
                            duration: 3,
                            delay: 2,
                            repeat: Infinity,
                            ease: "easeInOut" 
                          }}
                        />
                        <div className="absolute inset-0 bg-amber-500/10 rounded-xl backdrop-blur-sm" />
                        <Star className="w-6 h-6 text-amber-600 dark:text-amber-400" strokeWidth={1.5} />
                      </motion.div>
                    ),
                    title: "Contenus spéciaux",
                    description: "Du contenu réservé aux membres premium"
                  }
                ].map((feature, index) => (
                  <motion.div
                    key={index}
                    className="group backdrop-blur-lg bg-white/5 dark:bg-white/5 border border-white/10 rounded-xl p-6 hover:bg-white/10 transition-all duration-300"
                    whileHover={{ y: -5 }}
                    initial={{ opacity: 0, y: 20 }}
                    animate={{ opacity: 1, y: 0 }}
                    transition={{ duration: 0.6, delay: 1 + (index * 0.1) }}
                  >
                    <div className="flex justify-center mb-4 transform group-hover:scale-105 transition-transform duration-300">
                      {feature.icon}
                    </div>
                    <h3 className="font-semibold mb-2">
                      {feature.title}
                    </h3>
                    <p className="text-sm text-muted-foreground">
                      {feature.description}
                    </p>
                  </motion.div>
                ))}
              </motion.div>
            </div>
          </div>
        </motion.div>
      </article>
    </div>
  );
}


================================================================================

===== C:\wamp64\www\75Tribune\src\components\articles\PremiumContentBlock.tsx =====

'use client';

import React, { useState } from 'react';
import { useRouter } from 'next/navigation';
import Image from 'next/image';
import { motion } from "framer-motion";
import { Button } from '@/components/ui/button';
import { Sparkles, LogIn, Clock, Download } from 'lucide-react';
import { normalizeImagePath } from '@/lib/image';

// Composant Confetti amélioré
const Confetti = ({ isHovered }: { isHovered: boolean }) => {
  return (
    <div className="absolute inset-0 pointer-events-none overflow-hidden">
      {isHovered && Array.from({ length: 50 }).map((_, i) => (
        <motion.div
          key={i}
          initial={{ 
            x: "50%", 
            y: "50%", 
            scale: 0,
            opacity: 1 
          }}
          animate={{ 
            x: `${Math.random() * 400 - 200}%`,
            y: `${Math.random() * 400 - 200}%`,
            scale: Math.random() * 2.5,
            opacity: 0,
            rotate: Math.random() * 360
          }}
          transition={{ 
            duration: 1.2 + Math.random() * 0.8,
            ease: [0.23, 1, 0.32, 1],
            delay: Math.random() * 0.2
          }}
          className={`absolute w-3 h-3 rounded-full ${
            [
              'bg-primary-400 shadow-lg shadow-primary-400/50',
              'bg-blue-400 shadow-lg shadow-blue-400/50',
              'bg-purple-400 shadow-lg shadow-purple-400/50',
              'bg-amber-400 shadow-lg shadow-amber-400/50',
              'bg-emerald-400 shadow-lg shadow-emerald-400/50',
              'bg-pink-400 shadow-lg shadow-pink-400/50'
            ][Math.floor(Math.random() * 6)]
          }`}
          style={{
            clipPath: Math.random() > 0.5 ? 'polygon(50% 0%, 100% 100%, 0% 100%)' : 'none'
          }}
        />
      ))}
    </div>
  );
};

interface PremiumContentBlockProps {
  article: any;
  session: any;
}

export default function PremiumContentBlock({ article, session }: PremiumContentBlockProps) {
  const router = useRouter();
  const [isButtonHovered, setIsButtonHovered] = useState(false);

  return (
    <div className="container mx-auto px-4 pt-24 pb-8">
      <article className="max-w-4xl mx-auto">
        <motion.div 
          initial={{ opacity: 0, y: 20 }}
          animate={{ opacity: 1, y: 0 }}
          transition={{ duration: 0.6 }}
          className="mb-8"
        >
          <h1 className="text-4xl font-bold mb-4">{article.title}</h1>
          <p className="text-xl text-muted-foreground mb-6">{article.excerpt}</p>
          
          {article.featuredImage && (
            <div className="relative aspect-video rounded-xl overflow-hidden">
              <Image
                src={normalizeImagePath(article.featuredImage)}
                alt={article.title}
                fill
                className="object-cover"
                priority
              />
            </div>
          )}
        </motion.div>

        <motion.div 
          initial={{ opacity: 0, y: 40 }}
          animate={{ opacity: 1, y: 0 }}
          transition={{ 
            duration: 0.8, 
            delay: 0.4,
            type: "spring",
            stiffness: 100 
          }}
          className="relative"
        >
          <div className="relative backdrop-blur-md bg-white/10 dark:bg-black/10 border border-white/20 rounded-3xl p-8 shadow-2xl hover:shadow-primary-500/10 transition-shadow duration-500">
            <div className="flex flex-col items-center text-center space-y-6">
              <motion.div 
                className="space-y-6 text-center"
                initial={{ opacity: 0, y: 20 }}
                animate={{ opacity: 1, y: 0 }}
                transition={{ duration: 0.6, delay: 0.6 }}
              >
                <motion.div
                  initial={{ opacity: 0, scale: 0.9 }}
                  animate={{ opacity: 1, scale: 1 }}
                  transition={{ duration: 0.5, delay: 0.7 }}
                  className="space-y-3"
                >
                  <h2 className="text-3xl md:text-4xl font-bold bg-clip-text text-transparent bg-gradient-to-r from-primary-500 to-primary-600">
                    Contenu Premium
                  </h2>
                  <p className="text-lg md:text-xl text-muted-foreground">
                    Accédez à ce contenu et bien plus pour seulement{" "}
                    <span className="font-semibold text-primary-500">5€ TTC</span> par mois
                  </p>
                </motion.div>

                {/* Bouton d'action avec animation et confetti */}
                <motion.div 
                  className="flex justify-center mt-8"
                  initial={{ opacity: 0, y: 20 }}
                  animate={{ opacity: 1, y: 0 }}
                  transition={{ duration: 0.6, delay: 0.8 }}
                >
                  <div className="relative">
                    <Button
                      onClick={() => router.push('/pricing')}
                      className="bg-primary-600 hover:bg-primary-700 text-white relative overflow-hidden group px-8"
                      size="lg"
                      onMouseEnter={() => setIsButtonHovered(true)}
                      onMouseLeave={() => setIsButtonHovered(false)}
                    >
                      <motion.div
                        className="absolute inset-0 bg-white opacity-0 group-hover:opacity-20"
                        initial={false}
                        whileHover={{ scale: 2, x: 50 }}
                        transition={{ duration: 0.5 }}
                      />
                      <Sparkles className="mr-2 h-4 w-4" />
                      Débloquer l&apos;accès
                    </Button>
                    <Confetti isHovered={isButtonHovered} />
                  </div>
                </motion.div>

                {/* Grille de fonctionnalités avec animation */}
                <motion.div 
                  className="grid grid-cols-1 sm:grid-cols-2 gap-6 mt-8"
                  initial={{ opacity: 0, y: 20 }}
                  animate={{ opacity: 1, y: 0 }}
                  transition={{ duration: 0.6, delay: 1 }}
                >
                  {[
                    {
                      icon: Clock,
                      color: "blue",
                      title: "Accès anticipé",
                      description: "Visionnez les tutoriels en avance"
                    },
                    {
                      icon: Download,
                      color: "purple",
                      title: "Téléchargement",
                      description: "Téléchargez les vidéos et les sources"
                    }
                  ].map((feature, index) => (
                    <motion.div
                      key={index}
                      className="group backdrop-blur-lg bg-white/5 dark:bg-white/5 border border-white/10 rounded-xl p-6 hover:bg-white/10 transition-all duration-300"
                      whileHover={{ y: -5, scale: 1.02 }}
                      initial={{ opacity: 0, y: 20 }}
                      animate={{ opacity: 1, y: 0 }}
                      transition={{ duration: 0.6, delay: 1 + (index * 0.1) }}
                    >
                      <motion.div 
                        className={`relative w-12 h-12 mx-auto mb-4 flex items-center justify-center rounded-xl bg-${feature.color}-500/10`}
                        whileHover={{ rotate: 5, scale: 1.1 }}
                        whileTap={{ scale: 0.95 }}
                      >
                        <motion.div 
                          className={`absolute inset-0 bg-gradient-to-br from-${feature.color}-400 to-${feature.color}-600 rounded-xl opacity-20`}
                          animate={{ 
                            scale: [1, 1.2, 1],
                            opacity: [0.2, 0.3, 0.2] 
                          }}
                          transition={{ 
                            duration: 3,
                            repeat: Infinity,
                            ease: "easeInOut" 
                          }}
                        />
                        <feature.icon className={`w-6 h-6 text-${feature.color}-600 dark:text-${feature.color}-400`} strokeWidth={1.5} />
                      </motion.div>
                      <h3 className="font-semibold text-center mb-2">
                        {feature.title}
                      </h3>
                      <p className="text-sm text-center text-muted-foreground">
                        {feature.description}
                      </p>
                    </motion.div>
                  ))}
                </motion.div>
              </motion.div>
            </div>
          </div>
        </motion.div>
      </article>
    </div>
  );
}


================================================================================

===== C:\wamp64\www\75Tribune\src\components\auth\AuthForm.tsx =====

'use client';

import { useState } from 'react';
import Link from 'next/link';
import { Eye, EyeOff, Github, Mail } from 'lucide-react';
import { useRouter } from 'next/navigation';
import { signIn, getSession } from 'next-auth/react';
import { Role } from '@prisma/client';
import { toast } from 'react-hot-toast'; // Import toast

interface AuthFormProps {
  mode: 'login' | 'register';
}

function AuthForm({ mode }: AuthFormProps) {
  const router = useRouter();
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const [name, setName] = useState('');
  const [showPassword, setShowPassword] = useState(false);
  const [loading, setLoading] = useState(false);
  const [rememberMe, setRememberMe] = useState(false);
  const [acceptTerms, setAcceptTerms] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const getRedirectPath = async () => {
    try {
      const session = await getSession();
      const userRole = session?.user?.role;

      switch (userRole) {
        case 'ADMIN':
          return '/dashboard';
        case 'MODERATOR':
          return '/moderator';
        case 'USER':
          return '/profile';
        default:
          return '/';
      }
    } catch (error) {
      console.error('Erreur lors de la récupération du rôle:', error);
      return '/';
    }
  };

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    setLoading(true);
    setError(null);

    try {
      if (mode === 'register') {
        // Inscription
        const res = await fetch('/api/auth/register', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            email: email.toLowerCase(),
            password,
            name,
          }),
        });

        const data = await res.json();

        if (!res.ok) {
          throw new Error(data.error || 'Une erreur est survenue lors de l\'inscription');
        }

        toast.success('Inscription réussie ! Un email de vérification a été envoyé à votre adresse.');
        
        // Attendre 3 secondes avant la redirection pour que l'utilisateur puisse lire le message
        setTimeout(() => {
          router.push('/login');
        }, 3000);
      } else {
        // Connexion
        const result = await signIn('credentials', {
          redirect: false,
          email: email.toLowerCase(),
          password,
        });

        if (result?.error) {
          if (result.error === 'Veuillez vérifier votre email avant de vous connecter') {
            toast.error('Veuillez vérifier votre email avant de vous connecter');
          } else {
            toast.error('Email ou mot de passe incorrect');
          }
          throw new Error(result.error);
        }

        toast.success('Connexion réussie !');
        
        // Obtenir l'URL de redirection en fonction du rôle
        const redirectPath = await getRedirectPath();
        router.push(redirectPath);
        router.refresh();
      }
    } catch (err: any) {
      console.error('Erreur:', err);
      setError(err.message);
    } finally {
      setLoading(false);
    }
  };

  return (
    <div className="grid gap-6">
      <div className="grid gap-2">
        <div className="grid gap-1">
          <h1 className="text-2xl font-semibold tracking-tight">
            {mode === 'login' ? 'Connexion' : 'Créer un compte'}
          </h1>
          <p className="text-sm text-muted-foreground">
            {mode === 'login'
              ? 'Entrez vos identifiants pour vous connecter'
              : 'Entrez vos informations pour créer un compte'}
          </p>
        </div>
        {error && (
          <div className="bg-red-50 text-red-500 text-sm p-3 rounded">
            {error}
          </div>
        )}
        <form onSubmit={handleSubmit}>
          <div className="grid gap-2">
            {mode === 'register' && (
              <div className="grid gap-1">
                <label className="text-sm font-medium" htmlFor="name">
                  Nom
                </label>
                <input
                  id="name"
                  name="name"
                  type="text"
                  autoCapitalize="none"
                  autoComplete="name"
                  autoCorrect="off"
                  disabled={loading}
                  value={name}
                  onChange={(e) => setName(e.target.value)}
                  required
                  className="w-full p-2 border rounded focus:outline-none focus:ring-2 focus:ring-blue-500"
                />
              </div>
            )}
            <div className="grid gap-1">
              <label className="text-sm font-medium" htmlFor="email">
                Email
              </label>
              <input
                id="email"
                name="email"
                type="email"
                autoCapitalize="none"
                autoComplete="email"
                autoCorrect="off"
                disabled={loading}
                value={email}
                onChange={(e) => setEmail(e.target.value)}
                required
                className="w-full p-2 border rounded focus:outline-none focus:ring-2 focus:ring-blue-500"
              />
            </div>
            <div className="grid gap-1">
              <label className="text-sm font-medium" htmlFor="password">
                Mot de passe
              </label>
              <div className="relative">
                <input
                  id="password"
                  name="password"
                  type={showPassword ? 'text' : 'password'}
                  autoCapitalize="none"
                  autoComplete={mode === 'login' ? 'current-password' : 'new-password'}
                  autoCorrect="off"
                  disabled={loading}
                  value={password}
                  onChange={(e) => setPassword(e.target.value)}
                  required
                  className="w-full p-2 border rounded focus:outline-none focus:ring-2 focus:ring-blue-500"
                />
                <button
                  type="button"
                  onClick={() => setShowPassword(!showPassword)}
                  className="absolute right-2 top-1/2 transform -translate-y-1/2"
                >
                  {showPassword ? (
                    <EyeOff className="h-4 w-4 text-gray-500" />
                  ) : (
                    <Eye className="h-4 w-4 text-gray-500" />
                  )}
                </button>
              </div>
            </div>
            {mode === 'login' && (
              <div className="flex items-center justify-between">
                <div className="flex items-center">
                  <input
                    id="remember"
                    name="remember"
                    type="checkbox"
                    checked={rememberMe}
                    onChange={(e) => setRememberMe(e.target.checked)}
                    className="h-4 w-4 text-blue-600 focus:ring-blue-500 border-gray-300 rounded"
                  />
                  <label htmlFor="remember" className="ml-2 block text-sm text-gray-900">
                    Se souvenir de moi
                  </label>
                </div>
                <Link
                  href="/forgot-password"
                  className="text-sm font-medium text-blue-600 hover:text-blue-500"
                >
                  Mot de passe oublié ?
                </Link>
              </div>
            )}
            {mode === 'register' && (
              <div className="flex items-center">
                <input
                  id="terms"
                  name="terms"
                  type="checkbox"
                  checked={acceptTerms}
                  onChange={(e) => setAcceptTerms(e.target.checked)}
                  required
                  className="h-4 w-4 text-blue-600 focus:ring-blue-500 border-gray-300 rounded"
                />
                <label htmlFor="terms" className="ml-2 block text-sm text-gray-900">
                  J&apos;accepte les{' '}
                  <Link href="/terms" className="text-blue-600 hover:text-blue-500">
                    conditions d&apos;utilisation
                  </Link>
                </label>
              </div>
            )}
            <button
              type="submit"
              disabled={loading || (mode === 'register' && !acceptTerms)}
              className="w-full flex justify-center py-2 px-4 border border-transparent rounded-md shadow-sm text-sm font-medium text-white bg-blue-600 hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500 disabled:opacity-50"
            >
              {loading ? (
                <div className="h-5 w-5 border-2 border-white border-t-transparent rounded-full animate-spin"></div>
              ) : mode === 'login' ? (
                'Se connecter'
              ) : (
                'S\'inscrire'
              )}
            </button>
          </div>
        </form>
        <div className="relative my-4">
          <div className="absolute inset-0 flex items-center">
            <span className="w-full border-t"></span>
          </div>
          <div className="relative flex justify-center text-xs uppercase">
            <span className="bg-white dark:bg-gray-800 px-2 text-gray-500">Ou continuer avec</span>
          </div>
        </div>
        <div className="grid grid-cols-2 gap-4">
          <button
            type="button"
            disabled={loading}
            onClick={() => signIn('github')}
            className="flex items-center justify-center gap-2 px-4 py-2 border rounded-lg text-sm font-medium hover:bg-gray-50"
          >
            <Github className="h-4 w-4" />
            Github
          </button>
          <button
            type="button"
            disabled={loading}
            onClick={() => signIn('google')}
            className="flex items-center justify-center gap-2 px-4 py-2 border rounded-lg text-sm font-medium hover:bg-gray-50"
          >
            <Mail className="h-4 w-4" />
            Google
          </button>
        </div>
        <p className="text-center text-sm text-gray-600">
          {mode === 'login' ? (
            <>
              Pas encore de compte ?{' '}
              <Link href="/register" className="text-blue-600 hover:text-blue-500">
                S&apos;inscrire
              </Link>
            </>
          ) : (
            <>
              Déjà un compte ?{' '}
              <Link href="/login" className="text-blue-600 hover:text-blue-500">
                Se connecter
              </Link>
            </>
          )}
        </p>
      </div>
    </div>
  );
}

export { AuthForm };


================================================================================

===== C:\wamp64\www\75Tribune\src\components\auth\ClientForgotPasswordForm.tsx =====

'use client';

import { useState } from 'react';
import Link from 'next/link';
import { ArrowLeft } from 'lucide-react';

export function ClientForgotPasswordForm() {
  const [email, setEmail] = useState('');
  const [loading, setLoading] = useState(false);
  const [success, setSuccess] = useState(false);

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    setLoading(true);
    
    try {
      const response = await fetch('/api/auth/forgot-password', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ email: email.toLowerCase() }),
      });

      const data = await response.json();

      if (!response.ok) {
        throw new Error(data.error || 'Une erreur est survenue');
      }

      setSuccess(true);
    } catch (error) {
      console.error('Erreur:', error);
      // On ne montre pas d'erreur spécifique pour éviter la divulgation d'informations
      setSuccess(true); // On affiche toujours le message de succès pour la sécurité
    } finally {
      setLoading(false);
    }
  };

  if (success) {
    return (
      <div className="auth-form">
        <div className="text-center">
          <h2 className="text-2xl font-bold">Vérifiez votre email</h2>
          <p className="mt-2 text-muted-foreground">
            Si un compte existe avec cette adresse email, vous recevrez un lien de réinitialisation.
          </p>
        </div>
        <Link
          href="/login"
          className="inline-flex items-center gap-2 text-sm text-primary hover:text-primary/80"
        >
          <ArrowLeft className="h-4 w-4" />
          Retour à la connexion
        </Link>
      </div>
    );
  }

  return (
    <div className="auth-form">
      <div>
        <h2 className="text-2xl font-bold text-center">Mot de passe oublié</h2>
        <p className="mt-2 text-center text-muted-foreground">
          Entrez votre email pour recevoir un lien de réinitialisation
        </p>
      </div>

      <form onSubmit={handleSubmit} className="space-y-4">
        <div className="form-group">
          <label htmlFor="email" className="form-label">
            Email
          </label>
          <input
            id="email"
            type="email"
            value={email}
            onChange={(e) => setEmail(e.target.value)}
            className="input-field"
            placeholder="vous@exemple.fr"
            required
          />
        </div>

        <button type="submit" className="btn-primary" disabled={loading}>
          {loading ? 'Envoi en cours...' : 'Envoyer le lien'}
        </button>
      </form>

      <Link
        href="/login"
        className="inline-flex items-center gap-2 text-sm text-primary hover:text-primary/80"
      >
        <ArrowLeft className="h-4 w-4" />
        Retour à la connexion
      </Link>
    </div>
  );
}


================================================================================

===== C:\wamp64\www\75Tribune\src\components\auth\ClientLoginForm.tsx =====

'use client';

import { AuthForm } from '@/components/auth/AuthForm';

export function ClientLoginForm() {
  return <AuthForm mode="login" />;
}


================================================================================

===== C:\wamp64\www\75Tribune\src\components\auth\ClientRegisterForm.tsx =====

'use client';

import { AuthForm } from '@/components/auth/AuthForm';

export function ClientRegisterForm() {
  return <AuthForm mode="register" />;
}


================================================================================

===== C:\wamp64\www\75Tribune\src\components\categories\category-dialog.tsx =====

"use client"

import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogHeader,
  DialogTitle,
} from "@/components/ui/dialog"
import { CategoryForm } from "./category-form"
import { CategoryTree } from "@/services/category.service"

interface CategoryDialogProps {
  show: boolean
  onClose: () => void
  categories: CategoryTree[]
  category?: CategoryTree
  onSubmit: (data: any) => Promise<void>
}

export function CategoryDialog({
  show,
  onClose,
  categories,
  category,
  onSubmit,
}: CategoryDialogProps) {
  return (
    <Dialog open={show} onOpenChange={onClose}>
      <DialogContent className="dark:bg-gray-800">
        <DialogHeader>
          <DialogTitle className="dark:text-white">
            {category ? 'Modifier la catégorie' : 'Créer une catégorie'}
          </DialogTitle>
          <DialogDescription className="dark:text-gray-400">
            {category
              ? 'Modifiez les détails de la catégorie.'
              : 'Ajoutez une nouvelle catégorie à votre site.'}
          </DialogDescription>
        </DialogHeader>
        <CategoryForm
          categories={categories.filter(cat => cat.id !== category?.id)}
          initialData={category}
          onSubmit={onSubmit}
          onCancel={onClose}
        />
      </DialogContent>
    </Dialog>
  )
}


================================================================================

===== C:\wamp64\www\75Tribune\src\components\categories\category-form.tsx =====

"use client"

import { useState } from 'react'
import { useForm } from 'react-hook-form'
import { zodResolver } from '@hookform/resolvers/zod'
import * as z from 'zod'
import { CategoryTree } from '@/services/category.service'

const categorySchema = z.object({
  name: z.string().min(1, 'Le nom est requis'),
  slug: z.string().optional(),
  parentId: z.string().nullable().optional(),
  order: z.number().optional(),
  isActive: z.boolean().default(true),
})

type CategoryFormValues = z.infer<typeof categorySchema>

interface CategoryFormProps {
  categories: CategoryTree[]
  initialData?: CategoryTree
  onSubmit: (data: CategoryFormValues) => Promise<void>
  onCancel: () => void
}

export function CategoryForm({
  categories,
  initialData,
  onSubmit,
  onCancel,
}: CategoryFormProps) {
  const [isLoading, setIsLoading] = useState(false)

  const form = useForm<CategoryFormValues>({
    resolver: zodResolver(categorySchema),
    defaultValues: {
      name: initialData?.name || '',
      slug: initialData?.slug || '',
      parentId: initialData?.parentId || undefined,
      order: initialData?.order || 0,
      isActive: initialData?.isActive ?? true,
    },
  })

// Modifiez la fonction handleSubmit comme ceci :
const handleSubmit = async (data: CategoryFormValues) => {
  try {
    setIsLoading(true);
    
    // Correction clé : Transformer parentId vide en null
    const formattedData = {
      ...data,
      parentId: data.parentId === '' ? null : data.parentId,
    };

    await onSubmit(formattedData); // Utilisez formattedData au lieu de data
    form.reset();
  } catch (error) {
    console.error('Erreur lors de la soumission:', error);
  } finally {
    setIsLoading(false);
  }
};

  const renderCategoryOptions = (cats: CategoryTree[], level = 0): JSX.Element[] => {
    return cats.flatMap((category) => [
      <option key={category.id} value={category.id}>
        {'  '.repeat(level)}
        {category.name}
      </option>,
      ...(category.children ? renderCategoryOptions(category.children, level + 1) : []),
    ])
  }

  return (
    <form onSubmit={form.handleSubmit(handleSubmit)} className="space-y-4">
      <div className="space-y-2">
        <label
          htmlFor="name"
          className="text-sm font-medium leading-none text-gray-900 dark:text-gray-100 peer-disabled:cursor-not-allowed peer-disabled:opacity-70"
        >
          Nom
        </label>
        <input
          {...form.register('name')}
          className="flex h-10 w-full rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background file:border-0 file:bg-transparent file:text-sm file:font-medium placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 dark:bg-gray-700 dark:border-gray-600 dark:text-white dark:placeholder-gray-400"
        />
        {form.formState.errors.name && (
          <p className="text-sm text-red-500 dark:text-red-400">{form.formState.errors.name.message}</p>
        )}
      </div>

      <div className="space-y-2">
        <label
          htmlFor="parentId"
          className="text-sm font-medium leading-none text-gray-900 dark:text-gray-100 peer-disabled:cursor-not-allowed peer-disabled:opacity-70"
        >
          Catégorie parente
        </label>
        <select
          {...form.register('parentId')}
          className="flex h-10 w-full rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 dark:bg-gray-700 dark:border-gray-600 dark:text-white"
        >
          <option value="">Aucune</option>
          {renderCategoryOptions(categories)}
        </select>
      </div>

      <div className="space-y-2">
        <label
          htmlFor="order"
          className="text-sm font-medium leading-none text-gray-900 dark:text-gray-100 peer-disabled:cursor-not-allowed peer-disabled:opacity-70"
        >
          Ordre
        </label>
        <input
          type="number"
          {...form.register('order', { valueAsNumber: true })}
          className="flex h-10 w-full rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background file:border-0 file:bg-transparent file:text-sm file:font-medium placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 dark:bg-gray-700 dark:border-gray-600 dark:text-white dark:placeholder-gray-400"
        />
      </div>

      <div className="flex items-center space-x-2">
        <input
          type="checkbox"
          {...form.register('isActive')}
          className="h-4 w-4 rounded border-gray-300 text-primary focus:ring-primary dark:border-gray-600 dark:bg-gray-700"
        />
        <label
          htmlFor="isActive"
          className="text-sm font-medium leading-none text-gray-900 dark:text-gray-100 peer-disabled:cursor-not-allowed peer-disabled:opacity-70"
        >
          Actif
        </label>
      </div>

      <div className="flex justify-end space-x-2">
        <button
          type="button"
          onClick={onCancel}
          className="px-4 py-2 text-sm font-medium text-gray-700 dark:text-gray-200 bg-white dark:bg-gray-700 border border-gray-300 dark:border-gray-600 rounded-md hover:bg-gray-50 dark:hover:bg-gray-600 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-primary dark:focus:ring-offset-gray-800"
          disabled={isLoading}
        >
          Annuler
        </button>
        <button
          type="submit"
          className="px-4 py-2 text-sm font-medium text-white bg-primary-600 rounded-md hover:bg-primary-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-primary dark:focus:ring-offset-gray-800"
          disabled={isLoading}
        >
          {isLoading ? 'Chargement...' : initialData ? 'Modifier' : 'Créer'}
        </button>
      </div>
    </form>
  )
}


================================================================================

===== C:\wamp64\www\75Tribune\src\components\comments\CommentItem.tsx =====

'use client';

import { format } from 'date-fns';
import { fr } from 'date-fns/locale';
import { Trash2, Check, X, Reply } from 'lucide-react';
import { useSession } from 'next-auth/react';
import { useState } from 'react';
import { toast } from '../ui/use-toast';
import { Button } from '../ui/button';
import { Textarea } from '../ui/textarea';
import { Avatar } from '../ui/avatar';

interface CommentItemProps {
  comment: any;
  onDelete: (id: string) => void;
  onModerate?: (id: string, isApproved: boolean) => void;
  onReply?: (parentId: string, content: string) => void;
  showModeration?: boolean;
  isReply?: boolean;
}

export default function CommentItem({
  comment,
  onDelete,
  onModerate,
  onReply,
  showModeration = false,
  isReply = false,
}: CommentItemProps) {
  const { data: session } = useSession();
  const [isDeleting, setIsDeleting] = useState(false);
  const [isModerating, setIsModerating] = useState(false);
  const [isReplying, setIsReplying] = useState(false);
  const [replyContent, setReplyContent] = useState('');

  const handleDelete = async () => {
    if (!window.confirm('Êtes-vous sûr de vouloir supprimer ce commentaire ?')) {
      return;
    }

    setIsDeleting(true);
    try {
      const response = await fetch(`/api/comments/${comment.id}`, {
        method: 'DELETE',
      });

      if (!response.ok) {
        throw new Error('Erreur lors de la suppression');
      }

      onDelete(comment.id);
      toast({
        title: 'Succès',
        description: 'Commentaire supprimé avec succès',
      });
    } catch (error) {
      console.error('Erreur:', error);
      toast({
        title: 'Erreur',
        description: 'Impossible de supprimer le commentaire',
        variant: 'destructive',
      });
    } finally {
      setIsDeleting(false);
    }
  };

  const handleModerate = async (isApproved: boolean) => {
    setIsModerating(true);
    try {
      const response = await fetch(`/api/comments/${comment.id}`, {
        method: 'PATCH',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ isApproved }),
      });

      if (!response.ok) {
        throw new Error('Erreur lors de la modération');
      }

      const updatedComment = await response.json();
      onModerate?.(comment.id, isApproved);
      toast({
        title: 'Succès',
        description: `Commentaire ${isApproved ? 'approuvé' : 'rejeté'} avec succès`,
      });
    } catch (error) {
      console.error('Erreur:', error);
      toast({
        title: 'Erreur',
        description: 'Impossible de modérer le commentaire',
        variant: 'destructive',
      });
    } finally {
      setIsModerating(false);
    }
  };

  const handleReplySubmit = async (e: React.FormEvent<HTMLFormElement>) => {
    e.preventDefault();
    if (!replyContent.trim()) return;

    try {
      await onReply?.(comment.id, replyContent);
      setReplyContent('');
      setIsReplying(false);
      toast({
        title: 'Succès',
        description: 'Réponse envoyée avec succès',
      });
    } catch (error) {
      console.error('Erreur:', error);
      toast({
        title: 'Erreur',
        description: 'Impossible d\'envoyer la réponse',
        variant: 'destructive',
      });
    }
  };

  const canDelete =
    session?.user?.id === comment.author.id || session?.user?.role === 'ADMIN';

  return (
    <div className={`flex space-x-4 p-4 bg-white dark:bg-gray-800 rounded-lg shadow-sm ${isReply ? 'ml-8' : ''}`}>
      <div className="flex items-start gap-3">
        {/* Debug data */}
        <Avatar 
          src={comment.author.avatar}
          name={comment.author.name}
          size="sm"
        />
        <div className="flex-1">
          <div className="flex items-center justify-between">
            <div className="flex items-center space-x-2">
              <span className="font-medium text-gray-900 dark:text-gray-100">
                {comment.author.name}
              </span>
              <span className="text-sm text-gray-500 dark:text-gray-400">
                {format(new Date(comment.createdAt), 'dd MMMM yyyy à HH:mm', {
                  locale: fr,
                })}
              </span>
            </div>
            <div className="flex items-center space-x-2">
              {showModeration && !comment.isApproved && (
                <>
                  <button
                    onClick={() => handleModerate(true)}
                    disabled={isModerating}
                    className="p-1 text-green-600 hover:text-green-700 dark:text-green-500 dark:hover:text-green-400"
                    title="Approuver"
                  >
                    <Check className="h-5 w-5" />
                  </button>
                  <button
                    onClick={() => handleModerate(false)}
                    disabled={isModerating}
                    className="p-1 text-red-600 hover:text-red-700 dark:text-red-500 dark:hover:text-red-400"
                    title="Rejeter"
                  >
                    <X className="h-5 w-5" />
                  </button>
                </>
              )}
              {canDelete && (
                <button
                  onClick={handleDelete}
                  disabled={isDeleting}
                  className="p-1 text-red-600 hover:text-red-700 dark:text-red-500 dark:hover:text-red-400"
                  title="Supprimer"
                >
                  <Trash2 className="h-5 w-5" />
                </button>
              )}
            </div>
          </div>
          <p className="mt-2 text-gray-700 dark:text-gray-300">{comment.content}</p>

          {!isReply && session && (
            <div className="mt-2">
              <button
                onClick={() => setIsReplying(!isReplying)}
                className="flex items-center text-sm text-gray-500 hover:text-gray-700 dark:text-gray-400 dark:hover:text-gray-300"
              >
                <Reply className="h-4 w-4 mr-1" />
                Répondre
              </button>

              {isReplying && (
                <form onSubmit={handleReplySubmit} className="mt-2 space-y-2">
                  <Textarea
                    value={replyContent}
                    onChange={(e) => setReplyContent(e.target.value)}
                    placeholder="Écrivez votre réponse..."
                    className="w-full"
                  />
                  <div className="flex space-x-2">
                    <Button type="submit" disabled={!replyContent.trim()}>
                      Envoyer
                    </Button>
                    <Button
                      type="button"
                      variant="outline"
                      onClick={() => {
                        setIsReplying(false);
                        setReplyContent('');
                      }}
                    >
                      Annuler
                    </Button>
                  </div>
                </form>
              )}
            </div>
          )}

          {comment.replies && comment.replies.length > 0 && (
            <div className="mt-4 space-y-4">
              {comment.replies.map((reply: any) => (
                <CommentItem
                  key={reply.id}
                  comment={reply}
                  onDelete={onDelete}
                  onModerate={onModerate}
                  showModeration={showModeration}
                  isReply={true}
                />
              ))}
            </div>
          )}
        </div>
      </div>
    </div>
  );
}


================================================================================

===== C:\wamp64\www\75Tribune\src\components\comments\CommentSection.tsx =====

'use client';

import { useSession } from 'next-auth/react';
import { useEffect, useState } from 'react';
import { Button } from '../ui/button';
import { Textarea } from '../ui/textarea';
import CommentItem from './CommentItem';
import { toast } from '../ui/use-toast';

interface CommentSectionProps {
  articleId: string;
  showModeration?: boolean;
}

export default function CommentSection({
  articleId,
  showModeration = false,
}: CommentSectionProps) {
  const { data: session } = useSession();
  const [comments, setComments] = useState<any[]>([]);
  const [newComment, setNewComment] = useState('');
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [isLoading, setIsLoading] = useState(true);

  useEffect(() => {
    fetchComments();
  }, [articleId]);

  const fetchComments = async () => {
    try {
      console.log('Fetching comments for article:', articleId); // Debug log
      const response = await fetch(`/api/comments?articleId=${articleId}`);
      if (!response.ok) {
        throw new Error('Erreur lors de la récupération des commentaires');
      }
      const data = await response.json();
      console.log('Comments received:', data); // Debug log
      setComments(data);
    } catch (error) {
      console.error('Erreur:', error);
      toast({
        title: 'Erreur',
        description: 'Impossible de charger les commentaires',
        variant: 'destructive',
      });
    } finally {
      setIsLoading(false);
    }
  };

  const handleSubmit = async (e: React.FormEvent<HTMLFormElement>) => {
    e.preventDefault();
    if (!newComment.trim()) return;

    setIsSubmitting(true);
    try {
      const response = await fetch('/api/comments', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          content: newComment,
          articleId,
        }),
      });

      if (!response.ok) {
        throw new Error('Erreur lors de la soumission du commentaire');
      }

      const comment = await response.json();
      if (comment.isApproved) {
        setComments((prev) => [comment, ...prev]);
      }
      setNewComment('');
      toast({
        title: 'Succès',
        description: comment.isApproved
          ? 'Commentaire publié avec succès'
          : 'Commentaire soumis pour modération',
      });
    } catch (error) {
      console.error('Erreur:', error);
      toast({
        title: 'Erreur',
        description: 'Impossible de publier le commentaire',
        variant: 'destructive',
      });
    } finally {
      setIsSubmitting(false);
    }
  };

  const handleDelete = (id: string) => {
    setComments((prev) => {
      const updateReplies = (comments: any[]) =>
        comments.filter((comment) => {
          if (comment.replies) {
            comment.replies = updateReplies(comment.replies);
          }
          return comment.id !== id;
        });

      return updateReplies(prev);
    });
  };

  const handleModerate = (id: string, isApproved: boolean) => {
    setComments((prev) => {
      const updateReplies = (comments: any[]) =>
        comments.map((comment) => {
          if (comment.id === id) {
            return { ...comment, isApproved };
          }
          if (comment.replies) {
            comment.replies = updateReplies(comment.replies);
          }
          return comment;
        });

      return updateReplies(prev);
    });
  };

  const handleReply = async (parentId: string, content: string) => {
    try {
      const response = await fetch('/api/comments', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          content,
          articleId,
          parentId,
        }),
      });

      if (!response.ok) {
        const error = await response.json();
        throw new Error(error.error || 'Erreur lors de la soumission de la réponse');
      }

      const reply = await response.json();
      
      setComments((prev) => {
        return prev.map((comment) => {
          if (comment.id === parentId) {
            return {
              ...comment,
              replies: [...(comment.replies || []), reply],
            };
          }
          return comment;
        });
      });

      return reply;
    } catch (error) {
      console.error('Erreur lors de la réponse:', error);
      throw error;
    }
  };

  if (isLoading) {
    return <div className="animate-pulse">Chargement des commentaires...</div>;
  }

  return (
    <div className="space-y-6">
      <h2 className="text-2xl font-bold">Commentaires</h2>
      
      {session ? (
        <form onSubmit={handleSubmit} className="space-y-4">
          <Textarea
            value={newComment}
            onChange={(e) => setNewComment(e.target.value)}
            placeholder="Écrivez votre commentaire..."
            className="w-full"
          />
          <Button type="submit" disabled={isSubmitting || !newComment.trim()}>
            {isSubmitting ? 'Publication...' : 'Publier'}
          </Button>
        </form>
      ) : (
        <p className="text-gray-600 dark:text-gray-400">
          Connectez-vous pour laisser un commentaire.
        </p>
      )}

      <div className="space-y-4">
        {comments.length > 0 ? (
          comments.map((comment) => (
            <CommentItem
              key={comment.id}
              comment={comment}
              onDelete={handleDelete}
              onModerate={handleModerate}
              onReply={handleReply}
              showModeration={showModeration}
            />
          ))
        ) : (
          <p className="text-gray-600 dark:text-gray-400">
            Aucun commentaire pour le moment. Soyez le premier à commenter !
          </p>
        )}
      </div>
    </div>
  );
}


================================================================================

===== C:\wamp64\www\75Tribune\src\components\editor\AIAssistant.tsx =====

import { useState } from 'react';
import { Sparkles, Loader2, BookOpen, BookmarkCheck } from 'lucide-react';

interface AIAssistantProps {
  onSuggestion: (content: string) => void;
}

const AI_MODELS = [
  { value: 'codellama:latest', label: 'Code Llama (Latest)' },
  { value: 'codellama:13b', label: 'Code Llama (13B)' },
  { value: 'qwen2.5-coder:14b', label: 'Qwen 2.5 Coder (14B)' },
  { value: 'mixtral:8x7b', label: 'Mixtral 8x7B' },
  { value: 'qwen2.5:7b', label: 'Qwen 2.5 (7B)' },
  { value: 'llama3:latest', label: 'LLaMA 3 (Latest)' },
  { value: 'llama3.2:latest', label: 'LLaMA 3.2 (Latest)' },
  { value: 'llava:34b', label: 'LLaVA 34B' },
  { value: 'deepseek-r1:14b', label: 'DeepSeek R1 (14B)' },
  { value: 'nomic-embed-text:latest', label: 'Nomic Embed Text' }
];
const TONES = [
  { value: 'professional', label: 'Professionnel' },
  { value: 'friendly', label: 'Amical' },
  { value: 'informative', label: 'Informatif' },
  { value: 'humorous', label: 'Humoristique' },
  { value: 'motivational', label: 'Motivant' },
  { value: 'empathetic', label: 'Empathique' },
  { value: 'direct', label: 'Direct' },
  { value: 'creative', label: 'Créatif' },
  { value: 'serious', label: 'Sérieux' },
  { value: 'optimistic', label: 'Optimiste' },
  { value: 'enthusiastic', label: 'Enthousiaste' },
  { value: 'persuasive', label: 'Persuasif' },
  { value: 'neutral', label: 'Neutre' },
  { value: 'strict', label: 'Sévère' },
  { value: 'sincere', label: 'Sincère' },
  { value: 'technical', label: 'Technique' },
  { value: 'academic', label: 'Académique' },
];

export default function AIAssistant({ onSuggestion }: AIAssistantProps) {
  const [prompt, setPrompt] = useState('');
  const [loading, setLoading] = useState(false);
  const [selectedModel, setSelectedModel] = useState('llama3.1:8b');
  const [selectedTone, setSelectedTone] = useState('professional');

  const generateContent = async (customPrompt?: string) => {
    const finalPrompt = customPrompt || prompt;
    if (!finalPrompt.trim()) return;
    
    setLoading(true);
    try {
      const response = await fetch('/api/ai/generate', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ 
          prompt: finalPrompt,
          model: selectedModel,
          tone: selectedTone,
        }),
      });

      const data = await response.json();
      if (response.ok) {
        onSuggestion(data.content);
        setPrompt('');
      } else {
        console.error('Erreur de génération:', data.error);
      }
    } catch (error) {
      console.error('Erreur:', error);
    } finally {
      setLoading(false);
    }
  };

  const quickActions = [
    {
      icon: BookOpen,
      label: "Introduction",
      prompt: "Générer une introduction captivante pour cet article qui présente le sujet et donne envie de lire la suite.",
    },
    {
      icon: BookmarkCheck,
      label: "Conclusion",
      prompt: "Générer une conclusion qui résume les points clés de l'article et ouvre sur une réflexion ou une action.",
    },
  ];

  return (
    <div className="space-y-4 p-4 bg-background/95 backdrop-blur supports-[backdrop-filter]:bg-background/60 border rounded-lg">
      <div className="flex gap-4 mb-4">
        <div className="flex-1">
          <label htmlFor="model" className="block text-sm font-medium text-foreground/60 mb-1">
            Modèle IA
          </label>
          <select
            id="model"
            value={selectedModel}
            onChange={(e) => setSelectedModel(e.target.value)}
            className="w-full px-3 py-2 bg-background border rounded-md text-sm"
          >
            {AI_MODELS.map((model) => (
              <option key={model.value} value={model.value}>
                {model.label}
              </option>
            ))}
          </select>
        </div>
        <div className="flex-1">
          <label htmlFor="tone" className="block text-sm font-medium text-foreground/60 mb-1">
            Ton
          </label>
          <select
            id="tone"
            value={selectedTone}
            onChange={(e) => setSelectedTone(e.target.value)}
            className="w-full px-3 py-2 bg-background border rounded-md text-sm"
          >
            {TONES.map((tone) => (
              <option key={tone.value} value={tone.value}>
                {tone.label}
              </option>
            ))}
          </select>
        </div>
      </div>

      <div className="flex gap-2 flex-wrap">
        {quickActions.map((action) => (
          <button
            key={action.label}
            onClick={() => generateContent(action.prompt)}
            className="inline-flex items-center gap-2 px-3 py-1.5 bg-primary/10 hover:bg-primary/20 text-primary text-sm rounded-md transition-colors"
            disabled={loading}
          >
            <action.icon className="w-4 h-4" />
            {action.label}
          </button>
        ))}
      </div>

      <div className="flex gap-2">
        <textarea
          value={prompt}
          onChange={(e) => setPrompt(e.target.value)}
          placeholder="Décrivez ce que vous souhaitez générer..."
          className="flex-1 min-h-[100px] px-3 py-2 bg-background border rounded-md text-sm resize-none"
          disabled={loading}
        />
        <button
          onClick={() => generateContent()}
          disabled={loading || !prompt.trim()}
          className="inline-flex items-center justify-center gap-2 px-4 py-2 bg-primary text-primary-foreground rounded-md hover:bg-primary/90 transition-colors disabled:opacity-50 disabled:cursor-not-allowed"
        >
          {loading ? (
            <Loader2 className="w-4 h-4 animate-spin" />
          ) : (
            <Sparkles className="w-4 h-4" />
          )}
          Générer
        </button>
      </div>
    </div>
  );
}


================================================================================

===== C:\wamp64\www\75Tribune\src\components\editor\ImageUpload.tsx =====

import { useState, useRef } from 'react';
import { Image as ImageIcon, Loader2 } from 'lucide-react';

interface ImageUploadProps {
  onUpload: (url: string) => void;
}

export default function ImageUpload({ onUpload }: ImageUploadProps) {
  const [loading, setLoading] = useState(false);
  const fileInputRef = useRef<HTMLInputElement>(null);

  const handleUpload = async (event: React.ChangeEvent<HTMLInputElement>) => {
    const file = event.target.files?.[0];
    if (!file) return;

    try {
      setLoading(true);
      const formData = new FormData();
      formData.append('file', file);

      const response = await fetch('/api/upload', {
        method: 'POST',
        body: formData,
        credentials: 'same-origin',
        headers: {
          'Accept': 'application/json'
        }
      });

      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(errorData.error || 'Erreur lors de l\'upload');
      }

      const data = await response.json();
      onUpload(data.url);
    } catch (error) {
      console.error('Erreur upload:', error);
      alert(error instanceof Error ? error.message : 'Erreur lors de l\'upload');
    } finally {
      setLoading(false);
      if (fileInputRef.current) {
        fileInputRef.current.value = '';
      }
    }
  };

  return (
    <div className="relative">
      <input
        ref={fileInputRef}
        type="file"
        accept="image/*"
        onChange={handleUpload}
        className="absolute inset-0 w-full h-full opacity-0 cursor-pointer"
        disabled={loading}
      />
      <button
        type="button"
        className={`p-2 rounded hover:bg-gray-100 ${
          loading ? 'opacity-50 cursor-not-allowed' : ''
        }`}
        disabled={loading}
      >
        {loading ? (
          <Loader2 className="w-5 h-5 animate-spin" />
        ) : (
          <ImageIcon className="w-5 h-5" />
        )}
      </button>
    </div>
  );
}


================================================================================

===== C:\wamp64\www\75Tribune\src\components\editor\RichTextEditor.tsx =====

'use client';

import { useState } from 'react';
import dynamic from 'next/dynamic';
import { useEditor, EditorContent } from '@tiptap/react';
import StarterKit from '@tiptap/starter-kit';
import Image from '@tiptap/extension-image';
import Link from '@tiptap/extension-link';
import CodeBlockLowlight from '@tiptap/extension-code-block-lowlight';
import { createLowlight } from 'lowlight';
import js from 'highlight.js/lib/languages/javascript';
import python from 'highlight.js/lib/languages/python';
import html from 'highlight.js/lib/languages/xml';
import css from 'highlight.js/lib/languages/css';
import {
  Bold,
  Italic,
  List,
  ListOrdered,
  Quote,
  Undo,
  Redo,
  Link as LinkIcon,
  Image as ImageIcon,
  Code,
} from 'lucide-react';

import AIAssistant from './AIAssistant';
import ImageUpload from './ImageUpload';

/* ------------------------------------------------------------------
   1) Configuration du lowlight (pour la coloration syntaxique)
------------------------------------------------------------------ */
const lowlight = createLowlight();
lowlight.register('javascript', js);
lowlight.register('python', python);
lowlight.register('html', html);
lowlight.register('css', css);

/* ------------------------------------------------------------------
   2) Props du composant "RichTextEditor"
------------------------------------------------------------------ */
interface RichTextEditorProps {
  /** Contenu HTML initial que vous passez depuis le parent */
  content: string;
  /** Fonction pour récupérer les mises à jour de contenu */
  onChange: (content: string) => void;
  /** Optionnel: fonction à appeler pour publier */
  onPublish?: (destinations: any[]) => void;
  /** Afficher ou non la partie publication */
  showPublishOptions?: boolean;
}

/* ------------------------------------------------------------------
   3) Composant "MenuBar" = barre d'outils
------------------------------------------------------------------ */
const MenuBar = ({ editor }: { editor: any }) => {
  if (!editor) {
    return null;
  }

  const addImage = () => {
    const url = window.prompt("URL de l'image:");
    if (url) {
      editor.chain().focus().setImage({ src: url }).run();
    }
  };

  const setLink = () => {
    const url = window.prompt('URL:');
    if (url) {
      editor.chain().focus().setLink({ href: url }).run();
    }
  };

  const addCodeBlock = () => {
    const language = window.prompt('Langage (ex: javascript, python):', 'javascript');
    if (language) {
      editor.chain().focus().toggleCodeBlock({ language }).run();
    }
  };

  return (
    <div className="border-b border-gray-200 p-2 mb-4 flex flex-wrap gap-2">
      <button
        type="button"
        onClick={() => editor.chain().focus().toggleBold().run()}
        className={`p-2 rounded hover:bg-gray-100 ${
          editor.isActive('bold') ? 'bg-gray-100' : ''
        }`}
      >
        <Bold className="w-5 h-5" />
      </button>
      <button
        type="button"
        onClick={() => editor.chain().focus().toggleItalic().run()}
        className={`p-2 rounded hover:bg-gray-100 ${
          editor.isActive('italic') ? 'bg-gray-100' : ''
        }`}
      >
        <Italic className="w-5 h-5" />
      </button>
      <button
        type="button"
        onClick={() => editor.chain().focus().toggleBulletList().run()}
        className={`p-2 rounded hover:bg-gray-100 ${
          editor.isActive('bulletList') ? 'bg-gray-100' : ''
        }`}
      >
        <List className="w-5 h-5" />
      </button>
      <button
        type="button"
        onClick={() => editor.chain().focus().toggleOrderedList().run()}
        className={`p-2 rounded hover:bg-gray-100 ${
          editor.isActive('orderedList') ? 'bg-gray-100' : ''
        }`}
      >
        <ListOrdered className="w-5 h-5" />
      </button>
      <button
        type="button"
        onClick={() => editor.chain().focus().toggleBlockquote().run()}
        className={`p-2 rounded hover:bg-gray-100 ${
          editor.isActive('blockquote') ? 'bg-gray-100' : ''
        }`}
      >
        <Quote className="w-5 h-5" />
      </button>
      <button
        type="button"
        onClick={setLink}
        className={`p-2 rounded hover:bg-gray-100 ${
          editor.isActive('link') ? 'bg-gray-100' : ''
        }`}
      >
        <LinkIcon className="w-5 h-5" />
      </button>
      <button
        type="button"
        onClick={addImage}
        className="p-2 rounded hover:bg-gray-100"
      >
        <ImageIcon className="w-5 h-5" />
      </button>
      <button
        type="button"
        onClick={addCodeBlock}
        className={`p-2 rounded hover:bg-gray-100 ${
          editor.isActive('codeBlock') ? 'bg-gray-100' : ''
        }`}
      >
        <Code className="w-5 h-5" />
      </button>
      <button
        type="button"
        onClick={() => editor.chain().focus().undo().run()}
        className="p-2 rounded hover:bg-gray-100"
      >
        <Undo className="w-5 h-5" />
      </button>
      <button
        type="button"
        onClick={() => editor.chain().focus().redo().run()}
        className="p-2 rounded hover:bg-gray-100"
      >
        <Redo className="w-5 h-5" />
      </button>
    </div>
  );
};

/* ------------------------------------------------------------------
   4) Composant interne "RichTextEditorContent"
   Cet éditeur Tiptap se base sur la "value" initiale,
   et appelle onChange() à chaque mise à jour.
------------------------------------------------------------------ */
const RichTextEditorContent = ({
  value,
  onChange,
}: {
  value: string;
  onChange: (content: string) => void;
}) => {
  // capture la "value" initiale dans un state local :
  const [initialValue] = useState(value);

  // Setup Tiptap Editor
  const editor = useEditor({
    extensions: [
      StarterKit.configure({
        codeBlock: false,
        heading: { levels: [1, 2, 3] },
        bulletList: { keepMarks: true, keepAttributes: false },
        orderedList: { keepMarks: true, keepAttributes: false },
      }),
      Image.configure({
        HTMLAttributes: {
          class: 'max-w-full h-auto rounded-lg',
        },
        allowBase64: true,
      }),
      Link.configure({
        openOnClick: false,
        HTMLAttributes: {
          class: 'text-primary-600 hover:text-primary-700 dark:text-primary-400 dark:hover:text-primary-300',
        },
      }),
      CodeBlockLowlight.configure({
        lowlight,
        HTMLAttributes: {
          class: 'rounded-lg p-4 bg-gray-100 dark:bg-gray-800',
        },
      }),
    ],
    // On n'utilise QUE la "initialValue" pour éviter de réécraser en continu
    content: initialValue,
    onUpdate: ({ editor }) => {
      // À chaque frappe, on remonte le HTML dans onChange
      onChange(editor.getHTML());
    },
    editorProps: {
      attributes: {
        class: 'prose dark:prose-invert max-w-none focus:outline-none min-h-[200px] p-4',
      },
      handleDrop: (view, event, slice, moved) => {
        if (!moved && event.dataTransfer?.files.length) {
          const file = event.dataTransfer.files[0];
          if (file.type.startsWith('image/')) {
            // TODO: Gérer le drop d'image
            return true;
          }
        }
        return false;
      },
      handlePaste: (view, event) => {
        if (event.clipboardData?.files.length) {
          const file = event.clipboardData.files[0];
          if (file.type.startsWith('image/')) {
            // TODO: Gérer le collage d'image
            return true;
          }
        }
        return false;
      },
    },
    immediatelyRender: false,
  });

  // Gestion d'insertion de suggestions IA
  const handleAISuggestion = (suggestion: string) => {
    if (editor) {
      editor.chain().focus().insertContent(suggestion).run();
    }
  };

  // Gestion d'upload d'image (ex: via URL)
  const handleImageUpload = (url: string) => {
    if (editor) {
      editor.chain().focus().setImage({ src: url }).run();
    }
  };

  if (!editor) {
    return null;
  }

  return (
    <div className="space-y-4">
      {/* Barre d'outils */}
      <div className="w-full border rounded-lg overflow-hidden dark:border-gray-700">
        <MenuBar editor={editor} />
        {/* Zone pour upload direct (bouton) */}
        <div className="border-t dark:border-gray-700">
          <ImageUpload onUpload={handleImageUpload} />
        </div>
        {/* Zone d'édition */}
        <div className="border-t dark:border-gray-700">
          <EditorContent editor={editor} />
        </div>
      </div>

      {/* Assistant IA */}
      <div className="border-t pt-4 dark:border-gray-700">
        <h3 className="text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
          Assistant IA
        </h3>
        <AIAssistant onSuggestion={handleAISuggestion} />
      </div>
    </div>
  );
};

/* ------------------------------------------------------------------
   5) Composant "RichTextEditor" final
   => C'est celui que vous importez dans vos pages
------------------------------------------------------------------ */
const RichTextEditor = ({
  content,
  onChange,
  onPublish,
  showPublishOptions = true,
}: RichTextEditorProps) => {
  // On importe dynamiquement RichTextEditorContent si on veut le SSR: false
  // Mais ici, tout est dans le même fichier ; vous n’avez plus besoin du dynamic import
  // (ou vous pouvez l'utiliser comme avant, si vous voulez).
  // Pour la démo, on ne fait pas de dynamic import supplémentaire.

  return (
    <div className="space-y-4">
      {/* L'éditeur */}
      <div>
        <RichTextEditorContent
          value={content}
          onChange={onChange}
        />
      </div>

      {/* Options de publication (facultatif) */}
      {showPublishOptions && onPublish && (
        <div className="mt-4 space-y-4">
          <div className="flex justify-end">
            <button
              onClick={() => onPublish([])}
              className="px-4 py-2 bg-primary text-white rounded-lg hover:bg-primary/90"
            >
              Publier sur les plateformes sélectionnées
            </button>
          </div>
        </div>
      )}
    </div>
  );
};

export default RichTextEditor;


================================================================================

===== C:\wamp64\www\75Tribune\src\components\editor\RichTextEditorContent.tsx =====

import { useEditor, EditorContent } from '@tiptap/react';
import StarterKit from '@tiptap/starter-kit';
import Image from '@tiptap/extension-image';
import Link from '@tiptap/extension-link';
import { CodeBlockLowlight } from '@tiptap/extension-code-block-lowlight';
import { common, createLowlight } from 'lowlight';
import { Copy, Check } from 'lucide-react';
import TextAlign from '@tiptap/extension-text-align';
import Placeholder from '@tiptap/extension-placeholder';
import Typography from '@tiptap/extension-typography';
import Highlight from '@tiptap/extension-highlight';
import Color from '@tiptap/extension-color';
import TextStyle from '@tiptap/extension-text-style';
import Underline from '@tiptap/extension-underline';
import Superscript from '@tiptap/extension-superscript';
import Subscript from '@tiptap/extension-subscript';
import Table from '@tiptap/extension-table';
import TableRow from '@tiptap/extension-table-row';
import TableCell from '@tiptap/extension-table-cell';
import TableHeader from '@tiptap/extension-table-header';

import {
  Bold,
  Italic,
  List,
  ListOrdered,
  Quote,
  Link as LinkIcon,
  Image as ImageIcon,
  Code,
  Undo,
  Redo,
  Sparkles,
  Loader2,
  AlignLeft,
  AlignCenter,
  AlignRight,
  AlignJustify,
  Underline as UnderlineIcon,
  Table as TableIcon,
} from 'lucide-react';
import {
  useState, useEffect, useCallback
} from 'react';

interface RichTextEditorProps {
  value: string;
  onChange: (content: string) => void;
}

const AI_MODELS = [
  { id: 'codellama:latest', name: 'Code Llama (Latest)' },
  { id: 'codellama:13b', name: 'Code Llama (13B)' },
  { id: 'qwen2.5-coder:14b', name: 'Qwen 2.5 Coder (14B)' },
  { id: 'mixtral:8x7b', name: 'Mixtral 8x7B' },
  { id: 'qwen2.5:7b', name: 'Qwen 2.5 (7B)' },
  { id: 'llama3:latest', name: 'LLaMA 3 (Latest)' },
  { id: 'llama3.2:latest', name: 'LLaMA 3.2 (Latest)' },
  { id: 'llava:34b', name: 'LLaVA 34B' },
  { id: 'deepseek-r1:14b', name: 'DeepSeek R1 (14B)' },
  { id: 'nomic-embed-text:latest', name: 'Nomic Embed Text' }
];

const TONES = [
  { id: 'professional', name: 'Professionnel' },
  { id: 'friendly', name: 'Amical' },
  { id: 'informative', name: 'Informatif' },
  { id: 'humorous', name: 'Humoristique' },
  { id: 'motivational', name: 'Motivant' },
  { id: 'empathetic', name: 'Empathique' },
  { id: 'direct', name: 'Direct' },
  { id: 'creative', name: 'Créatif' },
  { id: 'serious', name: 'Sérieux' },
  { id: 'optimistic', name: 'Optimiste' },
  { id: 'enthusiastic', name: 'Enthousiaste' },
  { id: 'persuasive', name: 'Persuasif' },
  { id: 'neutral', name: 'Neutre' },
  { id: 'strict', name: 'Sévère' },
  { id: 'sincere', name: 'Sincère' },
  { id: 'romantic', name: 'Romantique' },
  { id: 'poetic', name: 'Poétique' },
  { id: 'playful', name: 'Ludique' },
  { id: 'inspiring', name: 'Inspirant' },
  { id: 'ironic', name: 'Ironique' },
  { id: 'sarcastic', name: 'Sarcastique' },
  { id: 'mysterious', name: 'Mystérieux' },
  { id: 'nostalgic', name: 'Nostalgique' },
  { id: 'authoritative', name: 'Autoritaire' },
  { id: 'benevolent', name: 'Bienveillant' },
  { id: 'academic', name: 'Académique' },
  { id: 'technical', name: 'Technique' },
  { id: 'exaggerated', name: 'Exagéré' },
  { id: 'provocative', name: 'Provocateur' },
  { id: 'thoughtful', name: 'Réfléchi' },
];

// Liste des langages supportés par Prism
const SUPPORTED_LANGUAGES = {
  markup: 'HTML',
  html: 'HTML',
  xml: 'XML',
  svg: 'SVG',
  mathml: 'MathML',
  ssml: 'SSML',
  atom: 'ATOM',
  rss: 'RSS',
  css: 'CSS',
  clike: 'C-like',
  javascript: 'JavaScript',
  js: 'JavaScript',
  jsx: 'JSX',
  typescript: 'TypeScript',
  ts: 'TypeScript',
  tsx: 'TSX',
  php: 'PHP',
  python: 'Python',
  py: 'Python',
  ruby: 'Ruby',
  rb: 'Ruby',
  go: 'Go',
  rust: 'Rust',
  sql: 'SQL',
  bash: 'Bash',
  shell: 'Shell',
  json: 'JSON',
  yaml: 'YAML',
  yml: 'YAML',
  markdown: 'Markdown',
  md: 'Markdown',
} as const;

// Fonction pour normaliser le langage
function normalizeLanguage(lang: string): string {
  // Enlever le préfixe 'language-' s'il existe
  const cleanLang = lang.replace(/^language-/, '').toLowerCase();
  
  // Correspondances spécifiques
  const languageMap: { [key: string]: string } = {
    js: 'javascript',
    py: 'python',
    rb: 'ruby',
    ts: 'typescript',
    yml: 'yaml',
    md: 'markdown',
    html: 'markup',
    xml: 'markup',
    svg: 'markup',
    mathml: 'markup',
    ssml: 'markup',
    atom: 'markup',
    rss: 'markup'
  };

  return languageMap[cleanLang] || cleanLang;
}

// Extension personnalisée pour les blocs de code
const lowlight = createLowlight(common);

const CustomCodeBlock = CodeBlockLowlight.extend({
  addAttributes() {
    return {
      ...this.parent?.(),
      language: {
        default: 'text',
        parseHTML: element => {
          // Essayer de détecter le langage à partir de la classe
          const codeElement = element.querySelector('code');
          if (codeElement) {
            const classes = codeElement.className.split(' ');
            for (const cls of classes) {
              if (cls.startsWith('language-')) {
                const lang = cls.replace('language-', '');
                const normalizedLang = normalizeLanguage(lang);
                return normalizedLang;
              }
            }
          }
          
          // Si aucun langage n'est spécifié, essayer de détecter à partir du contenu
          const content = element.textContent || '';
          
          // Détection basée sur le contenu
          if (content.includes('def ') || content.includes('import ') || content.match(/:\s*$/m)) {
            return 'python';
          }
          if (content.includes('function ') || content.includes('const ') || content.includes('let ') || content.match(/=>/)) {
            return 'javascript';
          }
          if (content.includes('interface ') || content.includes('type ') || content.includes(': ')) {
            return 'typescript';
          }
          if (content.match(/<\/?[a-z][\s\S]*>/i)) {
            return 'html';
          }
          if (content.includes('SELECT ') || content.includes('FROM ') || content.includes('WHERE ')) {
            return 'sql';
          }
          if (content.match(/^[\s\S]*\{[\s\S]*\}[\s\S]*$/)) {
            return 'json';
          }
          if (content.startsWith('<?php')) {
            return 'php';
          }
          
          return 'text';
        },
        renderHTML: attributes => {
          return {
            'data-language': attributes.language,
          };
        },
      },
    };
  },
  addNodeView() {
    return ({ node, editor }) => {
      const container = document.createElement('div');
      container.className = 'not-prose my-8 overflow-hidden rounded-lg border border-gray-700 dark:bg-gray-900';

      // En-tête avec le nom du langage et le bouton copier
      const header = document.createElement('div');
      header.className = 'flex items-center justify-between px-4 py-2 text-xs text-gray-400 border-b border-gray-700';
      
      const lang = node.attrs.language || 'text';
      const normalizedLang = normalizeLanguage(lang);
      const displayLang = SUPPORTED_LANGUAGES[normalizedLang as keyof typeof SUPPORTED_LANGUAGES] || lang.toUpperCase();
      
      // Affichage du langage
      const langDisplay = document.createElement('span');
      langDisplay.className = 'font-mono';
      langDisplay.textContent = displayLang;
      header.appendChild(langDisplay);

      // Bouton de copie
      const copyButton = document.createElement('button');
      copyButton.className = 'flex items-center gap-1 px-2 py-1 rounded hover:bg-gray-700 dark:hover:bg-gray-800 transition-colors';
      copyButton.title = 'Copier le code';
      copyButton.innerHTML = '<svg class="w-3 h-3" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><path d="M8 4H6a2 2 0 00-2 2v12a2 2 0 002 2h8a2 2 0 002-2v-2M8 4v12a2 2 0 002 2h8a2 2 0 002-2V8l-6-4H8z"/></svg><span>Copier</span>';
      
      copyButton.addEventListener('click', () => {
        const code = node.textContent;
        navigator.clipboard.writeText(code).then(() => {
          copyButton.innerHTML = '<svg class="w-3 h-3" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><path d="M20 6L9 17l-5-5"/></svg><span>Copié!</span>';
          setTimeout(() => {
            copyButton.innerHTML = '<svg class="w-3 h-3" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><path d="M8 4H6a2 2 0 00-2 2v12a2 2 0 002 2h8a2 2 0 002-2v-2M8 4v12a2 2 0 002 2h8a2 2 0 002-2V8l-6-4H8z"/></svg><span>Copier</span>';
          }, 2000);
        });
      });
      
      header.appendChild(copyButton);
      container.appendChild(header);

      // Bloc de code
      const pre = document.createElement('pre');
      pre.className = 'p-4 text-sm overflow-x-auto';
      pre.style.margin = '0';
      container.appendChild(pre);

      return {
        dom: container,
        contentDOM: pre,
        update: (updatedNode) => {
          if (updatedNode.type !== node.type) return false;
          
          // Mettre à jour le langage affiché si nécessaire
          const updatedLang = updatedNode.attrs.language || 'text';
          const updatedNormalizedLang = normalizeLanguage(updatedLang);
          const updatedDisplayLang = SUPPORTED_LANGUAGES[updatedNormalizedLang as keyof typeof SUPPORTED_LANGUAGES] || updatedLang.toUpperCase();
          langDisplay.textContent = updatedDisplayLang;
          
          return true;
        },
      };
    };
  },
});

export default function RichTextEditorContent({ value, onChange }: RichTextEditorProps) {
  const [isLoading, setIsLoading] = useState(false);
  const [prompt, setPrompt] = useState('');
  const [selectedModel, setSelectedModel] = useState('mistral');
  const [selectedTone, setSelectedTone] = useState('professional');
  const [showAIOptions, setShowAIOptions] = useState(false);
  const [showFormatOptions, setShowFormatOptions] = useState(false);
  const [selectedTextSize, setSelectedTextSize] = useState('normal');
  const [selectedAlignment, setSelectedAlignment] = useState('left');
  const [selectedSpacing, setSelectedSpacing] = useState('normal');

  const editor = useEditor({
    extensions: [
      StarterKit.configure({
        heading: {
          levels: [1, 2, 3]
        },
        codeBlock: false
      }),
      Image.configure({
        allowBase64: true,
        HTMLAttributes: {
          class: 'rounded-lg max-w-full h-auto'
        }
      }),
      Link.configure({
        HTMLAttributes: {
          class: 'text-blue-500 hover:text-blue-700 underline',
          target: '_blank'
        },
        openOnClick: false
      }),
      CustomCodeBlock.configure({
        lowlight,
        HTMLAttributes: {
          class: 'not-prose'
        }
      }),
      TextAlign.configure({
        types: ['heading', 'paragraph'],
        alignments: ['left', 'center', 'right', 'justify'],
      }),
      Placeholder.configure({
        placeholder: 'Commencez à écrire...',
      }),
      Typography,
      Highlight.configure({
        multicolor: true,
      }),
      Color.configure({
        types: ['textStyle'],
      }),
      TextStyle,
      Underline,
      Superscript,
      Subscript,
      Table.configure({
        resizable: true,
        HTMLAttributes: {
          class: 'border-collapse table-auto w-full',
        },
      }),
      TableRow,
      TableCell,
      TableHeader,
    ],
    content: value,
    onUpdate: ({ editor }) => {
      onChange(editor.getHTML());
    },
    editorProps: {
      attributes: {
        class: 'prose prose-sm sm:prose lg:prose-lg xl:prose-xl dark:prose-invert focus:outline-none max-w-none min-h-[200px] p-4'
      }
    },
  });

  useEffect(() => {
    if (editor && value !== editor.getHTML()) {
      editor.commands.setContent(value);
    }
  }, [editor, value]);

  const setLink = () => {
    const previousUrl = editor?.getAttributes('link').href;
    const url = window.prompt('URL', previousUrl);

    if (url === null) {
      return;
    }

    if (url === '') {
      editor?.chain().focus().extendMarkRange('link').unsetLink().run();
      return;
    }

    editor?.chain().focus().extendMarkRange('link').setLink({ href: url }).run();
  };

  const addImage = () => {
    const url = window.prompt('URL');
    if (url) {
      editor?.chain().focus().setImage({ src: url }).run();
    }
  };

  const addTable = () => {
    editor?.chain().focus().insertTable({ rows: 3, cols: 3, withHeaderRow: true }).run();
  };

  const addCodeBlock = () => {
    const language = window.prompt('Langage (javascript, python, etc...)', 'javascript');
    if (language) {
      editor?.chain().focus().toggleCodeBlock({ language }).run();
    }
  };

  const sizeStyles = {
    small: { fontSize: '14px' },
    normal: { fontSize: '16px' },
    large: { fontSize: '18px' },
    xlarge: { fontSize: '20px' }
  };

  const spacingStyles = {
    tight: { lineHeight: '1.25' },
    normal: { lineHeight: '1.5' },
    relaxed: { lineHeight: '1.75' },
    loose: { lineHeight: '2' }
  };

  const applyFormatting = (type: string, value: string) => {
    if (!editor) return;

    switch (type) {
      case 'size':
        const fontSize = sizeStyles[value as keyof typeof sizeStyles].fontSize;
        editor.chain().focus()
          .unsetMark('textStyle')
          .run();
        editor.chain().focus()
          .setMark('textStyle', { fontSize })
          .run();
        setSelectedTextSize(value);
        break;

      case 'alignment':
        editor.chain().focus().setTextAlign(value as 'left' | 'center' | 'right' | 'justify').run();
        setSelectedAlignment(value);
        break;

      case 'spacing':
        const lineHeight = spacingStyles[value as keyof typeof spacingStyles].lineHeight;
        editor.chain().focus()
          .unsetMark('textStyle')
          .run();
        editor.chain().focus()
          .setMark('textStyle', { lineHeight })
          .run();
        setSelectedSpacing(value);
        break;
    }
  };

  const handleAISuggestion = async () => {
    if (!prompt.trim() || !editor) return;

    setIsLoading(true);
    try {
      const response = await fetch('/api/ollama', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          model: selectedModel,
          prompt: prompt,
          tone: selectedTone,
          context: editor.getHTML(),
        }),
      });

      if (!response.ok) {
        throw new Error('Erreur lors de la génération');
      }

      const data = await response.json();
      
      if (data.content) {
        // Créer une transaction pour l'insertion
        editor.chain()
          .focus()
          .insertContent(data.content)
          .run();
        
        // Afficher les options de mise en page
        setShowFormatOptions(true);
      }
    } catch (error) {
      console.error('Erreur:', error);
    } finally {
      setIsLoading(false);
      setPrompt('');
      setShowAIOptions(false);
    }
  };

  const renderFormatOptions = () => {
    if (!showFormatOptions) return null;

    return (
      <div className="flex flex-wrap gap-4 p-4 bg-gray-50 dark:bg-gray-800 rounded-md shadow-sm">
        <div className="flex flex-col gap-2">
          <label className="text-sm font-medium text-gray-700 dark:text-gray-300">
            Taille du texte
          </label>
          <select
            value={selectedTextSize}
            onChange={(e) => applyFormatting('size', e.target.value)}
            className="block w-full pl-3 pr-10 py-2 text-base border-gray-300 dark:border-gray-600 rounded-md focus:outline-none focus:ring-blue-500 focus:border-blue-500 dark:bg-gray-700 dark:text-white sm:text-sm"
          >
            <option value="small">Petit</option>
            <option value="normal">Normal</option>
            <option value="large">Grand</option>
            <option value="xlarge">Très grand</option>
          </select>
        </div>

        <div className="flex flex-col gap-2">
          <label className="text-sm font-medium text-gray-700 dark:text-gray-300">
            Alignement
          </label>
          <select
            value={selectedAlignment}
            onChange={(e) => applyFormatting('alignment', e.target.value)}
            className="block w-full pl-3 pr-10 py-2 text-base border-gray-300 dark:border-gray-600 rounded-md focus:outline-none focus:ring-blue-500 focus:border-blue-500 dark:bg-gray-700 dark:text-white sm:text-sm"
          >
            <option value="left">Gauche</option>
            <option value="center">Centre</option>
            <option value="right">Droite</option>
            <option value="justify">Justifié</option>
          </select>
        </div>

        <div className="flex flex-col gap-2">
          <label className="text-sm font-medium text-gray-700 dark:text-gray-300">
            Espacement
          </label>
          <select
            value={selectedSpacing}
            onChange={(e) => applyFormatting('spacing', e.target.value)}
            className="block w-full pl-3 pr-10 py-2 text-base border-gray-300 dark:border-gray-600 rounded-md focus:outline-none focus:ring-blue-500 focus:border-blue-500 dark:bg-gray-700 dark:text-white sm:text-sm"
          >
            <option value="tight">Serré</option>
            <option value="normal">Normal</option>
            <option value="relaxed">Détendu</option>
            <option value="loose">Large</option>
          </select>
        </div>
      </div>
    );
  };

  if (!editor) {
    return null;
  }

  return (
    <div className="flex flex-col gap-4">
      <div className="flex flex-col gap-4">
        <div className="flex items-center gap-2">
          <input
            type="text"
            value={prompt}
            onChange={(e) => setPrompt(e.target.value)}
            placeholder="Que souhaitez-vous générer ?"
            className="flex-1 px-4 py-3 text-base border-gray-300 dark:border-gray-600 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500 dark:bg-gray-700 dark:text-white transition-colors duration-200"
          />
          <button
            type="button"
            onClick={() => setShowAIOptions(!showAIOptions)}
            className="inline-flex items-center px-3 py-1.5 text-sm font-medium rounded-md text-blue-600 dark:text-blue-400 hover:text-blue-700 dark:hover:text-blue-300 hover:bg-blue-50 dark:hover:bg-blue-900/50 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500 dark:focus:ring-offset-gray-800 transition-colors duration-200"
          >
            {showAIOptions ? 'Masquer les options' : 'Afficher les options'}
          </button>
          <button
            type="button"
            onClick={handleAISuggestion}
            disabled={isLoading || !prompt.trim()}
            className={`inline-flex items-center px-6 py-3 text-base font-medium rounded-md text-white ${
              isLoading || !prompt.trim()
                ? 'bg-gray-400 cursor-not-allowed'
                : 'bg-blue-600 hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500'
            } transition-colors duration-200`}
          >
            {isLoading ? (
              <>
                <svg className="animate-spin -ml-1 mr-3 h-5 w-5 text-white" xmlns="http://www.w3.org/2000/svg" fill="none" stroke="currentColor" strokeWidth="2"><circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle><path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path></svg>
                Génération en cours...
              </>
            ) : (
              'Générer'
            )}
          </button>
        </div>

        {showAIOptions && (
          <div className="grid grid-cols-1 md:grid-cols-2 gap-4 p-4 bg-gray-50/50 dark:bg-gray-800/50 rounded-md border border-gray-100 dark:border-gray-700/50 backdrop-blur-sm">
            <div>
              <label htmlFor="model" className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
                Modèle
              </label>
              <select
                id="model"
                value={selectedModel}
                onChange={(e) => setSelectedModel(e.target.value)}
                className="block w-full pl-3 pr-10 py-2 text-base border-gray-300 dark:border-gray-600 bg-white dark:bg-gray-700 text-gray-900 dark:text-gray-100 focus:outline-none focus:ring-2 focus:ring-blue-500 dark:focus:ring-blue-400 focus:border-blue-500 dark:focus:border-blue-400 sm:text-sm rounded-md transition-colors duration-200"
              >
                {AI_MODELS.map((model) => (
                  <option key={model.id} value={model.id} className="dark:bg-gray-700">
                    {model.name}
                  </option>
                ))}
              </select>
            </div>

            <div>
              <label htmlFor="tone" className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
                Ton
              </label>
              <select
                id="tone"
                value={selectedTone}
                onChange={(e) => setSelectedTone(e.target.value)}
                className="block w-full pl-3 pr-10 py-2 text-base border-gray-300 dark:border-gray-600 bg-white dark:bg-gray-700 text-gray-900 dark:text-gray-100 focus:outline-none focus:ring-2 focus:ring-blue-500 dark:focus:ring-blue-400 focus:border-blue-500 dark:focus:border-blue-400 sm:text-sm rounded-md transition-colors duration-200"
              >
                {TONES.map((tone) => (
                  <option key={tone.id} value={tone.id} className="dark:bg-gray-700">
                    {tone.name}
                  </option>
                ))}
              </select>
            </div>
          </div>
        )}

        {renderFormatOptions()}
      </div>

      <div className="border rounded-lg p-4">
        <div className="border-b border-gray-200 p-2 mb-4 flex flex-wrap gap-2">
          {/* Styles de texte basiques */}
          <div className="flex items-center gap-1">
            <button
              type="button"
              onClick={() => editor.chain().focus().toggleBold().run()}
              className={`p-2 rounded hover:bg-gray-100 ${
                editor.isActive('bold') ? 'bg-gray-100' : ''
              }`}
              title="Gras (Ctrl+B)"
            >
              <Bold className="w-5 h-5" />
            </button>
            <button
              type="button"
              onClick={() => editor.chain().focus().toggleItalic().run()}
              className={`p-2 rounded hover:bg-gray-100 ${
                editor.isActive('italic') ? 'bg-gray-100' : ''
              }`}
              title="Italique (Ctrl+I)"
            >
              <Italic className="w-5 h-5" />
            </button>
            <button
              type="button"
              onClick={() => editor.chain().focus().toggleUnderline().run()}
              className={`p-2 rounded hover:bg-gray-100 ${
                editor.isActive('underline') ? 'bg-gray-100' : ''
              }`}
              title="Souligné (Ctrl+U)"
            >
              <UnderlineIcon className="w-5 h-5" />
            </button>
          </div>

          <div className="w-px h-6 bg-gray-200" />

          {/* Alignement */}
          <div className="flex items-center gap-1">
            <button
              type="button"
              onClick={() => editor.chain().focus().setTextAlign('left').run()}
              className={`p-2 rounded hover:bg-gray-100 ${
                editor.isActive({ textAlign: 'left' }) ? 'bg-gray-100' : ''
              }`}
              title="Aligner à gauche"
            >
              <AlignLeft className="w-5 h-5" />
            </button>
            <button
              type="button"
              onClick={() => editor.chain().focus().setTextAlign('center').run()}
              className={`p-2 rounded hover:bg-gray-100 ${
                editor.isActive({ textAlign: 'center' }) ? 'bg-gray-100' : ''
              }`}
              title="Centrer"
            >
              <AlignCenter className="w-5 h-5" />
            </button>
            <button
              type="button"
              onClick={() => editor.chain().focus().setTextAlign('right').run()}
              className={`p-2 rounded hover:bg-gray-100 ${
                editor.isActive({ textAlign: 'right' }) ? 'bg-gray-100' : ''
              }`}
              title="Aligner à droite"
            >
              <AlignRight className="w-5 h-5" />
            </button>
            <button
              type="button"
              onClick={() => editor.chain().focus().setTextAlign('justify').run()}
              className={`p-2 rounded hover:bg-gray-100 ${
                editor.isActive({ textAlign: 'justify' }) ? 'bg-gray-100' : ''
              }`}
              title="Justifier"
            >
              <AlignJustify className="w-5 h-5" />
            </button>
          </div>

          <div className="w-px h-6 bg-gray-200" />

          {/* Listes */}
          <div className="flex items-center gap-1">
            <button
              type="button"
              onClick={() => editor.chain().focus().toggleBulletList().run()}
              className={`p-2 rounded hover:bg-gray-100 ${
                editor.isActive('bulletList') ? 'bg-gray-100' : ''
              }`}
              title="Liste à puces"
            >
              <List className="w-5 h-5" />
            </button>
            <button
              type="button"
              onClick={() => editor.chain().focus().toggleOrderedList().run()}
              className={`p-2 rounded hover:bg-gray-100 ${
                editor.isActive('orderedList') ? 'bg-gray-100' : ''
              }`}
              title="Liste numérotée"
            >
              <ListOrdered className="w-5 h-5" />
            </button>
          </div>

          <div className="w-px h-6 bg-gray-200" />

          {/* Éléments spéciaux */}
          <div className="flex items-center gap-1">
            <button
              type="button"
              onClick={() => editor.chain().focus().toggleBlockquote().run()}
              className={`p-2 rounded hover:bg-gray-100 ${
                editor.isActive('blockquote') ? 'bg-gray-100' : ''
              }`}
              title="Citation"
            >
              <Quote className="w-5 h-5" />
            </button>
            <button
              type="button"
              onClick={setLink}
              className={`p-2 rounded hover:bg-gray-100 ${
                editor.isActive('link') ? 'bg-gray-100' : ''
              }`}
              title="Lien"
            >
              <LinkIcon className="w-5 h-5" />
            </button>
            <button
              type="button"
              onClick={addImage}
              className="p-2 rounded hover:bg-gray-100"
              title="Image"
            >
              <ImageIcon className="w-5 h-5" />
            </button>
            <button
              type="button"
              onClick={addTable}
              className={`p-2 rounded hover:bg-gray-100 ${
                editor.isActive('table') ? 'bg-gray-100' : ''
              }`}
              title="Tableau"
            >
              <TableIcon className="w-5 h-5" />
            </button>
            <button
              type="button"
              onClick={addCodeBlock}
              className={`p-2 rounded hover:bg-gray-100 ${
                editor.isActive('codeBlock') ? 'bg-gray-100' : ''
              }`}
              title="Bloc de code"
            >
              <Code className="w-5 h-5" />
            </button>
          </div>

          <div className="w-px h-6 bg-gray-200" />

          {/* Annuler/Rétablir */}
          <div className="flex items-center gap-1">
            <button
              type="button"
              onClick={() => editor.chain().focus().undo().run()}
              disabled={!editor.can().undo()}
              className="p-2 rounded hover:bg-gray-100 disabled:opacity-50"
              title="Annuler (Ctrl+Z)"
            >
              <Undo className="w-5 h-5" />
            </button>
            <button
              type="button"
              onClick={() => editor.chain().focus().redo().run()}
              disabled={!editor.can().redo()}
              className="p-2 rounded hover:bg-gray-100 disabled:opacity-50"
              title="Rétablir (Ctrl+Y)"
            >
              <Redo className="w-5 h-5" />
            </button>
          </div>
        </div>

        <EditorContent editor={editor} />
      </div>
    </div>
  );
}


================================================================================

===== C:\wamp64\www\75Tribune\src\components\layout\user-nav.tsx =====

'use client';

import { useSession, signOut } from 'next-auth/react';
import Link from 'next/link';
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuLabel,
  DropdownMenuSeparator,
  DropdownMenuTrigger,
} from '@/components/ui/dropdown-menu';
import { Avatar } from '@/components/ui/avatar';
import { Button } from '@/components/ui/button';

export function UserNav() {
  const { data: session } = useSession();

  if (!session) {
    return (
      <div className="flex items-center gap-2">
        <Link href="/login">
          <Button variant="ghost">Connexion</Button>
        </Link>
        <Link href="/register">
          <Button>Inscription</Button>
        </Link>
      </div>
    );
  }

  return (
    <DropdownMenu>
      <DropdownMenuTrigger asChild>
        <Button variant="ghost" className="relative h-10 w-10 rounded-full">
          <Avatar
            src={session.user.avatar}
            name={session.user.name}
            size="md"
          />
        </Button>
      </DropdownMenuTrigger>
      <DropdownMenuContent className="w-56" align="end">
        <DropdownMenuLabel>
          <div className="flex flex-col space-y-1">
            <p className="text-sm font-medium leading-none">{session.user.name}</p>
            <p className="text-xs leading-none text-muted-foreground">
              {session.user.email}
            </p>
          </div>
        </DropdownMenuLabel>
        <DropdownMenuSeparator />
        <DropdownMenuItem asChild>
          <Link href="/profile">
            Profil
          </Link>
        </DropdownMenuItem>
        {session.user.role === 'ADMIN' && (
          <DropdownMenuItem asChild>
            <Link href="/dashboard">
              Dashboard
            </Link>
          </DropdownMenuItem>
        )}
        <DropdownMenuSeparator />
        <DropdownMenuItem
          className="text-red-600 cursor-pointer"
          onClick={() => signOut()}
        >
          Déconnexion
        </DropdownMenuItem>
      </DropdownMenuContent>
    </DropdownMenu>
  );
}


================================================================================

===== C:\wamp64\www\75Tribune\src\components\navigation\CategoryDropdown.tsx =====

'use client';

import React, { useEffect, useState } from 'react';
import Link from 'next/link';
import { ChevronDown } from 'lucide-react';
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuTrigger,
} from '@/components/ui/dropdown-menu';

interface Category {
  id: string;
  name: string;
  slug: string;
}

export default function CategoryDropdown() {
  const [categories, setCategories] = useState<Category[]>([]);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    // Appel API pour récupérer les catégories
    const fetchCategories = async () => {
      try {
        const response = await fetch('/api/categories');
        if (response.ok) {
          const data = await response.json();
          setCategories(data);
        }
      } catch (error) {
        console.error('Erreur lors de la récupération des catégories :', error);
      } finally {
        setLoading(false);
      }
    };
    fetchCategories();
  }, []);

  if (loading) {
    // Bouton inactif "Catégories" pendant le chargement
    return (
      <div className="nav-link">
        <span>Catégories</span>
      </div>
    );
  }

  return (
    <DropdownMenu>
      <DropdownMenuTrigger className="nav-link inline-flex items-center">
        <span>Catégories</span>
        <ChevronDown className="ml-1 h-4 w-4" />
      </DropdownMenuTrigger>
      <DropdownMenuContent align="start" className="bg-nyt-white dark:bg-nyt-black">
        {categories.length > 0 ? (
          categories.map((category) => (
            <DropdownMenuItem key={category.id} asChild>
              <Link href={`/categories/${category.slug}`}>
                {category.name}
              </Link>
            </DropdownMenuItem>
          ))
        ) : (
          <DropdownMenuItem disabled>
            Aucune catégorie
          </DropdownMenuItem>
        )}
      </DropdownMenuContent>
    </DropdownMenu>
  );
}


================================================================================

===== C:\wamp64\www\75Tribune\src\components\navigation\Navigation.tsx =====

'use client';

import Link from 'next/link';
import { usePathname } from 'next/navigation';
import { Menu, X, User, Settings, LayoutDashboard } from 'lucide-react';
import { useState, useEffect } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import { ThemeToggle } from '@/components/ui/ThemeToggle';
import { useAuth } from '@/providers/AuthProvider';
import LogoutButton from '@/components/LogoutButton';
import NotificationDropdown from '@/components/notifications/NotificationDropdown';
import CategoryDropdown from '@/components/navigation/CategoryDropdown';
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuLabel,
  DropdownMenuSeparator,
  DropdownMenuTrigger,
} from '@/components/ui/dropdown-menu';
import { Avatar, AvatarFallback, AvatarImage } from '@/components/ui/avatar';
import { Button } from '@/components/ui/button';
import { cn } from '@/lib/utils';
import { useSession } from 'next-auth/react';

export default function Navigation() {
  const [isOpen, setIsOpen] = useState(false);
  const [scrolled, setScrolled] = useState(false);
  const pathname = usePathname();
  const { data: session } = useSession();

  // Effet pour ajouter un fond à la nav quand on scroll
  useEffect(() => {
    const handleScroll = () => {
      setScrolled(window.scrollY > 20);
    };
    window.addEventListener('scroll', handleScroll);
    return () => window.removeEventListener('scroll', handleScroll);
  }, []);

  const isActive = (path: string) => pathname === path;

  // Items de menu personnalisés selon le rôle
  const userNavItems = [
    ...(session?.user?.role === 'ADMIN' 
      ? [{ href: '/dashboard', label: 'Dashboard', icon: LayoutDashboard }] 
      : []),
    { href: '/profile',  label: 'Profile',   icon: User },
    { href: '/settings', label: 'Settings', icon: Settings },
  ];

  return (
    <nav className={cn(
      'fixed top-0 left-0 right-0 z-50 transition-all duration-200',
      scrolled 
        ? 'bg-nyt-white/80 dark:bg-nyt-black/80 backdrop-blur-sm border-b shadow-sm' 
        : 'bg-nyt-white/0 dark:bg-nyt-black/0'
    )}>
      <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
        <div className="flex justify-between h-16">
          {/* Logo / Titre du site */}
          <div className="flex items-center">
            <Link href="/" className="flex items-center">
              <motion.span 
                initial={{ opacity: 0, x: -20 }}
                animate={{ opacity: 1, x: 0 }}
                transition={{ duration: 0.5 }}
                className="text-xl font-bold bg-gradient-to-r from-nyt-blue to-blue-600 bg-clip-text text-transparent"
              >
                75Tribune
              </motion.span>
            </Link>
            {/* Liens de navigation principaux (desktop) */}
            <div className="hidden sm:ml-8 sm:flex sm:space-x-1">
              {['/', '/articles'].map((path) => (
                <motion.div
                  key={path}
                  whileHover={{ scale: 1.05 }}
                  whileTap={{ scale: 0.95 }}
                >
                  <Link
                    href={path}
                    className={cn(
                      'nav-link font-body',
                      isActive(path) && 'text-nyt-blue',
                      scrolled && 'text-nyt-black dark:text-nyt-white'
                    )}
                  >
                    {path === '/' ? 'Accueil' : 'Articles'}
                  </Link>
                </motion.div>
              ))}
              <CategoryDropdown />
            </div>
          </div>

          {/* Section de droite: thème, notifications, profil/connexion */}
          <div className="hidden sm:flex sm:items-center sm:space-x-3">
            <div className="flex items-center space-x-4">
              <ThemeToggle />
              {session?.user ? (
                <>
                  <NotificationDropdown />
                  {/* Menu déroulant utilisateur */}
                  <DropdownMenu>
                    <DropdownMenuTrigger asChild>
                      <Button variant="ghost" className="relative h-8 w-8 rounded-full">
                        <Avatar className="h-8 w-8">
                          <AvatarImage src={session.user.avatar || '/uploads/avatars/default-avatar.png'} alt={session.user.name || ''} />
                          <AvatarFallback>{session.user.name?.charAt(0) || 'U'}</AvatarFallback>
                        </Avatar>
                      </Button>
                    </DropdownMenuTrigger>
                    <DropdownMenuContent className="w-56 bg-nyt-white dark:bg-nyt-black" align="end" forceMount>
                      <DropdownMenuLabel className="font-normal">
                        <div className="flex flex-col space-y-1">
                          <p className="text-sm font-medium leading-none text-nyt-black dark:text-nyt-white font-body">
                            {session.user.name}
                          </p>
                          <p className="text-xs leading-none text-nyt-gray-500 dark:text-nyt-gray-200 font-body">
                            {session.user.email}
                          </p>
                        </div>
                      </DropdownMenuLabel>
                      <DropdownMenuSeparator />
                      {userNavItems.map((item) => (
                        <DropdownMenuItem key={item.href} asChild>
                          <Link href={item.href} className="flex items-center text-nyt-black dark:text-nyt-white font-body">
                            <item.icon className="mr-2 h-4 w-4" />
                            <span>{item.label}</span>
                          </Link>
                        </DropdownMenuItem>
                      ))}
                      <DropdownMenuSeparator />
                      <DropdownMenuItem>
                        <LogoutButton />
                      </DropdownMenuItem>
                    </DropdownMenuContent>
                  </DropdownMenu>
                </>
              ) : (
                <>
                  <Link href="/login" className="nav-button-secondary text-nyt-black dark:text-nyt-white font-body">
                    Connexion
                  </Link>
                  <Link href="/register" className="nav-button-primary text-nyt-white font-body">
                    Inscription
                  </Link>
                </>
              )}
            </div>
          </div>

          {/* Boutons menu et icônes (mobile) */}
          <div className="flex items-center sm:hidden space-x-2">
            <ThemeToggle />
            {session?.user && <NotificationDropdown />}
            <button
              onClick={() => setIsOpen(!isOpen)}
              className="nav-button-secondary p-2 text-nyt-black dark:text-nyt-white"
            >
              <span className="sr-only">Ouvrir le menu</span>
              {isOpen ? (
                <X className="h-5 w-5" aria-hidden="true" />
              ) : (
                <Menu className="h-5 w-5" aria-hidden="true" />
              )}
            </button>
          </div>
        </div>
      </div>

      {/* Menu déroulant mobile avec animation */}
      <AnimatePresence>
        {isOpen && (
          <motion.div
            initial={{ opacity: 0, y: -20 }}
            animate={{ opacity: 1, y: 0 }}
            exit={{ opacity: 0, y: -20 }}
            transition={{ duration: 0.3 }}
            className="sm:hidden absolute left-4 right-4 top-20 rounded-lg overflow-hidden bg-nyt-white/95 dark:bg-nyt-black/95 backdrop-blur supports-[backdrop-filter]:bg-nyt-white/60 dark:supports-[backdrop-filter]:bg-nyt-black/60 border shadow-lg"
          >
            <div className="p-4 space-y-3">
              <Link
                href="/"
                className={cn('nav-link mobile-nav-link font-body', isActive('/') && 'text-nyt-blue')}
                onClick={() => setIsOpen(false)}
              >
                Accueil
              </Link>
              <Link
                href="/categories"
                className={cn('nav-link mobile-nav-link font-body', isActive('/categories') && 'text-nyt-blue')}
                onClick={() => setIsOpen(false)}
              >
                Catégories
              </Link>
              <Link
                href="/articles"
                className={cn('nav-link mobile-nav-link font-body', isActive('/articles') && 'text-nyt-blue')}
                onClick={() => setIsOpen(false)}
              >
                Articles
              </Link>

              {session?.user && (
                <div className="pt-4 pb-3 border-t border-nyt-gray-300 dark:border-nyt-gray-500">
                  <div className="flex items-center px-4">
                    <div className="flex-shrink-0">
                      <Avatar>
                        <AvatarImage src={session.user.avatar || '/uploads/avatars/default-avatar.png'} alt={session.user.name || ''} />
                        <AvatarFallback>{session.user.name?.charAt(0) || 'U'}</AvatarFallback>
                      </Avatar>
                    </div>
                    <div className="ml-3">
                      <p className="text-base font-medium text-nyt-black dark:text-nyt-white font-body">{session.user.name}</p>
                      <p className="text-sm font-medium text-nyt-gray-500 dark:text-nyt-gray-200 font-body">{session.user.email}</p>
                    </div>
                  </div>
                  <div className="mt-3 space-y-1">
                    {userNavItems.map((item) => (
                      <Link
                        key={item.href}
                        href={item.href}
                        className="flex items-center px-4 py-2 text-base hover:bg-nyt-gray-100 dark:hover:bg-nyt-gray-500 text-nyt-black dark:text-nyt-white font-body"
                        onClick={() => setIsOpen(false)}
                      >
                        <item.icon className="mr-3 h-5 w-5" />
                        {item.label}
                      </Link>
                    ))}
                    <div className="px-4 py-2">
                      <LogoutButton />
                    </div>
                  </div>
                </div>
              )}

              {!session?.user && (
                <div className="pt-4 pb-3 border-t border-nyt-gray-300 dark:border-nyt-gray-500">
                  <Link 
                    href="/login" 
                    className="block px-4 py-2 text-base text-nyt-black dark:text-nyt-white hover:bg-nyt-gray-100 dark:hover:bg-nyt-gray-500 font-body"
                    onClick={() => setIsOpen(false)}
                  >
                    Connexion
                  </Link>
                  <Link 
                    href="/register" 
                    className="block px-4 py-2 text-base text-nyt-black dark:text-nyt-white hover:bg-nyt-gray-100 dark:hover:bg-nyt-gray-500 font-body"
                    onClick={() => setIsOpen(false)}
                  >
                    Inscription
                  </Link>
                </div>
              )}
            </div>
          </motion.div>
        )}
      </AnimatePresence>
    </nav>
  );
}

================================================================================

===== C:\wamp64\www\75Tribune\src\components\notifications\NotificationDropdown.tsx =====

'use client';

import { useEffect, useState } from 'react';
import { Bell } from 'lucide-react';
import Link from 'next/link';
import { useSession } from 'next-auth/react';
import { format } from 'date-fns';
import { fr } from 'date-fns/locale';

interface Notification {
  id: string;
  type: 'COMMENT_REPLY' | 'NEW_COMMENT';
  content: string;
  isRead: boolean;
  createdAt: string;
  articleId?: string;
  article?: {
    id: string;
    title: string;
    slug: string;
  };
}

export default function NotificationDropdown() {
  const { data: session } = useSession();
  const [notifications, setNotifications] = useState<Notification[]>([]);
  const [isOpen, setIsOpen] = useState(false);
  const [unreadCount, setUnreadCount] = useState(0);

  useEffect(() => {
    if (session) {
      fetchNotifications();
      // Rafraîchir les notifications toutes les minutes
      const interval = setInterval(fetchNotifications, 60000);
      return () => clearInterval(interval);
    }
  }, [session]);

  const fetchNotifications = async () => {
    try {
      const response = await fetch('/api/notifications');
      if (response.ok) {
        const data = await response.json();
        setNotifications(data);
        setUnreadCount(data.filter((n: Notification) => !n.isRead).length);
      }
    } catch (error) {
      console.error('Erreur lors de la récupération des notifications:', error);
    }
  };

  const markAsRead = async (id: string) => {
    try {
      const response = await fetch(`/api/notifications?id=${id}`, {
        method: 'PATCH',
      });
      if (response.ok) {
        setNotifications((prev) =>
          prev.map((n) =>
            n.id === id ? { ...n, isRead: true } : n
          )
        );
        setUnreadCount((prev) => Math.max(0, prev - 1));
      }
    } catch (error) {
      console.error('Erreur lors du marquage de la notification:', error);
    }
  };

  if (!session) return null;

  return (
    <div className="relative">
      <button
        onClick={() => setIsOpen(!isOpen)}
        className="relative p-2 text-gray-600 hover:text-gray-800 dark:text-gray-300 dark:hover:text-gray-100"
      >
        <Bell className="h-6 w-6" />
        {unreadCount > 0 && (
          <span className="absolute top-0 right-0 inline-flex items-center justify-center px-2 py-1 text-xs font-bold leading-none text-white transform translate-x-1/2 -translate-y-1/2 bg-red-600 rounded-full">
            {unreadCount}
          </span>
        )}
      </button>

      {isOpen && (
        <div className="absolute right-0 mt-2 w-80 bg-white dark:bg-gray-800 rounded-lg shadow-lg overflow-hidden z-50">
          <div className="p-4 border-b dark:border-gray-700">
            <h3 className="text-lg font-semibold">Notifications</h3>
          </div>

          <div className="max-h-96 overflow-y-auto">
            {notifications.length > 0 ? (
              notifications.map((notification) => (
                <div
                  key={notification.id}
                  className={`p-4 border-b dark:border-gray-700 ${
                    !notification.isRead
                      ? 'bg-blue-50 dark:bg-blue-900/20'
                      : ''
                  }`}
                >
                  <Link
                    href={`/articles/${notification.article?.slug}`}
                    onClick={() => {
                      if (!notification.isRead) {
                        markAsRead(notification.id);
                      }
                      setIsOpen(false);
                    }}
                    className="block hover:bg-gray-50 dark:hover:bg-gray-700/50 -m-4 p-4"
                  >
                    <p className="text-sm text-gray-800 dark:text-gray-200">
                      {notification.content}
                    </p>
                    <p className="text-xs text-gray-500 dark:text-gray-400 mt-1">
                      {format(new Date(notification.createdAt), 'dd MMMM yyyy à HH:mm', {
                        locale: fr,
                      })}
                    </p>
                  </Link>
                </div>
              ))
            ) : (
              <div className="p-4 text-center text-gray-500 dark:text-gray-400">
                Aucune notification
              </div>
            )}
          </div>
        </div>
      )}
    </div>
  );
}


================================================================================

===== C:\wamp64\www\75Tribune\src\components\pricing\PricingCard.tsx =====

'use client';

import { Button } from "@/components/ui/button";
import { Check, Star } from "lucide-react";
import { motion } from "framer-motion";
import { cn } from "@/lib/utils";

interface PricingFeature {
  text: string;
  included: boolean;
}

interface PricingCardProps {
  title: string;
  price: string;
  description: string;
  features: PricingFeature[];
  isPopular?: boolean;
  buttonText?: string;
  onSubscribe?: () => void;
  index?: number;
}

export default function PricingCard({
  title,
  price,
  description,
  features,
  isPopular = false,
  buttonText = "Choisir",
  onSubscribe,
  index = 0,
}: PricingCardProps) {
  return (
    <motion.div
      initial={{ opacity: 0, y: 20 }}
      animate={{ opacity: 1, y: 0 }}
      transition={{ duration: 0.5, delay: index * 0.1 }}
      className={cn(
        "relative rounded-2xl border p-8",
        isPopular
          ? "border-primary-500 bg-primary-500/5 shadow-lg shadow-primary-500/20"
          : "border-border bg-card"
      )}
    >
      {isPopular && (
        <div className="absolute -top-5 left-0 right-0 mx-auto w-fit">
          <motion.div
            initial={{ opacity: 0, y: 10 }}
            animate={{ opacity: 1, y: 0 }}
            transition={{ delay: 0.2 }}
            className="flex items-center gap-1 rounded-full bg-primary-500 px-3 py-1 text-sm font-medium text-white"
          >
            <Star className="h-3.5 w-3.5" />
            Plus populaire
          </motion.div>
        </div>
      )}

      <div className="space-y-6">
        <div>
          <h3 className="text-2xl font-bold">{title}</h3>
          <p className="mt-2 text-muted-foreground">{description}</p>
        </div>

        <div className="flex items-baseline">
          <span className="text-4xl font-bold">{price}</span>
          {price !== "Gratuit" && <span className="ml-1 text-muted-foreground">/mois</span>}
        </div>

        <motion.ul 
          className="space-y-3"
          initial="hidden"
          animate="show"
          variants={{
            hidden: {},
            show: {
              transition: {
                staggerChildren: 0.1,
                delayChildren: 0.3,
              },
            },
          }}
        >
          {features.map((feature, idx) => (
            <motion.li
              key={idx}
              variants={{
                hidden: { opacity: 0, x: -10 },
                show: { opacity: 1, x: 0 },
              }}
              className="flex items-center gap-3"
            >
              <div
                className={cn(
                  "flex h-6 w-6 shrink-0 items-center justify-center rounded-full",
                  feature.included
                    ? "bg-primary-500"
                    : "bg-muted"
                )}
              >
                <Check className={cn(
                  "h-4 w-4",
                  feature.included ? "text-white" : "text-muted-foreground/40"
                )} />
              </div>
              <span className={cn(
                "text-sm",
                !feature.included && "text-muted-foreground"
              )}>
                {feature.text}
              </span>
            </motion.li>
          ))}
        </motion.ul>

        <Button
          onClick={onSubscribe}
          className={cn(
            "w-full",
            isPopular
              ? "bg-primary-500 text-white hover:bg-primary-600"
              : "bg-card"
          )}
          variant={isPopular ? "default" : "outline"}
          size="lg"
        >
          {buttonText}
        </Button>
      </div>
    </motion.div>
  );
}


================================================================================

===== C:\wamp64\www\75Tribune\src\components\shared\ImageUpload.tsx =====

'use client';

import { useState } from 'react';
import { Upload, X } from 'lucide-react';
import Image from 'next/image';
import { Button } from '@/components/ui/button';
import { normalizeImagePath } from '@/lib/image';

interface ImageUploadProps {
  value?: string;
  onChange: (url: string) => void;
  onRemove: () => void;
}

export default function ImageUpload({ value, onChange, onRemove }: ImageUploadProps) {
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const handleUpload = async (e: React.ChangeEvent<HTMLInputElement>) => {
    const file = e.target.files?.[0];
    if (!file) return;

    try {
      setLoading(true);
      setError(null);

      const formData = new FormData();
      formData.append('file', file);

      const response = await fetch('/api/upload', {
        method: 'POST',
        body: formData,
      });

      if (!response.ok) {
        throw new Error('Erreur lors de l\'upload');
      }

      const data = await response.json();
      console.log('Image uploadée:', data);
      
      // Utiliser la fonction de normalisation pour le chemin
      onChange(normalizeImagePath(data.url));
    } catch (error) {
      console.error('Erreur upload:', error);
      setError('Erreur lors du téléchargement de l\'image');
    } finally {
      setLoading(false);
    }
  };

  return (
    <div className="flex flex-col items-center justify-center w-full">
      {error && (
        <div className="w-full p-4 mb-4 text-sm text-red-600 bg-red-100 rounded-lg">
          {error}
        </div>
      )}
      <div className="w-full p-4 border-2 border-dashed rounded-lg border-gray-300 dark:border-gray-600">
        {value ? (
          <div className="relative aspect-video w-full">
            <Image
              src={normalizeImagePath(value)}
              alt="Image téléchargée"
              fill
              className="object-cover rounded-lg"
              onError={(e) => {
                console.error('Erreur de chargement de l\'image:', value);
                setError('Impossible de charger l\'image');
              }}
            />
            <button
              onClick={onRemove}
              className="absolute top-2 right-2 p-1 rounded-full bg-red-500 text-white hover:bg-red-600"
              type="button"
            >
              <X className="h-4 w-4" />
            </button>
          </div>
        ) : (
          <div className="flex flex-col items-center justify-center py-6">
            <Upload className="h-10 w-10 text-gray-400 dark:text-gray-500 mb-2" />
            <p className="text-sm text-gray-600 dark:text-gray-400">
              Glissez-déposez une image ici ou
            </p>
            <div className="mt-2">
              <Button
                disabled={loading}
                variant="outline"
                size="sm"
                onClick={() => document.getElementById('imageUpload')?.click()}
                type="button"
              >
                {loading ? 'Chargement...' : 'Sélectionnez un fichier'}
              </Button>
            </div>
          </div>
        )}
        <input
          id="imageUpload"
          type="file"
          accept="image/*"
          className="hidden"
          onChange={handleUpload}
          disabled={loading}
        />
      </div>
    </div>
  );
}


================================================================================

===== C:\wamp64\www\75Tribune\src\components\test\TestAuth.tsx =====

'use client';

import { useState } from 'react';
import { useRouter } from 'next/navigation';

interface AuthResponse {
  user?: {
    id: string;
    email: string;
    role: string;
  };
  error?: string;
}

export default function TestAuth() {
  const router = useRouter();
  const [loading, setLoading] = useState(false);
  const [result, setResult] = useState<AuthResponse | null>(null);

  // Test Register
  const testRegister = async () => {
    setLoading(true);
    try {
      const response = await fetch('/api/auth/register', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          email: `test${Date.now()}@example.com`,
          password: 'Test123!',
          name: 'Test User',
        }),
      });
      const data = await response.json();
      setResult(data);
      if (data.user) {
        console.log('✅ Register test passed');
      } else {
        console.log('❌ Register test failed');
      }
    } catch (error) {
      setResult({ error: 'Register failed' });
      console.log('❌ Register test failed with error:', error);
    } finally {
      setLoading(false);
    }
  };

  // Test Login
  const testLogin = async () => {
    setLoading(true);
    try {
      const response = await fetch('/api/auth/login', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          email: 'test@example.com',
          password: 'Test123!',
        }),
      });
      const data = await response.json();
      setResult(data);
      if (data.user) {
        console.log('✅ Login test passed');
      } else {
        console.log('❌ Login test failed');
      }
    } catch (error) {
      setResult({ error: 'Login failed' });
      console.log('❌ Login test failed with error:', error);
    } finally {
      setLoading(false);
    }
  };

  // Test Logout
  const testLogout = async () => {
    setLoading(true);
    try {
      const response = await fetch('/api/auth/logout', {
        method: 'POST',
      });
      const data = await response.json();
      setResult(data);
      if (data.success) {
        console.log('✅ Logout test passed');
        router.push('/login');
      } else {
        console.log('❌ Logout test failed');
      }
    } catch (error) {
      setResult({ error: 'Logout failed' });
      console.log('❌ Logout test failed with error:', error);
    } finally {
      setLoading(false);
    }
  };

  // Test Protected Route
  const testProtectedRoute = async () => {
    setLoading(true);
    try {
      const response = await fetch('/api/articles', {
        method: 'GET',
      });
      const data = await response.json();
      setResult(data);
      if (response.ok) {
        console.log('✅ Protected route test passed');
      } else {
        console.log('❌ Protected route test failed');
      }
    } catch (error) {
      setResult({ error: 'Protected route test failed' });
      console.log('❌ Protected route test failed with error:', error);
    } finally {
      setLoading(false);
    }
  };

  return (
    <div className="space-y-4">
      <div className="flex flex-col gap-4">
        <button
          onClick={testRegister}
          disabled={loading}
          className="px-4 py-2 bg-green-500 text-white rounded hover:bg-green-600 disabled:opacity-50"
        >
          Test Register
        </button>

        <button
          onClick={testLogin}
          disabled={loading}
          className="px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600 disabled:opacity-50"
        >
          Test Login
        </button>

        <button
          onClick={testLogout}
          disabled={loading}
          className="px-4 py-2 bg-red-500 text-white rounded hover:bg-red-600 disabled:opacity-50"
        >
          Test Logout
        </button>

        <button
          onClick={testProtectedRoute}
          disabled={loading}
          className="px-4 py-2 bg-purple-500 text-white rounded hover:bg-purple-600 disabled:opacity-50"
        >
          Test Protected Route
        </button>
      </div>

      {loading && (
        <div className="text-gray-600">Chargement...</div>
      )}

      {result && (
        <div className="mt-4 p-4 bg-gray-100 rounded">
          <pre className="whitespace-pre-wrap">
            {JSON.stringify(result, null, 2)}
          </pre>
        </div>
      )}
    </div>
  );
}


================================================================================

===== C:\wamp64\www\75Tribune\src\components\theme\ThemeToggle.tsx =====

'use client';

import { useTheme } from 'next-themes';
import { useEffect, useState } from 'react';
import { Sun, Moon } from 'lucide-react';

export function ThemeToggle() {
  const [mounted, setMounted] = useState(false);
  const { theme, setTheme } = useTheme();

  // Éviter l'hydration mismatch
  useEffect(() => {
    setMounted(true);
  }, []);

  if (!mounted) {
    return null;
  }

  return (
    <button
      onClick={() => setTheme(theme === 'dark' ? 'light' : 'dark')}
      className="rounded-md p-2 hover:bg-gray-100 dark:hover:bg-gray-800 focus:outline-none"
      aria-label="Toggle theme"
    >
      {theme === 'dark' ? (
        <Sun className="h-5 w-5 text-gray-600 dark:text-gray-400" />
      ) : (
        <Moon className="h-5 w-5 text-gray-600 dark:text-gray-400" />
      )}
    </button>
  );
}


================================================================================

===== C:\wamp64\www\75Tribune\src\hooks\use-toast.ts =====

import { useToast as useToastUI } from "@/components/ui/use-toast";

export interface Toast {
  title?: string;
  description?: string;
  variant?: "default" | "destructive";
}

export const useToast = () => {
  const { toast: toastUI } = useToastUI();

  const toast = ({ title, description, variant = "default" }: Toast) => {
    toastUI({
      title,
      description,
      variant,
    });
  };

  return { toast };
};


================================================================================

===== C:\wamp64\www\75Tribune\src\hooks\useArticles.ts =====

'use client';

import { useState, useEffect } from 'react';
import type { Article } from '@/types/article';

interface UseArticlesOptions {
  page?: number;
  limit?: number;
  status?: string;
  accessLevel?: string;
}

interface ArticlesResponse {
  articles: Article[];
  total: number;
  page: number;
  limit: number;
  totalPages: number;
}

export function useArticles(options: UseArticlesOptions = {}) {
  const [articles, setArticles] = useState<Article[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [total, setTotal] = useState(0);
  const [totalPages, setTotalPages] = useState(0);

  const fetchArticles = async () => {
    try {
      setLoading(true);
      const queryParams = new URLSearchParams();
      if (options.page) queryParams.set('page', options.page.toString());
      if (options.limit) queryParams.set('limit', options.limit.toString());
      if (options.status) queryParams.set('status', options.status);

      // On ne filtre plus par accessLevel ici car c'est géré dans la page de détail
      console.log('Fetching articles with params:', queryParams.toString());

      const response = await fetch(`/api/articles?${queryParams.toString()}`);
      if (!response.ok) {
        throw new Error('Erreur lors de la récupération des articles');
      }

      const data: ArticlesResponse = await response.json();
      console.log('Received articles:', data.articles.length);
      setArticles(data.articles || []);
      setTotal(data.total || 0);
      setTotalPages(data.totalPages || 0);
    } catch (err) {
      console.error('Erreur:', err);
      setError(err instanceof Error ? err.message : 'Une erreur est survenue');
    } finally {
      setLoading(false);
    }
  };

  useEffect(() => {
    fetchArticles();
  }, [options.page, options.limit, options.status]);

  const deleteArticle = async (id: string) => {
    try {
      const response = await fetch(`/api/articles/${id}`, {
        method: 'DELETE',
      });

      if (!response.ok) {
        throw new Error('Erreur lors de la suppression de l\'article');
      }

      // Rafraîchir la liste après la suppression
      await fetchArticles();
      return true;
    } catch (err) {
      console.error('Erreur lors de la suppression:', err);
      throw err;
    }
  };

  return {
    articles,
    loading,
    error,
    total,
    totalPages,
    deleteArticle,
    refetch: fetchArticles
  };
}


================================================================================

===== C:\wamp64\www\75Tribune\src\hooks\useAuth.ts =====

import { create } from 'zustand';
import { createJSONStorage, persist } from 'zustand/middleware';
import type { AuthResponse } from '@/types/auth';

interface AuthState {
  user: AuthResponse['user'] | null;
  token: string | null;
  setAuth: (auth: AuthResponse | null) => void;
  logout: () => void;
}

export const useAuth = create<AuthState>()(
  persist(
    (set) => ({
      user: null,
      token: null,
      setAuth: (auth) =>
        set({
          user: auth?.user || null,
          token: auth?.token || null,
        }),
      logout: () =>
        set({
          user: null,
          token: null,
        }),
    }),
    {
      name: 'auth-storage',
      storage: createJSONStorage(() => sessionStorage),
    }
  )
);


================================================================================

===== C:\wamp64\www\75Tribune\src\hooks\useRole.ts =====

'use client';

import { useAuth } from './useAuth';
import type { Role } from '@/middlewares/withRoleCheck';

export function useRole() {
  const { user } = useAuth();

  const hasRole = (roles: Role | Role[]): boolean => {
    if (!user) return false;
    
    const userRole = user.role as Role;
    if (Array.isArray(roles)) {
      return roles.includes(userRole);
    }
    return roles === userRole;
  };

  const isAdmin = (): boolean => {
    return hasRole('ADMIN');
  };

  const isUser = (): boolean => {
    return hasRole('USER');
  };

  return {
    hasRole,
    isAdmin,
    isUser,
  };
}


================================================================================

===== C:\wamp64\www\75Tribune\src\hooks\useUsers.ts =====

import { useState, useEffect } from 'react';
import { Role, SubscriptionType } from '@prisma/client';
import { toast } from 'react-hot-toast';

interface User {
  id: string;
  email: string;
  name: string | null;
  role: Role;
  subscriptionType: SubscriptionType;
  emailVerified: boolean;
  lastLogin: Date | null;
  createdAt: Date;
  updatedAt: Date;
}

export function useUsers() {
  const [users, setUsers] = useState<User[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  const fetchUsers = async () => {
    try {
      setLoading(true);
      const response = await fetch('/api/users');
      if (!response.ok) {
        throw new Error('Erreur lors de la récupération des utilisateurs');
      }
      const data = await response.json();
      setUsers(data);
    } catch (err) {
      console.error('Erreur:', err);
      setError(err instanceof Error ? err.message : 'Une erreur est survenue');
    } finally {
      setLoading(false);
    }
  };

  const createUser = async (userData: {
    email: string;
    password: string;
    name?: string;
    role?: Role;
    subscriptionType?: SubscriptionType;
  }) => {
    try {
      const response = await fetch('/api/users', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(userData),
      });

      if (!response.ok) {
        const error = await response.json();
        throw new Error(error.error || 'Erreur lors de la création');
      }

      const { user } = await response.json();
      setUsers(prev => [...prev, user]);
      toast.success('Utilisateur créé avec succès');
      return user;
    } catch (err) {
      console.error('Erreur création:', err);
      toast.error(err instanceof Error ? err.message : 'Erreur lors de la création');
      throw err;
    }
  };

  const updateUser = async (
    id: string,
    userData: {
      email?: string;
      name?: string;
      role?: Role;
      subscriptionType?: SubscriptionType;
      password?: string;
    }
  ) => {
    try {
      const response = await fetch(`/api/users/${id}`, {
        method: 'PUT',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(userData),
      });

      if (!response.ok) {
        const error = await response.json();
        throw new Error(error.error || 'Erreur lors de la mise à jour');
      }

      const { user } = await response.json();
      setUsers(prev => prev.map(u => (u.id === id ? user : u)));
      toast.success('Utilisateur mis à jour avec succès');
      return user;
    } catch (err) {
      console.error('Erreur mise à jour:', err);
      toast.error(err instanceof Error ? err.message : 'Erreur lors de la mise à jour');
      throw err;
    }
  };

  const deleteUser = async (id: string) => {
    try {
      const response = await fetch(`/api/users/${id}`, {
        method: 'DELETE',
      });

      if (!response.ok) {
        const error = await response.json();
        throw new Error(error.error || 'Erreur lors de la suppression');
      }

      setUsers(prev => prev.filter(user => user.id !== id));
      toast.success('Utilisateur supprimé avec succès');
    } catch (err) {
      console.error('Erreur suppression:', err);
      toast.error(err instanceof Error ? err.message : 'Erreur lors de la suppression');
      throw err;
    }
  };

  useEffect(() => {
    fetchUsers();
  }, []);

  return {
    users,
    loading,
    error,
    createUser,
    updateUser,
    deleteUser,
    refetch: fetchUsers,
  };
}


================================================================================

===== C:\wamp64\www\75Tribune\src\lib\auth.ts =====

import { NextAuthOptions } from 'next-auth';
import { PrismaAdapter } from '@auth/prisma-adapter';
import { prisma } from './prisma';
import CredentialsProvider from 'next-auth/providers/credentials';
import { hashPassword, comparePasswords, createToken, setAuthCookie, removeAuthCookie, verifyToken } from './auth.utils';
import { Adapter } from 'next-auth/adapters';
import { randomBytes } from 'crypto';
import { Role, SubscriptionType } from '@prisma/client';

// Définir le type de session étendu
declare module 'next-auth' {
  interface Session {
    user: {
      id: string;
      email: string;
      name: string;
      role: Role;
      avatar: string | null;
      subscriptionType: SubscriptionType;
    }
  }
}

export const authOptions: NextAuthOptions = {
  adapter: PrismaAdapter(prisma) as Adapter,
  session: {
    strategy: 'jwt',
    maxAge: 30 * 24 * 60 * 60, // 30 days
  },
  pages: {
    signIn: '/login',
    error: '/login',
    signOut: '/',
  },
  callbacks: {
    async jwt({ token, user, trigger, session }) {
      console.log('JWT Callback - Input:', { token, user, trigger, session });
      
      if (trigger === 'update' && session) {
        console.log('JWT Update triggered with session:', session);
        // Mettre à jour directement à partir de la session
        token.name = session.user.name;
        token.email = session.user.email;
        token.avatar = session.user.avatar;
        token.role = session.user.role;
        token.subscriptionType = session.user.subscriptionType;

        console.log('JWT token updated from session:', token);
      } else if (user) {
        token.id = user.id;
        token.email = user.email;
        token.name = user.name;
        token.role = user.role;
        token.avatar = user.avatar;
        token.subscriptionType = user.subscriptionType || 'FREE';
        console.log('JWT token updated from user:', token);
      }
      
      console.log('JWT Callback - Output token:', token);
      return token;
    },
    async session({ token, session }) {
      console.log('Session Callback - Input:', { token, session });
      
      if (token && session.user) {
        // Récupérer les données les plus récentes de l'utilisateur
        const user = await prisma.user.findUnique({
          where: { id: token.id as string },
          select: {
            id: true,
            email: true,
            name: true,
            role: true,
            avatar: true,
            subscriptionType: true
          }
        });
        
        console.log('Fresh user data from database:', user);
        
        if (user) {
          session.user = {
            id: user.id,
            email: user.email,
            name: user.name || '', // Garantir une chaîne non-null
            role: user.role,
            avatar: user.avatar,
            subscriptionType: user.subscriptionType
          };
        } else {
          console.warn('User not found in database:', token.id);
        }
      }
      
      console.log('Session Callback - Output:', session);
      return session;
    },
  },
  providers: [
    CredentialsProvider({
      name: 'credentials',
      credentials: {
        email: { label: 'Email', type: 'email' },
        password: { label: 'Password', type: 'password' },
      },
      async authorize(credentials) {
        try {
          console.log('Authorize attempt with credentials:', { email: credentials?.email });

          if (!credentials?.email || !credentials?.password) {
            console.log('Missing credentials');
            throw new Error('Email ou mot de passe incorrect');
          }

          const user = await prisma.user.findUnique({
            where: { 
              email: credentials.email.toLowerCase(),
            },
            select: {
              id: true,
              email: true,
              name: true,
              role: true,
              password: true,
              avatar: true,
              subscriptionType: true,
              emailVerified: true
            },
          });

          console.log('User found:', { user: user ? { ...user, password: '[HIDDEN]' } : null });

          if (!user || !user.password) {
            console.log('User not found or no password');
            throw new Error('Email ou mot de passe incorrect');
          }

          const isPasswordValid = await comparePasswords(credentials.password, user.password);
          console.log('Password validation:', { isValid: isPasswordValid });

          if (!isPasswordValid) {
            console.log('Invalid password');
            throw new Error('Email ou mot de passe incorrect');
          }

          if (!user.emailVerified) {
            console.log('Email not verified');
            throw new Error('Veuillez vérifier votre email avant de vous connecter');
          }

          console.log('Authorization successful');
          return {
            id: user.id,
            email: user.email,
            name: user.name || '',
            role: user.role,
            avatar: user.avatar,
            subscriptionType: user.subscriptionType || 'FREE'
          };
        } catch (error) {
          console.error('Auth error:', error);
          throw new Error(error instanceof Error ? error.message : 'Une erreur est survenue');
        }
      },
    }),
  ],
  secret: process.env.NEXTAUTH_SECRET,
  debug: process.env.NODE_ENV === 'development',
};

export {
  hashPassword,
  comparePasswords,
  createToken,
  setAuthCookie,
  removeAuthCookie,
  verifyToken,
};


================================================================================

===== C:\wamp64\www\75Tribune\src\lib\auth.utils.ts =====

import { cookies } from 'next/headers';
import { SignJWT, jwtVerify } from 'jose';
import bcrypt from 'bcryptjs';
import { AuthUser } from '@/types/auth';
import crypto from 'crypto';
import { NextResponse } from 'next/server';
import { Role } from '@prisma/client';

const JWT_SECRET = new TextEncoder().encode(process.env.JWT_SECRET || 'your-secret-key');

export async function hashPassword(password: string): Promise<string> {
  const salt = await bcrypt.genSalt(10);
  return bcrypt.hash(password, salt);
}

export async function comparePasswords(password: string, hashedPassword: string): Promise<boolean> {
  return bcrypt.compare(password, hashedPassword);
}

export async function createToken(user: AuthUser): Promise<string> {
  console.log('Creating token for user:', {
    id: user.id,
    email: user.email,
    role: user.role
  });
  return new SignJWT({ 
    id: user.id,
    email: user.email,
    role: user.role 
  })
    .setProtectedHeader({ alg: 'HS256' })
    .setIssuedAt()
    .setExpirationTime('24h')
    .sign(JWT_SECRET);
}

export function setAuthCookie(response: NextResponse, token: string): NextResponse {
  response.cookies.set('auth-token', token, {
    httpOnly: true,
    secure: process.env.NODE_ENV === 'production',
    sameSite: 'lax',
    maxAge: 60 * 60 * 24, // 24 hours
    path: '/',
  });
  return response;
}

export function removeAuthCookie(): void {
  cookies().delete('auth-token');
}

interface JWTPayloadWithUser {
  id: string;
  email: string;
  role: Role;
  exp: number;
  [key: string]: unknown;
}

export async function verifyToken(token: string): Promise<JWTPayloadWithUser | null> {
  try {
    const verified = await jwtVerify(token, JWT_SECRET);
    const payload = verified.payload as unknown as JWTPayloadWithUser;
    
    console.log('Token payload:', payload);
    
    // Vérifier que les champs requis sont présents
    if (!payload.id || !payload.email || !payload.role) {
      console.log('Missing required fields in token');
      return null;
    }
    
    return payload;
  } catch (error) {
    console.error('Token verification error:', error);
    return null;
  }
}

export async function getAuthUser(): Promise<AuthUser | null> {
  try {
    console.log('=== getAuthUser Start ===');
    const token = cookies().get('auth-token');
    console.log('Found token:', token?.value ? 'yes' : 'no');
    
    if (!token) {
      console.log('No token found');
      return null;
    }

    console.log('Verifying token...');
    const verified = await verifyToken(token.value);
    console.log('Token verification result:', verified);
    
    if (!verified) {
      console.log('Token verification failed');
      return null;
    }

    const user = {
      id: verified.id,
      email: verified.email,
      role: verified.role as Role,
    };
    console.log('User from token:', user);
    return user;
  } catch (error) {
    console.error('Error in getAuthUser:', error);
    return null;
  } finally {
    console.log('=== getAuthUser End ===');
  }
}

export async function generateVerificationToken(): Promise<string> {
  return crypto.randomBytes(32).toString('hex');
}


================================================================================

===== C:\wamp64\www\75Tribune\src\lib\email.ts =====

import nodemailer from 'nodemailer';

interface EmailOptions {
  to: string;
  subject: string;
  text: string;
  html: string;
}

export async function sendEmail({ to, subject, text, html }: EmailOptions) {
  const transporter = nodemailer.createTransport({
    host: process.env.SMTP_HOST,
    port: Number(process.env.SMTP_PORT),
    secure: process.env.SMTP_SECURE === 'true',
    auth: {
      user: process.env.SMTP_USER,
      pass: process.env.SMTP_PASSWORD,
    },
  });

  try {
    const info = await transporter.sendMail({
      from: process.env.SMTP_FROM || '"75Tribune" <no-reply@75Tribune.io>',
      to,
      subject,
      text,
      html,
    });

    console.log('Email envoyé:', info.messageId);
    return info;
  } catch (error) {
    console.error('Erreur lors de l\'envoi de l\'email:', error);
    throw error;
  }
}


================================================================================

===== C:\wamp64\www\75Tribune\src\lib\image.ts =====

/**
 * Nettoie et normalise un chemin d'image
 * @param path Chemin de l'image à nettoyer
 * @returns Chemin normalisé
 */
export function normalizeImagePath(path: string | undefined | null): string {
  if (!path) return '';
  
  // Si c'est une URL complète, la retourner telle quelle
  if (path.startsWith('http')) return path;
  
  // Supprimer les slashes au début et à la fin
  let cleanPath = path.trim().replace(/^\/+|\/+$/g, '');
  
  // Supprimer tous les "uploads/" multiples
  cleanPath = cleanPath.replace(/^(uploads\/)+/, '');
  
  // Si le chemin ne commence pas par "uploads/", l'ajouter
  if (!cleanPath.startsWith('uploads/')) {
    cleanPath = `uploads/${cleanPath}`;
  }
  
  // Ajouter un seul slash au début
  return `/${cleanPath}`;
}


================================================================================

===== C:\wamp64\www\75Tribune\src\lib\prisma.ts =====

import { PrismaClient } from '@prisma/client';

export const prisma = new PrismaClient();


================================================================================

===== C:\wamp64\www\75Tribune\src\lib\utils.ts =====

import { type ClassValue, clsx } from 'clsx';
import { twMerge } from 'tailwind-merge';

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs));
}

export const formatDate = (date: Date | string | null) => {
  if (!date) return '';
  const d = new Date(date);
  return new Intl.DateTimeFormat('fr-FR', {
    day: '2-digit',
    month: '2-digit',
    year: 'numeric',
    hour: '2-digit',
    minute: '2-digit',
  }).format(d);
};


================================================================================

===== C:\wamp64\www\75Tribune\src\lib\validations\category.ts =====

import { z } from 'zod';

export const createCategorySchema = z.object({
  name: z.string().min(2, 'Le nom doit contenir au moins 2 caractères'),
  description: z.string().optional(),
  parentId: z.string().nullable().optional(),
  order: z.number().int().min(0).optional(),
  isActive: z.boolean().optional()
});

export const updateCategorySchema = z.object({
  id: z.string(),
  name: z.string().min(2, 'Le nom doit contenir au moins 2 caractères').optional(),
  description: z.string().optional(),
  parentId: z.string().nullable().optional(),
  order: z.number().int().min(0).optional(),
  isActive: z.boolean().optional()
});

export type CreateCategoryInput = z.infer<typeof createCategorySchema>;
export type UpdateCategoryInput = z.infer<typeof updateCategorySchema>;


================================================================================

===== C:\wamp64\www\75Tribune\src\middlewares\withRoleCheck.ts =====

import { NextResponse } from 'next/server';
import { getAuthUser } from '@/lib/auth.utils';
import { Role } from '@prisma/client';

type HandlerFunction = (
  request: Request,
  context: any
) => Promise<NextResponse>;

export function withRoleCheck(allowedRoles: Role[], handler: HandlerFunction) {
  return async (request: Request, context: any) => {
    try {
      console.log('=== withRoleCheck Start ===');
      
      // Vérifier l'authentification
      const user = await getAuthUser();
      console.log('User from getAuthUser:', user);

      if (!user) {
        console.log('No user found, returning 401');
        return NextResponse.json(
          { error: 'Non autorisé - Authentification requise' },
          { status: 401 }
        );
      }

      // Vérifier si le rôle de l'utilisateur est dans la liste des rôles autorisés
      const isAllowed = allowedRoles.includes(user.role);
      console.log('User role:', user.role);
      console.log('Allowed roles:', allowedRoles);
      console.log('Is role allowed:', isAllowed);

      if (!isAllowed) {
        console.log('User role not allowed');
        return NextResponse.json(
          { error: 'Non autorisé - Rôle insuffisant' },
          { status: 403 }
        );
      }

      console.log('Role check passed, proceeding with handler');
      return handler(request, context);
    } catch (error) {
      console.error('Error in withRoleCheck:', error);
      return NextResponse.json(
        { error: 'Erreur serveur' },
        { status: 500 }
      );
    } finally {
      console.log('=== withRoleCheck End ===');
    }
  };
}


================================================================================

===== C:\wamp64\www\75Tribune\src\providers\AuthProvider.tsx =====

'use client';

import { createContext, useContext, useState, useEffect } from 'react';
import { useSession, signOut } from 'next-auth/react';
import { useRouter } from 'next/navigation';

interface AuthContextType {
  user: any;
  loading: boolean;
  error: string | null;
  clearAuth: () => Promise<void>;
}

const AuthContext = createContext<AuthContextType>({
  user: null,
  loading: true,
  error: null,
  clearAuth: async () => {},
});

export function AuthProvider({ children }: { children: React.ReactNode }) {
  const { data: session, status } = useSession();
  const router = useRouter();
  const loading = status === 'loading';

  const clearAuth = async () => {
    try {
      await signOut({ redirect: false });
      router.push('/login');
    } catch (error) {
      console.error('Logout error:', error);
    }
  };

  return (
    <AuthContext.Provider 
      value={{ 
        user: session?.user || null,
        loading,
        error: null,
        clearAuth
      }}
    >
      {children}
    </AuthContext.Provider>
  );
}

export function useAuth() {
  const context = useContext(AuthContext);
  if (!context) {
    throw new Error('useAuth must be used within an AuthProvider');
  }
  return context;
}


================================================================================

===== C:\wamp64\www\75Tribune\src\providers\Providers.tsx =====

'use client';

import { SessionProvider } from 'next-auth/react';
import { ThemeProvider } from '@/providers/ThemeProvider';
import { AuthProvider } from '@/providers/AuthProvider';

export default function Providers({ children }: { children: React.ReactNode }) {
  return (
    <ThemeProvider attribute="class" defaultTheme="system" enableSystem disableTransitionOnChange>
      <SessionProvider>
        <AuthProvider>
          {children}
        </AuthProvider>
      </SessionProvider>
    </ThemeProvider>
  );
}


================================================================================

===== C:\wamp64\www\75Tribune\src\providers\ThemeProvider.tsx =====

'use client';

import { ThemeProvider as NextThemesProvider } from 'next-themes';
import type { ThemeProviderProps } from 'next-themes';

export function ThemeProvider({ children, ...props }: ThemeProviderProps) {
  return (
    <NextThemesProvider
      attribute="class"
      defaultTheme="system"
      enableSystem
      disableTransitionOnChange
      {...props}
    >
      {children}
    </NextThemesProvider>
  );
}


================================================================================

===== C:\wamp64\www\75Tribune\src\services\article.service.ts =====

import { PrismaClient, ArticleStatus, AccessLevel } from '@prisma/client';
import { Article, ArticleWithRelations, Platform } from '@/types/article';
import slugify from 'slugify';
import { normalizeImagePath } from '@/lib/image';
import { prisma } from '@/lib/prisma';

const extractFirstImage = (content: string): string | undefined => {
  const imgMatch = content.match(/<img[^>]+src="([^">]+)"/);
  return imgMatch ? imgMatch[1] : undefined;
};

export class ArticleService {
  static async getAll() {
    try {
      const articles = await prisma.article.findMany({
        include: {
          tags: true,
          categories: true,
          author: {
            select: {
              id: true,
              name: true,
              email: true,
            },
          },
        },
        orderBy: {
          updatedAt: 'desc',
        },
      });

      return articles.map(article => this.enrichArticle(article));
    } catch (error) {
      console.error('Erreur dans ArticleService.getAll:', error);
      throw error;
    }
  }

  static async getById(id: string) {
    try {
      const article = await prisma.article.findUnique({
        where: { id },
        include: {
          tags: true,
          categories: true,
          author: {
            select: {
              id: true,
              name: true,
              email: true,
            },
          },
        },
      });

      if (!article) {
        return null;
      }

      return this.enrichArticle(article);
    } catch (error) {
      console.error('Erreur dans ArticleService.getById:', error);
      throw error;
    }
  }

  static async getBySlug(slug: string) {
    try {
      const article = await prisma.article.findUnique({
        where: { slug },
        include: {
          tags: true,
          categories: true,
          author: {
            select: {
              id: true,
              name: true,
              email: true,
            },
          },
        },
      });

      if (!article) {
        return null;
      }

      return this.enrichArticle(article);
    } catch (error) {
      console.error('Erreur dans ArticleService.getBySlug:', error);
      throw error;
    }
  }

  static async create({
    title,
    content,
    excerpt = '',
    status,
    accessLevel,
    tags = [],
    categories = [],
    authorId,
    publishPlatforms = [],
    featuredImage,
  }: {
    title: string;
    content: string;
    excerpt?: string;
    status: ArticleStatus;
    accessLevel: AccessLevel;
    tags?: string[];
    categories?: string[];
    authorId: string;
    publishPlatforms?: Platform[];
    featuredImage?: string;
  }) {
    try {
      // Generate slug from title
      let slug = slugify(title, { lower: true, strict: true });
      let slugExists = true;
      let slugCounter = 1;

      // Keep checking until we find a unique slug
      while (slugExists) {
        const existingArticle = await prisma.article.findUnique({
          where: { slug },
        });
        if (!existingArticle) {
          slugExists = false;
        } else {
          slug = `${slugify(title, { lower: true, strict: true })}-${slugCounter}`;
          slugCounter++;
        }
      }

      // Gérer les tags
      const tagIds = await Promise.all(
        tags.map(async (tagName) => {
          const tag = await prisma.tag.upsert({
            where: { name: tagName },
            update: {},
            create: {
              name: tagName,
              slug: slugify(tagName, { lower: true, strict: true }),
            },
          });
          return tag.id;
        })
      );

      // Vérification des catégories par ID (et non par nom, comme dans votre version)
      const validCategories = await Promise.all(
        categories.map(async (categoryId) => {
          const category = await prisma.category.findUnique({
            where: { id: categoryId },
          });
          if (!category) {
            throw new Error(`Category not found: ${categoryId}`);
          }
          return category.id;
        })
      );
      const categoryIds = validCategories.filter((id): id is string => id !== null);

      const article = await prisma.article.create({
        data: {
          title,
          slug,
          content,
          excerpt,
          status,
          accessLevel,
          publishPlatforms: publishPlatforms as any,
          featuredImage,
          author: {
            connect: { id: authorId },
          },
          tags: {
            connect: tagIds.map((id) => ({ id })),
          },
          categories: {
            connect: categoryIds.map((id) => ({ id })),
          },
        },
        include: {
          tags: true,
          categories: true,
          author: {
            select: {
              id: true,
              name: true,
              email: true,
            },
          },
        },
      });

      return this.enrichArticle(article);
    } catch (error) {
      console.error('Erreur dans ArticleService.create:', error);
      throw error;
    }
  }

  static async update({
    id,
    title,
    content,
    excerpt,
    status,
    accessLevel,
    tags = [],
    categories = [],
    publishPlatforms = [],
    featuredImage,
  }: {
    id: string;
    title?: string;
    content?: string;
    excerpt?: string;
    status?: ArticleStatus;
    accessLevel?: AccessLevel;
    tags?: string[];
    categories?: string[];
    publishPlatforms?: Platform[];
    featuredImage?: string;
  }) {
    console.log('ArticleService.update - Starting update with data:', {
      id,
      title,
      excerpt,
      status,
      accessLevel,
      tags,
      categories,
      publishPlatforms,
      featuredImage: featuredImage ? '[Image présente]' : '[Pas d\'image]',
    });

    try {
      // 1. Vérifier si l'article existe
      const existingArticle = await prisma.article.findUnique({
        where: { id },
        include: {
          tags: true,
          categories: true,
        },
      });

      if (!existingArticle) {
        throw new Error('Article non trouvé');
      }

      let slug;
      if (title && title !== existingArticle.title) {
        // Generate new slug only if title is being updated
        slug = slugify(title, { lower: true, strict: true });
        let slugExists = true;
        let slugCounter = 1;

        // Keep checking until we find a unique slug
        while (slugExists) {
          const existingArticleWithSlug = await prisma.article.findFirst({
            where: {
              slug,
              NOT: { id },
            },
          });
          if (!existingArticleWithSlug) {
            slugExists = false;
          } else {
            slug = `${slugify(title, { lower: true, strict: true })}-${slugCounter}`;
            slugCounter++;
          }
        }
      }

      // Gérer les tags si fournis
      const tagIds = tags.length > 0
        ? await Promise.all(
            tags.map(async (tagName) => {
              const tag = await prisma.tag.upsert({
                where: { name: tagName },
                update: {},
                create: {
                  name: tagName,
                  slug: slugify(tagName, { lower: true, strict: true }),
                },
              });
              return tag.id;
            })
          )
        : undefined;

      // Vérifier les catégories par ID si elles sont fournies
      const validCategories = categories.length > 0
        ? await Promise.all(
            categories.map(async (categoryId) => {
              const category = await prisma.category.findUnique({
                where: { id: categoryId },
              });
              if (!category) {
                throw new Error(`Category not found: ${categoryId}`);
              }
              return category.id;
            })
          )
        : undefined;
      const validCategoryIds = validCategories?.filter((id): id is string => id !== null);

      const updateData: any = {
        ...(title && { title }),
        ...(slug && { slug }),
        ...(content && { content }),
        ...(excerpt !== undefined && { excerpt }),
        ...(status && { status }),
        ...(accessLevel && { accessLevel }),
        ...(publishPlatforms && { publishPlatforms }),
        ...(featuredImage !== undefined && { featuredImage }),
      };

      if (tagIds) {
        updateData.tags = {
          set: [],
          connect: tagIds.map((id) => ({ id })),
        };
      }

      if (validCategoryIds && validCategoryIds.length > 0) {
        updateData.categories = {
          set: [],
          connect: validCategoryIds.map((id) => ({ id })),
        };
      }

      console.log('ArticleService.update - Final update data:', {
        ...updateData,
        tags: updateData.tags ? '[Tags présents]' : '[Pas de tags]',
        categories: updateData.categories ? '[Categories présentes]' : '[Pas de categories]',
      });

      const article = await prisma.article.update({
        where: { id },
        data: updateData,
        include: {
          tags: true,
          categories: true,
          author: {
            select: {
              id: true,
              name: true,
              email: true,
            },
          },
        },
      });

      const enrichedArticle = this.enrichArticle(article);
      console.log('ArticleService.update - Update successful');

      return enrichedArticle;
    } catch (error) {
      console.error('Erreur dans ArticleService.update:', error);
      throw error;
    }
  }

  static async list({
    status,
    accessLevel,
    authorId,
    where = {},
    page = 1,
    limit = 10,
  }: {
    status?: ArticleStatus;
    accessLevel?: AccessLevel;
    authorId?: string;
    where?: any;
    page?: number;
    limit?: number;
  }) {
    try {
      const skip = (page - 1) * limit;

      console.log('ArticleService.list - Input parameters:', {
        status,
        accessLevel,
        authorId,
        where,
        page,
        limit,
      });

      // Fusionner les conditions de base avec les conditions personnalisées
      const whereConditions = {
        ...where,
        ...(status && { status }),
        ...(accessLevel && { accessLevel }),
        ...(authorId && { authorId }),
      };

      console.log('ArticleService.list - Final where conditions:', JSON.stringify(whereConditions, null, 2));

      // Récupérer le total d'articles
      const total = await prisma.article.count({ where: whereConditions });
      console.log('ArticleService.list - Total articles found:', total);

      // Récupérer les articles avec pagination
      const articles = await prisma.article.findMany({
        where: whereConditions,
        include: {
          tags: true,
          categories: true,
          author: {
            select: {
              id: true,
              name: true,
              email: true,
            },
          },
        },
        orderBy: {
          updatedAt: 'desc',
        },
        skip,
        take: limit,
      });

      console.log('ArticleService.list - Articles retrieved:', articles.length);

      // Enrichir les articles
      const enrichedArticles = articles.map(article => this.enrichArticle(article));

      return {
        articles: enrichedArticles,
        pagination: {
          total,
          page,
          limit,
          totalPages: Math.ceil(total / limit),
        },
      };
    } catch (error) {
      console.error('Erreur dans ArticleService.list:', error);
      throw error;
    }
  }

  static async delete(id: string) {
    try {
      await prisma.article.delete({
        where: { id },
      });
    } catch (error) {
      console.error('Erreur dans ArticleService.delete:', error);
      throw error;
    }
  }

  private static enrichArticle(article: any): ArticleWithRelations {
    // Calculer la date de publication
    const publishedAt = article.status === 'PUBLISHED' ? article.updatedAt : null;

    // Normaliser le chemin de l'image mise en avant
    const featuredImage = article.featuredImage ? normalizeImagePath(article.featuredImage) : undefined;

    // Extraire l'image principale si elle n'est pas définie
    if (!featuredImage && article.content) {
      const extractedImage = extractFirstImage(article.content);
      if (extractedImage) {
        article.featuredImage = extractedImage;
      }
    }

    return {
      ...article,
      publishedAt,
      featuredImage,
    };
  }
}

================================================================================

===== C:\wamp64\www\75Tribune\src\services\articleView.service.ts =====

import { prisma } from '@/lib/prisma';

export class ArticleViewService {
  static async addView(articleId: string, userId?: string, ip?: string) {
    try {
      await prisma.articleView.create({
        data: {
          articleId,
          viewedBy: userId,
          ip,
        },
      });
    } catch (error) {
      console.error('Erreur dans ArticleViewService.addView:', error);
      throw error;
    }
  }

  static async getViewsCount(articleId: string) {
    try {
      return await prisma.articleView.count({
        where: { articleId },
      });
    } catch (error) {
      console.error('Erreur dans ArticleViewService.getViewsCount:', error);
      throw error;
    }
  }

  static async getTotalViewsCount() {
    try {
      return await prisma.articleView.count();
    } catch (error) {
      console.error('Erreur dans ArticleViewService.getTotalViewsCount:', error);
      throw error;
    }
  }

  static async getViewsCountForPeriod(startDate: Date, endDate: Date) {
    try {
      return await prisma.articleView.count({
        where: {
          viewedAt: {
            gte: startDate,
            lte: endDate,
          },
        },
      });
    } catch (error) {
      console.error('Erreur dans ArticleViewService.getViewsCountForPeriod:', error);
      throw error;
    }
  }
}


================================================================================

===== C:\wamp64\www\75Tribune\src\services\category.service.ts =====

import { prisma } from '@/lib/prisma';
import slugify from 'slugify';
import { Category, Prisma } from '@prisma/client';

export interface CreateCategoryDTO {
  name: string;
  description?: string;
  parentId?: string;
  order?: number;
  isActive?: boolean;
}

export interface UpdateCategoryDTO extends Partial<CreateCategoryDTO> {
  id: string;
}

export interface CategoryTree extends Category {
  children?: CategoryTree[];
  _count?: {
    articles: number;
    children: number;
  };
}

export class CategoryService {
  async findAll(activeOnly = false) {
    const where: Prisma.CategoryWhereInput = activeOnly 
      ? { isActive: true }
      : {};

    return prisma.category.findMany({
      where,
      orderBy: {
        order: 'asc'
      },
      include: {
        parent: true,
        _count: {
          select: {
            articles: true,
            children: true
          }
        }
      }
    });
  }

  async findById(id: string) {
    return prisma.category.findUnique({
      where: { id },
      include: {
        parent: true,
        _count: {
          select: {
            articles: true,
            children: true
          }
        }
      }
    });
  }

  async findBySlug(slug: string) {
    return prisma.category.findFirst({
      where: { 
        slug,
        isActive: true
      },
      include: {
        parent: true,
        _count: {
          select: {
            articles: true,
            children: true
          }
        }
      }
    });
  }

  async create(data: CreateCategoryDTO): Promise<Category> {
    const slug = slugify(data.name, { lower: true, strict: true });
    
    return prisma.category.create({
      data: {
        ...data,
        slug,
      },
      include: {
        parent: true,
        _count: {
          select: {
            articles: true,
            children: true
          }
        }
      }
    });
  }

  async update(data: UpdateCategoryDTO): Promise<Category> {
    const { id, ...updateData } = data;
    const slug = updateData.name ? slugify(updateData.name, { lower: true, strict: true }) : undefined;

    return prisma.category.update({
      where: { id },
      data: {
        ...updateData,
        slug,
      },
      include: {
        parent: true,
        _count: {
          select: {
            articles: true,
            children: true
          }
        }
      }
    });
  }

  async delete(id: string) {
    const category = await prisma.category.findUnique({
      where: { id },
      include: {
        _count: {
          select: {
            articles: true,
            children: true
          }
        }
      }
    });

    if (!category) {
      throw new Error('Category not found');
    }

    if (category._count.articles > 0 || category._count.children > 0) {
      throw new Error('Cannot delete category with articles or subcategories');
    }

    return prisma.category.delete({
      where: { id }
    });
  }

  async reorder(categories: { id: string; order: number }[]) {
    const updates = categories.map(({ id, order }) => 
      prisma.category.update({
        where: { id },
        data: { order }
      })
    );

    return prisma.$transaction(updates);
  }

  async getTree(activeOnly = false): Promise<CategoryTree[]> {
    const where: Prisma.CategoryWhereInput = {
      parent: null,
      ...(activeOnly && { isActive: true })
    };

    const categories = await prisma.category.findMany({
      where,
      orderBy: {
        order: 'asc'
      },
      include: {
        children: {
          include: {
            children: {
              include: {
                _count: {
                  select: {
                    articles: true,
                    children: true
                  }
                }
              }
            },
            _count: {
              select: {
                articles: true,
                children: true
              }
            }
          },
          orderBy: {
            order: 'asc'
          },
          ...(activeOnly && {
            where: { isActive: true }
          })
        },
        _count: {
          select: {
            articles: true,
            children: true
          }
        }
      }
    });

    return categories as CategoryTree[];
  }
}


================================================================================

===== C:\wamp64\www\75Tribune\src\services\upload.service.ts =====

import fs from 'fs';
import path from 'path';
import { randomUUID } from 'crypto';

export class UploadService {
  private static UPLOAD_DIR = path.join(process.cwd(), 'public', 'uploads');
  private static ALLOWED_TYPES = ['image/jpeg', 'image/png', 'image/gif', 'image/webp'];
  private static MAX_SIZE = 5 * 1024 * 1024; // 5MB

  static async initialize() {
    // Créer le dossier uploads s'il n'existe pas
    if (!fs.existsSync(this.UPLOAD_DIR)) {
      fs.mkdirSync(this.UPLOAD_DIR, { recursive: true });
    }
  }

  static async saveImage(file: File): Promise<string> {
    await this.initialize();

    // Vérifier le type de fichier
    if (!this.ALLOWED_TYPES.includes(file.type)) {
      throw new Error('Type de fichier non autorisé');
    }

    // Vérifier la taille du fichier
    if (file.size > this.MAX_SIZE) {
      throw new Error('Fichier trop volumineux (max 5MB)');
    }

    // Générer un nom de fichier unique
    const extension = path.extname(file.name);
    const fileName = `${randomUUID()}${extension}`;
    const filePath = path.join(this.UPLOAD_DIR, fileName);

    // Lire le buffer du fichier
    const buffer = Buffer.from(await file.arrayBuffer());

    // Sauvegarder le fichier
    fs.writeFileSync(filePath, buffer);

    // Retourner le chemin relatif pour l'accès via URL
    return `/uploads/${fileName}`;
  }

  static async deleteImage(fileName: string): Promise<void> {
    const filePath = path.join(this.UPLOAD_DIR, path.basename(fileName));
    
    if (fs.existsSync(filePath)) {
      fs.unlinkSync(filePath);
    }
  }

  static getImagePath(fileName: string): string {
    return path.join(this.UPLOAD_DIR, path.basename(fileName));
  }
}


================================================================================

===== C:\wamp64\www\75Tribune\src\services\user.service.ts =====

import { prisma } from '@/lib/prisma';
import { Role, SubscriptionType, User } from '@prisma/client';
import { hash } from 'bcryptjs';

export interface UserWithoutPassword {
  id: string;
  email: string;
  name: string | null;
  role: Role;
  subscriptionType: SubscriptionType;
  emailVerified: boolean;
  lastLogin: Date | null;
  createdAt: Date;
  updatedAt: Date;
}

export class UserService {
  static async list() {
    try {
      const users = await prisma.user.findMany({
        orderBy: {
          createdAt: 'desc',
        },
        select: {
          id: true,
          email: true,
          name: true,
          role: true,
          subscriptionType: true,
          emailVerified: true,
          lastLogin: true,
          createdAt: true,
          updatedAt: true,
        },
      });

      return users;
    } catch (error) {
      console.error('Erreur dans UserService.list:', error);
      throw error;
    }
  }

  static async getById(id: string): Promise<UserWithoutPassword | null> {
    try {
      const user = await prisma.user.findUnique({
        where: { id },
        select: {
          id: true,
          email: true,
          name: true,
          role: true,
          subscriptionType: true,
          emailVerified: true,
          lastLogin: true,
          createdAt: true,
          updatedAt: true,
        },
      });

      return user;
    } catch (error) {
      console.error('Erreur dans UserService.getById:', error);
      throw error;
    }
  }

  static async create({
    email,
    password,
    name,
    role = 'USER',
    subscriptionType = 'FREE',
  }: {
    email: string;
    password: string;
    name?: string;
    role?: Role;
    subscriptionType?: SubscriptionType;
  }) {
    try {
      const hashedPassword = await hash(password, 12);

      const user = await prisma.user.create({
        data: {
          email,
          password: hashedPassword,
          name: name || null,
          role,
          subscriptionType,
        },
        select: {
          id: true,
          email: true,
          name: true,
          role: true,
          subscriptionType: true,
          emailVerified: true,
          lastLogin: true,
          createdAt: true,
          updatedAt: true,
        },
      });

      return user;
    } catch (error) {
      console.error('Erreur dans UserService.create:', error);
      throw error;
    }
  }

  static async update({
    id,
    email,
    name,
    role,
    subscriptionType,
    password,
  }: {
    id: string;
    email?: string;
    name?: string;
    role?: Role;
    subscriptionType?: SubscriptionType;
    password?: string;
  }) {
    try {
      const updateData: any = {};
      if (email) updateData.email = email;
      if (name !== undefined) updateData.name = name;
      if (role) updateData.role = role;
      if (subscriptionType) updateData.subscriptionType = subscriptionType;
      if (password) {
        updateData.password = await hash(password, 12);
      }

      const user = await prisma.user.update({
        where: { id },
        data: updateData,
        select: {
          id: true,
          email: true,
          name: true,
          role: true,
          subscriptionType: true,
          emailVerified: true,
          lastLogin: true,
          createdAt: true,
          updatedAt: true,
        },
      });

      return user;
    } catch (error) {
      console.error('Erreur dans UserService.update:', error);
      throw error;
    }
  }

  static async delete(id: string) {
    try {
      await prisma.user.delete({
        where: { id },
      });
    } catch (error) {
      console.error('Erreur dans UserService.delete:', error);
      throw error;
    }
  }
}


================================================================================

===== C:\wamp64\www\75Tribune\src\services\publishers\LocalPublisher.ts =====

import { Publisher, PublishContent, PublishResult } from './types';
import { prisma } from '@/lib/prisma';

export class LocalPublisher implements Publisher {
  async publish(content: PublishContent): Promise<PublishResult> {
    try {
      // Logique de publication locale
      return {
        success: true,
        url: `/articles/${content.slug}`,
        platformId: 'local'
      };
    } catch (error) {
      console.error('Erreur publication locale:', error);
      return {
        success: false,
        error: 'Erreur lors de la publication locale'
      };
    }
  }

  isEnabled(): boolean {
    return true;
  }
}


================================================================================

===== C:\wamp64\www\75Tribune\src\services\publishers\PublishingService.ts =====

import { Publisher, PublishContent, PublishResult, PublishDestination } from './types';
import { LocalPublisher } from './LocalPublisher';
import { WordPressPublisher } from './WordPressPublisher';
import { YouTubePublisher } from './YouTubePublisher';
import { TwitterPublisher } from './TwitterPublisher';

export class PublishingService {
  private publishers: Map<PublishDestination['platform'], Publisher>;

  constructor() {
    this.publishers = new Map();
    // Le publisher local est toujours disponible
    this.publishers.set('local', new LocalPublisher());
    
    // Initialiser les autres publishers
    this.publishers.set('wordpress', new WordPressPublisher());
    this.publishers.set('youtube', new YouTubePublisher());
    this.publishers.set('twitter', new TwitterPublisher());
  }

  async publish(
    content: PublishContent,
    destinations: PublishDestination[]
  ): Promise<Map<string, PublishResult>> {
    const results = new Map<string, PublishResult>();

    // S'assurer que la publication locale est toujours incluse
    if (!destinations.some(d => d.platform === 'local')) {
      destinations.push({ platform: 'local', enabled: true });
    }

    // Publier sur chaque plateforme activée
    for (const destination of destinations) {
      if (!destination.enabled) continue;

      const publisher = this.publishers.get(destination.platform);
      if (!publisher) {
        results.set(destination.platform, {
          success: false,
          error: `Publisher not found for platform: ${destination.platform}`,
        });
        continue;
      }

      if (!publisher.isEnabled()) {
        results.set(destination.platform, {
          success: false,
          error: `Publisher ${destination.platform} is not properly configured`,
        });
        continue;
      }

      try {
        const result = await publisher.publish(content);
        results.set(destination.platform, result);
      } catch (error) {
        results.set(destination.platform, {
          success: false,
          error: error instanceof Error ? error.message : 'Unknown error',
        });
      }
    }

    return results;
  }

  getAvailablePublishers(): PublishDestination[] {
    return Array.from(this.publishers.entries()).map(([platform, publisher]) => ({
      platform,
      enabled: publisher.isEnabled(),
    }));
  }
}


================================================================================

===== C:\wamp64\www\75Tribune\src\services\publishers\TwitterPublisher.ts =====

import { Publisher, PublishContent, PublishResult } from './types';
import { TwitterApi } from 'twitter-api-v2';

export class TwitterPublisher implements Publisher {
  private client: TwitterApi | null = null;

  constructor() {
    if (this.isEnabled()) {
      this.client = new TwitterApi({
        appKey: process.env.TWITTER_API_KEY!,
        appSecret: process.env.TWITTER_API_SECRET!,
        accessToken: process.env.TWITTER_ACCESS_TOKEN,
      });
    }
  }

  async publish(content: PublishContent): Promise<PublishResult> {
    if (!this.isEnabled() || !this.client) {
      return {
        success: false,
        error: 'Twitter credentials not configured',
      };
    }

    try {
      // Créer le tweet avec le titre et l'extrait
      const tweetText = `${content.title}\n\n${content.excerpt}`;
      
      // Si on a une image, on la poste d'abord
      let mediaIds = [];
      if (content.featuredImage) {
        const mediaId = await this.client.v1.uploadMedia(content.featuredImage);
        mediaIds.push(mediaId);
      }

      // Poster le tweet
      const tweetParams: any = {
        text: tweetText
      };

      if (mediaIds.length > 0) {
        tweetParams.media = { 
          media_ids: mediaIds.slice(0, 4) as [string, string?, string?, string?]
        };
      }

      const tweet = await this.client.v2.tweet(tweetParams);

      return {
        success: true,
        url: `https://twitter.com/user/status/${tweet.data.id}`,
        platformId: tweet.data.id,
      };
    } catch (error) {
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Unknown error',
      };
    }
  }

  isEnabled(): boolean {
    return Boolean(
      process.env.TWITTER_API_KEY &&
      process.env.TWITTER_API_SECRET &&
      process.env.TWITTER_ACCESS_TOKEN
    );
  }
}


================================================================================

===== C:\wamp64\www\75Tribune\src\services\publishers\types.ts =====

export interface PublishDestination {
  platform: 'local' | 'wordpress' | 'youtube' | 'twitter';
  enabled: boolean;
}

export interface PublishContent {
  title: string;
  excerpt: string;
  content: string;
  slug: string;
  featuredImage?: string;
  tags?: string[];
  categories?: string[];
  videoUrl?: string;
}

export interface PublishResult {
  success: boolean;
  url?: string;
  error?: string;
  platformId?: string;
}

export interface Publisher {
  publish(content: PublishContent): Promise<PublishResult>;
  isEnabled(): boolean;
}


================================================================================

===== C:\wamp64\www\75Tribune\src\services\publishers\WordPressPublisher.ts =====

import { Publisher, PublishContent, PublishResult } from './types';
import fs from 'fs';
import path from 'path';
import { PrismaClient } from '@prisma/client';

export class WordPressPublisher implements Publisher {
  private apiUrl: string;
  private apiUser: string;
  private apiKey: string;
  private prisma: PrismaClient;

  constructor() {
    this.apiUrl = process.env.WORDPRESS_API_URL || '';
    this.apiUser = process.env.WORDPRESS_API_USERNAME || '';
    this.apiKey = process.env.WORDPRESS_API_PASSWORD || '';
    this.prisma = new PrismaClient();
  }

  /** Vérifie si les identifiants WordPress sont correctement configurés */
  public isEnabled(): boolean {
    return !!(this.apiUrl && this.apiUser && this.apiKey);
  }

  async publish(content: PublishContent): Promise<PublishResult> {
    if (!this.isEnabled()) {
      return { success: false, error: 'WordPress credentials not configured' };
    }

    try {
      // Log pour vérifier les données reçues
      console.log('Données reçues dans publish :', content);

      // Convertir les IDs de catégories en noms de catégories
      const categoryNames = await this.getCategoryNames(content.categories || []);
      console.log('Noms de catégories résolus :', categoryNames);
      
      const categoryIds = await this.resolveCategoryIds(categoryNames);
      let tagIds: number[] = [];
      
      if (content.tags && content.tags.length > 0) {
        tagIds = await this.resolveTagIds(content.tags);
      }

      let featuredMediaId: number | undefined;
      if (typeof content.featuredImage === 'number') {
        featuredMediaId = content.featuredImage;
      } else if (typeof content.featuredImage === 'string' && content.featuredImage.trim() !== '') {
        featuredMediaId = await this.uploadMediaToWordPress(content.featuredImage);
      }

      const postData: Record<string, any> = {
        title: content.title,
        content: content.content,
        excerpt: content.excerpt || '',
        status: 'publish',
        categories: categoryIds,
        tags: tagIds,
        slug: content.slug,
      };

      if (featuredMediaId !== undefined) {
        postData.featured_media = featuredMediaId;
      }

      const response = await fetch(`${this.apiUrl}/wp-json/wp/v2/posts`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': 'Basic ' + Buffer.from(`${this.apiUser}:${this.apiKey}`).toString('base64'),
        },
        body: JSON.stringify(postData),
      });

      const responseText = await response.text();
      console.log('Réponse API WordPress :', responseText);

      if (!response.ok) {
        throw new Error(`WordPress API error: ${response.status} ${response.statusText} – ${responseText}`);
      }

      const data = JSON.parse(responseText);
      return { success: true, url: data.link, platformId: data.id.toString() };
    } catch (error) {
      console.error('Erreur lors de la publication sur WordPress :', error);
      return { success: false, error: error instanceof Error ? error.message : String(error) };
    }
  }

  /** Récupère les noms des catégories à partir de leurs IDs */
  private async getCategoryNames(categoryIds: string[]): Promise<string[]> {
    try {
      const categories = await this.prisma.category.findMany({
        where: {
          id: { in: categoryIds }
        },
        select: {
          name: true
        }
      });
      
      return categories.map(cat => cat.name);
    } catch (error) {
      console.error('Erreur lors de la récupération des noms de catégories :', error);
      throw error;
    }
  }

  /** Résout un tableau de noms de catégories en leurs IDs WordPress */
  private async resolveCategoryIds(categoryNames: string[]): Promise<number[]> {
    const ids: number[] = [];
    for (const catName of categoryNames) {
      const id = await this.getOrCreateCategory(catName);
      ids.push(id);
    }
    return ids;
  }

  /** Récupère ou crée une catégorie par son nom */
  private async getOrCreateCategory(catName: string): Promise<number> {
    const slug = this.slugify(catName);
    let res = await fetch(`${this.apiUrl}/wp-json/wp/v2/categories?slug=${slug}`, {
      headers: { 'Authorization': 'Basic ' + Buffer.from(`${this.apiUser}:${this.apiKey}`).toString('base64') },
    });

    if (!res.ok) {
      throw new Error(`Erreur lors de la vérification de la catégorie '${catName}' (${res.statusText})`);
    }

    const list = await res.json();
    if (Array.isArray(list) && list.length > 0) {
      return list[0].id;
    }

    res = await fetch(`${this.apiUrl}/wp-json/wp/v2/categories`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': 'Basic ' + Buffer.from(`${this.apiUser}:${this.apiKey}`).toString('base64'),
      },
      body: JSON.stringify({ name: catName, slug: slug }),
    });

    if (!res.ok) {
      throw new Error(`Erreur lors de la création de la catégorie '${catName}' (${res.statusText})`);
    }

    const newCat = await res.json();
    return newCat.name;
  }

  /** Résout un tableau de noms de tags en leurs IDs WordPress */
  private async resolveTagIds(tagNames: string[]): Promise<number[]> {
    const ids: number[] = [];
    
    // Traiter correctement les tags qui peuvent être des chaînes ou un tableau
    const tagsArray: string[] = [];
    
    for (const tagItem of tagNames) {
      if (typeof tagItem === 'string') {
        // Si le tag contient des virgules, le diviser
        if (tagItem.includes(',')) {
          const splitTags = tagItem.split(',').map((t: string) => t.trim()).filter(Boolean);
          tagsArray.push(...splitTags);
        } else {
          tagsArray.push(tagItem.trim());
        }
      }
    }
    
    for (const tagName of tagsArray) {
      if (!tagName) continue;
      const slug = this.slugify(tagName);
      let res = await fetch(`${this.apiUrl}/wp-json/wp/v2/tags?slug=${slug}`, {
        headers: { 'Authorization': 'Basic ' + Buffer.from(`${this.apiUser}:${this.apiKey}`).toString('base64') },
      });

      if (!res.ok) {
        throw new Error(`Erreur lors de la vérification du tag '${tagName}' (${res.statusText})`);
      }

      const existingTags = await res.json();
      if (Array.isArray(existingTags) && existingTags.length > 0) {
        ids.push(existingTags[0].id);
      } else {
        res = await fetch(`${this.apiUrl}/wp-json/wp/v2/tags`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': 'Basic ' + Buffer.from(`${this.apiUser}:${this.apiKey}`).toString('base64'),
          },
          body: JSON.stringify({ name: tagName, slug: slug }),
        });

        if (!res.ok) {
          throw new Error(`Erreur lors de la création du tag '${tagName}' (${res.statusText})`);
        }

        const createdTag = await res.json();
        ids.push(createdTag.id);
      }
    }
    return ids;
  }

  /** Télécharge une image vers WordPress et retourne son ID */
  private async uploadMediaToWordPress(imagePath: string): Promise<number> {
    const fullImagePath = path.resolve(process.cwd(), 'public', imagePath.startsWith('/') ? imagePath.substring(1) : imagePath);

    if (!fs.existsSync(fullImagePath)) {
      throw new Error(`Le fichier image est introuvable : ${fullImagePath}`);
    }

    const mediaUrl = `${this.apiUrl}/wp-json/wp/v2/media`;
    const fileName = path.basename(fullImagePath);
    const fileData = fs.readFileSync(fullImagePath);

    const res = await fetch(mediaUrl, {
      method: 'POST',
      headers: {
        'Authorization': 'Basic ' + Buffer.from(`${this.apiUser}:${this.apiKey}`).toString('base64'),
        'Content-Disposition': `attachment; filename="${fileName}"`,
        'Content-Type': this.getMimeType(fileName),
      },
      body: fileData,
    });

    if (!res.ok) {
      throw new Error(`Erreur lors de l'upload de l'image vers WordPress (${res.statusText})`);
    }

    const uploadedMedia = await res.json();
    return uploadedMedia.id;
  }

  /** Détecte le type MIME selon l'extension du fichier */
  private getMimeType(fileName: string): string {
    const ext = path.extname(fileName).toLowerCase();
    switch (ext) {
      case '.jpeg':
      case '.jpg':
        return 'image/jpeg';
      case '.png':
        return 'image/png';
      case '.gif':
        return 'image/gif';
      case '.webp':
        return 'image/webp';
      default:
        throw new Error(`Format d'image non pris en charge : ${ext}`);
    }
  }

  /** Génère un slug à partir d'un nom */
  private slugify(str: string): string {
    return str
      .toLowerCase()
      .normalize('NFD')
      .replace(/[\u0300-\u036f]/g, '')
      .replace(/\s+/g, '-')
      .replace(/[^a-z0-9-_]/g, '');
  }
}


================================================================================

===== C:\wamp64\www\75Tribune\src\services\publishers\YouTubePublisher.ts =====

// C:\wamp64\www\75Tribune\src\services\publishers\YouTubePublisher.ts

import { Publisher, PublishContent, PublishResult } from './types';
import { google } from 'googleapis';
import fs from 'fs';

/**
 * YouTubePublisher
 * Publie une vidéo sur YouTube à partir d'un chemin local (videoUrl).
 */
export class YouTubePublisher implements Publisher {
  private youtube;
  private oauth2Client;

  constructor() {
    // Instancie un client OAuth2 pour YouTube
    this.oauth2Client = new google.auth.OAuth2(
      process.env.YOUTUBE_CLIENT_ID,
      process.env.YOUTUBE_CLIENT_SECRET,
      process.env.YOUTUBE_REDIRECT_URI
    );

    // Si vous avez un refresh token, vous le définissez ici
    if (process.env.YOUTUBE_REFRESH_TOKEN) {
      this.oauth2Client.setCredentials({
        refresh_token: process.env.YOUTUBE_REFRESH_TOKEN,
      });
    }

    // Initialise le client YouTube avec l'auth ci-dessus
    this.youtube = google.youtube({
      version: 'v3',
      auth: this.oauth2Client,
    });
  }

  /**
   * Publie le contenu (une vidéo locale) sur YouTube
   * @param content PublishContent: title, excerpt (description), tags, videoUrl...
   * @returns PublishResult: success, url, platformId, error
   */
  async publish(content: PublishContent): Promise<PublishResult> {
    // Vérifications basiques
    if (!this.isEnabled() || !content.videoUrl) {
      return {
        success: false,
        error: !this.isEnabled() ? 'YouTube credentials not configured' : 'No video URL provided',
      };
    }

    try {
      // Vérifier que le fichier vidéo existe localement
      const filePath = content.videoUrl;
      if (!fs.existsSync(filePath)) {
        throw new Error(`Le fichier vidéo n'existe pas : ${filePath}`);
      }

      // Envoi à l'API YouTube (videos.insert)
      const response = await this.youtube.videos.insert({
        part: ['snippet', 'status'],
        requestBody: {
          snippet: {
            title: content.title,
            description: content.excerpt || '',
            tags: content.tags || [],
          },
          status: {
            privacyStatus: 'public', // ou "unlisted", "private" selon vos besoins
          },
        },
        media: {
          // On passe un flux (stream) vers la vidéo
          body: fs.createReadStream(filePath),
        },
      });

      // Vérification du résultat
      if (!response.data.id) {
        throw new Error('No video ID returned by YouTube');
      }

      return {
        success: true,
        url: `https://youtube.com/watch?v=${response.data.id}`,
        platformId: response.data.id,
      };
    } catch (error) {
      console.error('Erreur lors de la publication sur YouTube:', error);
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Unknown error',
      };
    }
  }

  /**
   * Vérifie si les variables d'environnement nécessaires sont présentes
   */
  isEnabled(): boolean {
    return Boolean(
      process.env.YOUTUBE_CLIENT_ID &&
      process.env.YOUTUBE_CLIENT_SECRET &&
      process.env.YOUTUBE_REDIRECT_URI
    );
  }
}


================================================================================

===== C:\wamp64\www\75Tribune\src\types\article.ts =====

import { ArticleStatus, AccessLevel } from '@prisma/client';

export type Platform = 'wordpress' | 'youtube' | 'twitter';

export interface Article {
  id: string;
  title: string;
  content: string;
  excerpt: string;
  slug: string;
  status: ArticleStatus;
  accessLevel: AccessLevel;
  featuredImage?: string;
  authorId: string;
  createdAt: string;
  updatedAt: string;
  publishedAt?: string;
  publishPlatforms: Platform[];
  tags: {
    id: string;
    name: string;
    slug: string;
  }[];
  categories: {
    id: string;
    name: string;
    slug: string;
  }[];
}

export interface ArticleWithRelations extends Article {
  author?: {
    id: string;
    name: string;
    email: string;
  };
}

export interface CreateArticleDTO {
  title: string;
  content: string;
  excerpt?: string;
  status: ArticleStatus;
  accessLevel: AccessLevel;
  tags?: string[];
  categories?: string[];
  authorId: string;
  publishPlatforms?: Platform[];
  featuredImage?: string;
}

export interface UpdateArticleDTO {
  id: string;
  title: string;
  content: string;
  excerpt?: string;
  status: ArticleStatus;
  accessLevel: AccessLevel;
  tags: string[];
  categories: string[];
  publishPlatforms: Platform[];
  featuredImage?: string;
}

export type { ArticleStatus, AccessLevel };


================================================================================

===== C:\wamp64\www\75Tribune\src\types\auth.ts =====

import { Role } from '@prisma/client';

export interface AuthUser {
  id: string;
  email: string;
  role: Role;
  name: string | null | undefined;
}

export interface LoginCredentials {
  email: string;
  password: string;
}

export interface RegisterCredentials extends LoginCredentials {
  name?: string;
}

export interface AuthResponse {
  user: AuthUser;
  token: string;
}

export interface ResetPasswordCredentials {
  email: string;
  token: string;
  newPassword: string;
}

export interface User {
  id: string;
  email: string;
  name: string | null;
  emailVerified: boolean;
  image: string | null;
  role: 'USER' | 'ADMIN';
  createdAt: Date;
  updatedAt: Date;
}

export interface Session {
  user: {
    id: string;
    email: string;
    name: string | null;
    image: string | null;
    role: 'USER' | 'ADMIN';
  };
  expires: string;
}

export interface EmailVerificationToken {
  id: string;
  token: string;
  userId: string;
  expiresAt: Date;
  createdAt: Date;
  user: User;
}

export interface PasswordResetToken {
  id: string;
  token: string;
  userId: string;
  expiresAt: Date;
  createdAt: Date;
  user: User;
}

export interface SocialProvider {
  id: string;
  userId: string;
  provider: 'google' | 'github';
  providerId: string;
  accessToken: string;
  refreshToken: string | null;
  expiresAt: Date | null;
  user: User;
}


================================================================================

===== C:\wamp64\www\75Tribune\src\types\next-auth.d.ts =====

import NextAuth from "next-auth"
import { Role, SubscriptionType } from "@prisma/client"

declare module "next-auth" {
  interface User {
    id: string
    name: string
    email: string
    avatar: string | null
    role: Role
    subscriptionType: SubscriptionType
  }
  
  interface Session {
    user: {
      id: string
      name: string
      email: string
      avatar: string | null
      role: Role
      subscriptionType: SubscriptionType
    }
  }
}

declare module "next-auth/jwt" {
  interface JWT {
    id: string
    email: string
    name: string | null
    avatar: string | null
    role: Role
    subscriptionType: SubscriptionType
  }
}


================================================================================


### 131 fichiers enregistrés avec succès. ###
